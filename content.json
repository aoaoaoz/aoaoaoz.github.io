{"meta":{"title":"嗷嗷嗷's Blog","subtitle":"aoaoao's Blog","description":"算法竞赛, 数学, 怪物猎人(?)","author":"嗷嗷嗷","url":"http://aoudad.cn"},"pages":[],"posts":[{"title":"CodeforceDiv2 D Flood Fill","slug":"CodeforceDiv2-D-Flood-Fill","date":"2019-02-11T06:41:45.000Z","updated":"2019-02-11T07:20:56.571Z","comments":true,"path":"2019/02/11/CodeforceDiv2-D-Flood-Fill/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-D-Flood-Fill/","excerpt":"","text":"题意描述You are given a line of $n$ colored squares in a row, numbered from $1$ to $n$ from left to right. The $i$-th square initially has the color $c_i$.Let’s say, that two squares $i$ and $j$ belong to the same connected component if $c_i = c_j$, and $c_i = c_k$ for all $k$ satisfying $i &lt; k &lt; j$. In other words, all squares on the segment from $i$ to $j$ should have the same color.For example, the line $[3, 3, 3]$ has $1$ connected component, while the line $[5, 2, 4, 4]$ has $3$ connected components.The game “flood fill” is played on the given line as follows: At the start of the game you pick any starting square (this is not counted as a turn). Then, in each game turn, change the color of the connected component containing the starting square to any other color. Find the minimum number of turns needed for the entire line to be changed into a single color. InputThe first line contains a single integer $n$ ($1\\leq n\\leq 5000$) — the number of squares.The second line contains integers $c_1,c_2,\\dots,c_n$ ($1\\leq c_i\\leq 5000$) — the initial colors of the squares. OutputPrint a single integer — the minimum number of the turns needed. Sample Input84 5 2 2 1 3 5 5 Sample Output4 题意：有一个n单位长度的带子，每个位置上有一种颜色，定义同种颜色的块为联通快。选取一个位置作为开始，每个回合可以将包含开始位置的联通块修改成另一种颜色，问将带子变成同一种颜色至少需要多少个回合。 思路：一开始看错题目了。将数组压缩一下，考虑$dp$,$dp[i][j]$为将$i$到j这一段修改成同一种颜色的答案，那么根据$a[i]$是否等于$a[j]$可以得到三种决策: 修改成和$i,j$一样颜色的，修改成和$i$一样颜色的，修改成和$j$一样颜色的。然后就做完了…… 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 5007;int dp[maxn][maxn];int a[maxn];int dfs(int L, int R)&#123; if(L&gt;=R) return 0; if(dp[L][R]!=-1) return dp[L][R]; int res = INFI; if(a[L]==a[R]) res = dfs(L+1, R-1) + 1; else res = min(dfs(L+1, R), dfs(L, R-1))+1; return dp[L][R] = res;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n;cin &gt;&gt;n; const int S = 5000; for(int i=1;i&lt;=n;++i)cin &gt;&gt; a[i]; int tot=0; for(int i=1;i&lt;=n;++i) if(a[i]!=a[i-1])a[++tot] = a[i]; memset(dp, -1, sizeof dp); cout &lt;&lt; dfs(1, tot) &lt;&lt;endl;&#125;// 7 1 3 2 4 1 2 3// 7 5 3 5 2 4 3 4","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"CodeforceDiv2 E Arithmetic Progression","slug":"CodeforceDiv2-E-Arithmetic-Progression","date":"2019-02-11T06:41:24.000Z","updated":"2019-02-11T07:27:41.092Z","comments":true,"path":"2019/02/11/CodeforceDiv2-E-Arithmetic-Progression/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-E-Arithmetic-Progression/","excerpt":"","text":"题意：有一个长度为n的数列，如果将这个数列排序，那么它是一个等差数列，可以进行60次询问，每次询问可以给一个下标，会返回这个位置的值，可以给一个x，会返回数组中是否有大于这个数的值。求问这个等差数列的第一项和公差。 思路：二分最大值，随机出任意30个位置的值，取GCD。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////int chk(int x)&#123; cout &lt;&lt; \"&gt; \" &lt;&lt; x &lt;&lt; '\\n'; cout.flush(); int p; cin &gt;&gt; p; return p;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n; cin &gt;&gt; n; int L = 0, R = 1e9+1, mid, ans; int cnt = 0; while(L&lt;=R) &#123; ++cnt; mid = (L+R)&gt;&gt;1; if(chk(mid)) L = mid + 1, ans = mid + 1; else R = mid - 1; &#125; int res = 0; auto seed = chrono::high_resolution_clock::now().time_since_epoch().count(); mt19937 Ran(seed); for(int i=0;i&lt;60-cnt;++i) &#123; int p = Ran()%n+1; cout &lt;&lt; \"? \" &lt;&lt; p &lt;&lt; '\\n';cout.flush(); int x; cin &gt;&gt; x; if(x==ans)continue; res = (res==0)?abs(x-ans):__gcd(abs(x-ans), res); &#125; cout &lt;&lt; \"! \" &lt;&lt; ans-(n-1)*res &lt;&lt; ' ' &lt;&lt; res &lt;&lt; '\\n';cout.flush();&#125;","categories":[],"tags":[{"name":"交互题","slug":"交互题","permalink":"http://aoudad.cn/tags/交互题/"}]},{"title":"CodeforceDiv2 F Please, another Queries on Array?","slug":"CodeforceDiv2-F-Please-another-Queries-on-Array","date":"2019-02-11T06:39:59.000Z","updated":"2019-02-11T07:05:30.455Z","comments":true,"path":"2019/02/11/CodeforceDiv2-F-Please-another-Queries-on-Array/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-F-Please-another-Queries-on-Array/","excerpt":"","text":"题意描述You are given an array $a_1,a_2,\\dots,a_n$.You need to perform $q$ queries of the following two types: “MULTIPLY l r x” — for every $i$ ($l\\leq i\\leq r$) multiply $a_i$ by $x$. “TOTIENT l r” — print $\\phi(\\Pi_{i=l}^{r}a_i)$ taken modulo $10^9+7$, where $\\phi$ denotes $Euler’s totient function$.The $Euler’s totient function$ of a positive integer $n$ (denoted as $\\phi(n)$) is the number of integers $x$ ($1\\leq x\\leq n$) such that $gcd(n,x)=1$. InputThe first line contains two integers $n$ and $q$ ($1\\leq n\\leq 4⋅10^5$, $1\\leq q\\leq 2⋅10^5$) — the number of elements in array $a$ and the number of queries.The second line contains $n$ integers $a_1,a_2,\\dots,a_n$ ($1\\leq a_i\\leq 300$) — the elements of array $a$.Then $q$ lines follow, describing queries in the format given in the statement. “MULTIPLY l r x” ($1\\leq l\\leq r\\leq n$, $1\\leq x\\leq 300$) — denotes a multiplication query. “TOTIENT l r” ($1\\leq l\\leq r\\leq n$) — denotes a query on the value of Euler’s totient function.It is guaranteed that there is at least one “TOTIENT” query. OutputFor each “TOTIENT” query, print the answer to it. Sample Input4 45 9 1 2TOTIENT 3 3TOTIENT 3 4MULTIPLY 4 4 3TOTIENT 4 4 Sample Output112 题意：数据结构题，两种操作，第一种操作是对一个区间内的每个数乘以一个小于$300$的数，第二种操作是查询一个区间内所有数的乘积的欧拉函数值。 思路：设该区间内所有数的乘积是M，那么其实\\phi(M) = \\Sigma_{M\\%p==0 \\&\\& p 素数}\\frac{p-1}{p}，所以只需要预处理出300以内的素数有哪些（62个），每次维护区间内包含哪些素因子就可以了。这里有一个or-tree，也就是用long long的每个bit表示一个素因子，构建一颗线段树维护就可以了，写起来很简单。不过好像有点小卡常。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;const ll mod = 1e9+7;ll pro[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2], a[maxn];ll q_p(ll base, ll n)&#123;ll res=1;for(;n;n&gt;&gt;=1, base=base*base%mod)if(n&amp;1)res= res*base%mod;return res;&#125;void pushup(int rt)&#123;pro[rt]=pro[rt&lt;&lt;1]*pro[rt&lt;&lt;1|1]%mod;&#125;void pushdown(int rt, int len)&#123; if(lazy[rt]&gt;1) &#123; lazy[rt&lt;&lt;1]=lazy[rt&lt;&lt;1]*lazy[rt]%mod; lazy[rt&lt;&lt;1|1]=lazy[rt&lt;&lt;1|1]*lazy[rt]%mod; pro[rt&lt;&lt;1]=pro[rt&lt;&lt;1]*q_p(lazy[rt], (len+1)/2)%mod; pro[rt&lt;&lt;1|1]=pro[rt&lt;&lt;1|1]*q_p(lazy[rt], len&gt;&gt;1)%mod; lazy[rt]=1; &#125;&#125;void build(int l, int r, int rt)&#123; lazy[rt] = 1; if(l==r) &#123;pro[rt]=a[l];return ;&#125; int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);&#125;void update(int L, int R, int x, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;lazy[rt]=lazy[rt]*x%mod;pro[rt]=pro[rt]*q_p(x, r-l+1)%mod;return;&#125; pushdown(rt, r-l+1); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(L, R, x, lson); if(mid&lt;R) update(L, R, x, rson); pushup(rt);&#125;ll query(int L, int R, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;return pro[rt];&#125; int mid = l+r&gt;&gt;1;pushdown(rt, r-l+1); ll res = 1; if(L&lt;=mid) res = query(L, R, lson); if(mid&lt;R) res = res * query(L, R, rson) % mod; return res;&#125;char Q[30];vector&lt;int&gt; p&#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293&#125;;ll mark[maxn&lt;&lt;2], st[maxn&lt;&lt;2];int pos[403];void ppmark(int rt)&#123;mark[rt]=mark[rt&lt;&lt;1]|mark[rt&lt;&lt;1|1];&#125;void pdmark(int rt)&#123; if(st[rt]==0) return; st[rt&lt;&lt;1] |= st[rt]; st[rt&lt;&lt;1|1]|=st[rt]; mark[rt&lt;&lt;1] |= st[rt]; mark[rt&lt;&lt;1|1] |= st[rt];&#125;void updatem(int L, int R, ll M, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;st[rt]|=M;mark[rt]|=M;return;&#125; int mid = l+r&gt;&gt;1;pdmark(rt); if(L&lt;=mid) updatem(L, R, M, lson); if(mid&lt;R) updatem(L, R, M, rson); ppmark(rt);&#125;ll queryor(int L, int R, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;return mark[rt];&#125; int mid = l+r&gt;&gt;1;pdmark(rt); ll res = 0; if(L&lt;=mid) res = queryor(L, R, lson); if(mid&lt;R) res |= queryor(L, R, rson); return res;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m; int len = 62; for(int i=0;i&lt;len;++i) pos[p[i]] = i; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\", a+i); ll M = 0, x = a[i]; for(int j=2;j*j&lt;=x;++j) &#123; if(x%j==0) &#123; M |= 1LL&lt;&lt;pos[j]; while(x%j==0) x/=j; &#125; &#125; if(x&gt;1)M |= 1LL&lt;&lt;pos[x]; updatem(i, i, M, 1, n, 1);// error(i, M, a[i]); &#125; build(1, n, 1); for(int i=0;i&lt;m;++i) &#123; scanf(\"%s\", Q); if(Q[0]=='T') &#123; int L, R; scanf(\"%d%d\", &amp;L, &amp;R); ll tmp = query(L, R, 1, n, 1); ll M = queryor(L, R, 1, n, 1);// error(tmp, M); for(int j=0;j&lt;62;++j) if((M&gt;&gt;j)&amp;1) tmp = tmp*(p[j]-1)%mod*q_p(p[j], mod-2)%mod; printf(\"%lld\\n\", tmp); &#125; else if(Q[0]=='M') &#123; int L, R, x; scanf(\"%d%d%d\", &amp;L, &amp;R, &amp;x); update(L, R, x, 1, n, 1); ll M = 0; for(int j=2;j*j&lt;=x;++j) &#123; if(x%j==0) &#123; M |= 1LL&lt;&lt;pos[j]; while(x%j==0) x/=j; &#125; &#125; if(x&gt;1)M |= 1LL&lt;&lt;pos[x]; updatem(L, R, M, 1, n, 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"},{"name":"数论","slug":"数论","permalink":"http://aoudad.cn/tags/数论/"}]},{"title":"Camp Day2 H Cosmic Cleaner","slug":"Camp-Day2-H-Cosmic-Cleaner","date":"2019-02-10T13:16:11.000Z","updated":"2019-02-10T13:28:16.985Z","comments":true,"path":"2019/02/10/Camp-Day2-H-Cosmic-Cleaner/","link":"","permalink":"http://aoudad.cn/2019/02/10/Camp-Day2-H-Cosmic-Cleaner/","excerpt":"","text":"题意描述在一片小行星带里有 $n$ 颗小行星，它们在万有引力的作用下绕着一颗行星旋转。在这一刻时，它们之间不存在碰撞的情况。一位清洁工奉命前来清理这颗行星，Ta 会动用某种先进技术使这颗行星顷刻间从宇宙中消失，任何距离这颗行星的中心在一定范围内的事物都会在一瞬间被清除。假设这些天体都是完整的球体，你能计算出清除的区域里有多少体积的事物原本属于这些小行星吗？ 注意，这些天体在此刻满足两两不存在交集的条件。 Input输入包含多组测试数据。第一行包含一个整数 $T$，表示测试数据的组数。随后的内容是各组测试数据。对于每组测试数据：第一行包含一个整数 $n$。接下来的 $n$ 行里，每行包含四个整数 $x, y, z$ 和 $r$，表示有一颗中心位于 $(x, y, z)$、半径为 $r$ 的小行星。最后一行包含四个整数 $x’,y’,z’$ 和 $r’$，表示行星的中心位于 $(x’,y’,z’)$，而清洁工的清理半径为 $r’$（一个大于该行星半径的值）。 $1 \\leq T \\leq 6000$ $1 \\leq n \\leq 100$ $−10^3≤x,y,z,x’,y’,z’≤10^3$ $1 \\leq r’ \\leq 10^3$ Output 对于每组测试数据，输出一行Case #x: y，其中x是测试数据的编号（从 11 开始编号），y是这组数据的答案，要求相对误差或绝对误差不超过 $10^{-6}$。严格来讲，如果你的答案是 $a$，而标准答案是 $b$，那么当 $\\frac{|a - b|}{\\max{1, |b|}} \\leq 10^{-6}$ 时你的答案会被认为是正确的。 Sample Input135 5 5 2-6 -7 6 16 -5 0 31 -1 0 10 Sample OutputCase #1: 142.76246874761383764962 题意：有$n$个小球，求这些小球被一个大球截去的总体积 思路：样例很良心，由于小球两两之间不相交，所以直接单独考虑每个小球就可以了。分三种情况，第一种相离，截取的体积为0；第二种情况，内含，截取的体积为小球的总面积；第三种情况，相交，截去的面积实际上就是两个球缺，直接套一下球缺公式就可以了。球体积公式V=\\frac{4}{3}\\pi r^3球缺公式:V=\\pi H^2(R-\\frac{H}{3})其中$H$表示球缺的高。不过这个题目我之前的写法不知道为啥一直过不了，换种写法才过。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e3+7;struct Point&#123; double x, y, z; Point(double _x=0, db _y=0, db _z=0):x(_x), y(_y), z(_z)&#123;&#125; friend Point operator-(const Point &amp;a, const Point &amp;b)&#123;return Point(a.x-b.x, a.y-b.y,a.z-b.z);&#125; friend double dot(const Point&amp;a, const Point &amp;b) &#123; return a.x*b.x+a.y*b.y+a.z*b.z; &#125;&#125;p[maxn];double r[maxn];double gettheta(double a, db b, db c)&#123;// error((a*a+b*b-c*c)/(2*a*b)); return acos((a*a+b*b-c*c)/(2*a*b));&#125;int sgn(double x)&#123;if(x&gt;eps)return 1;if(x&lt;-eps)return -1;return 0;&#125;int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int t; scanf(\"%d\", &amp;t); for(int cas=1;cas&lt;=t;++cas) &#123; int n; scanf(\"%d\", &amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lf%lf%lf%lf\", &amp;p[i].x, &amp;p[i].y, &amp;p[i].z, &amp;r[i]); &#125; Point O;double R; scanf(\"%lf%lf%lf%lf\", &amp;O.x, &amp;O.y, &amp;O.z, &amp;R); double res = 0; for(int i=1;i&lt;=n;++i) &#123; double L = sqrt(dot(O-p[i],O-p[i])); double a = r[i], b = R; if(sgn(L-a-b)&gt;=0)continue; if(sgn(b-a-L)&gt;=0) &#123;res+=PI*4/3*a*a*a;continue;&#125; double L1 = (a*a+L*L-b*b)/(2*L); double H1 = a-L1, H2 = b-(L-L1); res += PI*H1*H1*(a-H1/3); res += PI*H2*H2*(b-H2/3); &#125; printf(\"Case #%d: %.12f\\n\", cas, res); &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Codeforces 1110 E Magic Stones","slug":"Codeforces-1110-E","date":"2019-02-07T17:02:28.000Z","updated":"2019-02-07T17:22:53.630Z","comments":true,"path":"2019/02/08/Codeforces-1110-E/","link":"","permalink":"http://aoudad.cn/2019/02/08/Codeforces-1110-E/","excerpt":"","text":"题意描述Grigory has $n$ magic stones, conveniently numbered from $1$ to $n$. The charge of the $i$-th stone is equal to $c_i$.Sometimes Grigory gets bored and selects some inner stone (that is, some stone with index $i$, where $2 \\le i \\le n - 1$), and after that synchronizes it with neighboring stones. After that, the chosen stone loses its own charge, but acquires the charges from neighboring stones. In other words, its charge $c_i$ changes to $c_i’ = c_{i + 1} + c_{i - 1} - c_i$.Andrew, Grigory’s friend, also has $n$ stones with charges $t_i$. Grigory is curious, whether there exists a sequence of zero or more synchronization operations, which transforms charges of Grigory’s stones into charges of corresponding Andrew’s stones, that is, changes $c_i$ into $t_i$ for all $i$? InputThe first line contains one integer $n$ ($2\\leq n\\leq 10^5$) — the number of magic stones.The second line contains integers $c_1,c_2,\\dots,c_n$ ($0\\leq c_i\\leq 2⋅10^9$) — the charges of Grigory’s stones.The second line contains integers $t_1,t_2,\\dots,t_n$ ($0\\leq t_i\\leq 2⋅10^9$) — the charges of Andrew’s stones. OutputIf there exists a (possibly empty) sequence of synchronization operations, which changes all charges to the required ones, print “Yes”.Otherwise, print “No”. Sample Input47 2 4 127 15 10 12 Sample OutputYes Sample Input34 4 41 2 3 Sample OutputNo 题意：对于一个长度为$n$的数组$c$，对每个$2\\leq i \\leq n-1$，可以把$c[i]$替换成$c[i+1]+c[i-1]-c[i]$，可以对某个位置多次替换，问是否存在某种操作顺序可以把$c$换成数组$t$ 思路：考虑连续的三个数字$a,b,c$, 对$b$进行操作，得到$a, a+c-b, c$差分数组变为$c-b$, $b-a$，也就是说每次操作就是在交换差分数组里的相邻元素，所以只需要判断一下头尾和差分数组是否一致就可以了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;ll c[maxn], t[maxn];int vis[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; c[i]; for(int i=1;i&lt;=n;++i) cin &gt;&gt; t[i]; if(c[1]!=t[1]||c[n]!=t[n])&#123;puts(\"No\");return 0;&#125; int cnt = 2; for(int i=n;i&gt;1;--i) c[i]-=c[i-1], t[i]-=t[i-1]; sort(c+1, c+1+n); sort(t+1, t+1+n); int ok=1; for(int i=1;i&lt;=n;++i) ok &amp;= (c[i]==t[i]); puts(ok?\"Yes\":\"No\");&#125;","categories":[],"tags":[{"name":"差分","slug":"差分","permalink":"http://aoudad.cn/tags/差分/"}]},{"title":"Codeforces 1110 D","slug":"Codeforces-1110-D","date":"2019-02-07T16:37:40.000Z","updated":"2019-02-07T17:01:50.080Z","comments":true,"path":"2019/02/08/Codeforces-1110-D/","link":"","permalink":"http://aoudad.cn/2019/02/08/Codeforces-1110-D/","excerpt":"","text":"题意描述You are playing a game of Jongmah. You don’t need to know the rules to solve this problem. You have $n$ tiles in your hand. Each tile has an integer between $1$ and $m$ written on it.To win the game, you will need to form some number of triples. Each triple consists of three tiles, such that the numbers written on the tiles are either all the same or consecutive. For example, $7, 7, 7$ is a valid triple, and so is $12, 13, 14$, but $2,2,3$ or $2,4,6$ are not. You can only use the tiles in your hand to form triples. Each tile can be used in at most one triple.To determine how close you are to the win, you want to know the maximum number of triples you can form from the tiles in your hand. InputThe first line contains two integers integer $n$ and $m$($1\\leq n,m\\leq 10^6$) — the number of tiles in your hand and the number of tiles types.The second line contains integers $a_1,a_2,\\dots,a_n$ ($1\\leq a_i\\leq m$), where $a_i$ denotes the number written on the $i$-th tile. OutputPrint one integer: the maximum number of triples you can form. Sample Input10 62 3 3 3 4 4 4 5 5 6 Sample Output3 Sample Input12 61 5 3 3 3 4 3 5 3 2 3 3 Sample Output3 Sample Input13 51 1 5 1 2 3 3 2 4 2 3 4 5 Sample Output4 题意：给一个$cnt$数组，数组大小为$m$，每次可以选择连续的三个位置且这些位置上的数字都大于$0$，分别对他们的值$-1$，或者选择一个位置$-3$，求最多可以做多少次这样的操作。 思路：定义$dp[i][j][k]$表示考虑前i个位置，第$i-2$个位置往后取j次连续$3$个的，$i-1$个位置往后取$k$次连续$3$个的答案。则对于第$i$个位置，枚举这个位置往后取$x$次$3$个的，显然，对于$x\\geq3$的情况，可以把$x$模$3$，当当前位置上的值足够大（$\\geq j+k+x$）的时候，这个枚举是合法的，那么这时候状态转移方程就是dp[i][k][x] = max(dp[i-1][j][k] + x + (cnt[i]-j-k-x)/3)答案就是$dp[m][0][0]$，因为只需要用到$i-1$的信息，所以可以滚动数组优化一下空间 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e6+7;ll dp[2][4][4], cnt[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // ll n, m; cin &gt;&gt; n &gt;&gt; m; ll res = 0; for(int i=1;i&lt;=n;++i) &#123; int x; cin &gt;&gt; x; cnt[x]++; &#125; int t = 0; for(int i=1;i&lt;=m;++i) &#123; t = t^1; memset(dp[t], 0, sizeof dp[t]); for(int j=0;j&lt;3;++j) for(int k=0;k&lt;3;++k) for(int x=0;x&lt;3;++x) &#123; if(j+k+x&gt;cnt[i])continue; dp[t][k][x] = max(dp[t][k][x], dp[t^1][j][k] + x + (cnt[i]-j-k-x)/3); &#125; &#125; cout &lt;&lt; dp[t][0][0]&lt;&lt; endl;&#125;/*12 61 1 1 2 3 3 4 4 4 5 5 6*/","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Codeforces1111D2 E","slug":"Codeforces1111D2-E","date":"2019-02-06T08:00:49.000Z","updated":"2019-02-06T14:18:46.997Z","comments":true,"path":"2019/02/06/Codeforces1111D2-E/","link":"","permalink":"http://aoudad.cn/2019/02/06/Codeforces1111D2-E/","excerpt":"","text":"题意描述You are given a tree with $n$ nodes and $q$ queries.Every query starts with three integers $k$, $m$ and $r$, followed by $k$ nodes of the tree $a_1, a_2, \\ldots, a_k$. To answer a query, assume that the tree is rooted at $r$. We want to divide the $k$ given nodes into at most $m$ groups such that the following conditions are met: Each node should be in exactly one group and each group should have at least one node. In any group, there should be no two distinct nodes such that one node is an ancestor (direct or indirect) of the other. You need to output the number of ways modulo $10^{9}+7$ for every query. InputThe first line contains two integers $n$ and $q$ ($1\\leq n,q\\leq 10^5$) — the number of vertices in the tree and the number of queries, respectively.Each of the next $n−1$ lines contains two integers $u$ and $v$($1\\leq u,v\\leq n,u\\not=v$), denoting an edge connecting vertex $u$ and vertex $v$. It is guaranteed that the given graph is a tree.Each of the next $q$ lines starts with three integers $k$, $m$ and $r$ ($1\\leq k,r\\leq n$, $1\\leq m\\leq \\min(300,k)$) — the number of nodes, the maximum number of groups and the root of the tree for the current query, respectively. They are followed by $k$ distinct integers $a_1,a_2,\\dots,a_k$ ($1\\leq ai\\leq n$), denoting the nodes of the current query.It is guaranteed that the sum of $k$ over all queries does not exceed $10^5$. OutputPrint $q$ lines, where the $i$-th line contains the answer to the $i$-th query. Sample Input7 25 42 65 31 27 54 63 3 2 7 4 33 1 4 6 2 1 Sample Output20 Sample Input7 24 72 54 15 15 64 33 3 2 7 1 42 1 6 3 2 Sample Output11 Sample Input5 23 54 54 21 42 2 3 1 22 2 4 5 4 Sample Output21 题意：给一棵无根树，节点数小于$10^5$，q次询问，每次询问给k个点和一个根r，将这k个节点分为不多于m组，使得每个节点不与他们的祖先节点在同一组，求方案数。 思路：这道题感觉好多trick，可能是太久没训练的原因，有点迟钝。一直wa6，因为数组开小了2333。以后再出现数组开小了这种问题就打自己一耳光。先是考虑比较简单的情况，固定根节点，设$h_i$表示节点集中i节点的祖先节点数量，按$h[i]$从小到大将节点进行排序，考虑dp，设$dp[i][j]$表示前i个节点组成j组的方案数，那么这就没有后效性了，可以推出状态转移方程为dp[i][j] = dp[i-1][j-1] + dp[i-1][j]*(j-h[i])所以ans=\\Sigma_{j=1}^mdp[k][j]问题的关键就变成了怎么求$h[i]$，实际上$h[i]$就是从节点i到根节点这条简单路径上的在节点集中出现的数量。那我们就能用打标记的方法，给节点集打上标记，那$h[i]$就是一个前缀和。那么怎么维护这个东西呢，显然我们要用树状数组，另外还用到了一个很强大的东西，括号序列，这东西就像dfs序一样强大。括号序列就是dfs树的时候给每个节点记录一个进栈和出栈的值，获得的序列。给每个节点的(进栈序号)打上+1，(出栈序号+1)打上-1，那么每次查询树状数组的时候就是$h[i]+1$了。现在考虑不同根的情况，实际上这里上面的dp还是对的，而$h[i]$表示的是i到r这两个节点间的关键节点的数量。那么就是一个树上差分就解决了h[i] = Sum(inq[i])+Sum(inq[r])-2*Sum(inq[LCA(i, r)])+[LCA是关键节点]-1总复杂度是$O(n*logn)$。需要注意的有： 数组要开双倍大小，因为括号序列是双倍长的QwQ。 这里dp的时候只会用到上一层的信息，所以可以滚动数组优化一下。 求完数组h之后可以反着打一下标记，这样就能抵消了。 注意取模QwQ。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;const int mod = 1e9+7;vector&lt;int&gt; G[maxn];int st[maxn], en[maxn], tot;const int DEG = 20;int p[maxn][DEG], dep[maxn];void dfs(int u, int ff)&#123; p[u][0] = ff; dep[u] = dep[ff] + 1; if(ff) &#123; for(int i=1;i&lt;DEG;++i) p[u][i] = p[p[u][i-1]][i-1]; &#125; st[u] = ++tot; for(int i=0;i&lt;G[u].size();++i) if(G[u][i]!=ff) dfs(G[u][i], u); en[u] = ++tot;&#125;int h[maxn];bool cmp(int x, int y)&#123;return h[x]&lt;h[y];&#125;int Q[maxn];int bit[maxn];int n;void add(int p, int x)&#123;for(int i=p;i&lt;=2*n;i+=(i&amp;-i)) bit[i]+=x;&#125;ll Sum(int p)&#123;if(p==0)return 0;ll res = 0;for(int i=p;i&gt;0;i-=(i&amp;-i))res+=bit[i];return res;&#125;ll dp[maxn];int LCA(int u, int v)&#123; if(dep[u]&gt;dep[v])swap(u, v); int tmp = dep[v] - dep[u]; for(int i=0;tmp;i++,tmp&gt;&gt;=1)if(tmp&amp;1)v = p[v][i]; if(u==v)return u; for(int i=DEG-1;i&gt;=0;--i) if(p[u][i]!=p[v][i]) u = p[u][i], v=p[v][i]; return p[u][0];&#125;int vis[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int q;tot=0; scanf(\"%d%d\", &amp;n, &amp;q); for(int i=1;i&lt;n;++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].eb(v);G[v].eb(u); &#125; dfs(1, 0); for(int i=1;i&lt;=q;++i) &#123; int k, m, r; scanf(\"%d%d%d\", &amp;k, &amp;m, &amp;r); for(int j=1;j&lt;=k;++j) &#123; scanf(\"%d\", Q+j); add(st[Q[j]], 1); add(en[Q[j]]+1, -1); vis[Q[j]] = 1; &#125; for(int j=1;j&lt;=k;++j) &#123; int lca = LCA(Q[j], r); h[j] = Sum(st[Q[j]]) + Sum(st[r]) - 2 * Sum(st[lca]) + vis[lca] - 1; &#125; for(int i=0;i&lt;=m;++i) dp[i]=0;dp[0]=1; for(int j=1;j&lt;=k;++j) add(st[Q[j]], -1), add(en[Q[j]], 1), vis[Q[j]] = 0; sort(h+1, h+1+k); for(int i=1;i&lt;=k;++i) for(int j=m;j&gt;=0;--j)&#123; if(j&gt;=h[i]) dp[j] = (dp[j-1] + 1LL*dp[j] * (j-h[i])%mod+mod)%mod; else dp[j] = 0; &#125; ll res = 0; for(int i=1;i&lt;=m;++i) &#123;res += dp[i]; res%=mod;&#125; cout &lt;&lt; (res+mod)%mod &lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"括号序列","slug":"括号序列","permalink":"http://aoudad.cn/tags/括号序列/"},{"name":"LCA","slug":"LCA","permalink":"http://aoudad.cn/tags/LCA/"}]},{"title":"Codeforces1111D2 D","slug":"Codeforces1111D2-D","date":"2019-02-06T08:00:35.000Z","updated":"2019-02-06T08:52:08.351Z","comments":true,"path":"2019/02/06/Codeforces1111D2-D/","link":"","permalink":"http://aoudad.cn/2019/02/06/Codeforces1111D2-D/","excerpt":"","text":"题意描述There is a colony of villains with several holes aligned in a row, where each hole contains exactly one villain.Each colony arrangement can be expressed as a string of even length, where the i-th character of the string represents the type of villain in the i-th hole.Iron Man can destroy a colony only if the colony arrangement is such that all villains of a certain type either live in the first half of the colony or in the second half of the colony.His assistant Jarvis has a special power. It can swap villains of any two holes, i.e. swap any two characters in the string; he can do this operation any number of times.Now Iron Man asks Jarvis q questions. In each question, he gives Jarvis two numbers x and y. Jarvis has to tell Iron Man the number of distinct colony arrangements he can create from the original one using his powers such that all villains having the same type as those originally living in x-th hole or y-th hole live in the same half and the Iron Man can destroy that colony arrangement.Two colony arrangements are considered to be different if there exists a hole such that different types of villains are present in that hole in the arrangements. InputThe first line contains a string $s$ ($2 \\leq |s|\\leq 10^5$), representing the initial colony arrangement. String $s$ can have both lowercase and uppercase English letters and its length is even.The second line contains a single integer qq ($1\\leq q \\leq 10^5$) — the number of questions.The $i$-th of the next $q$ lines contains two integers $xi$ and $yi$($1\\leq xi,yi\\leq |s|$, $xi\\not=yi$) — the two numbers given to the Jarvis for the $i$-th question. OutputFor each question output the number of arrangements possible modulo $10^9+7$. Sample Inputabba21 41 2 Sample Output20 Sample InputAAaa21 21 3 Sample Output20 Sample Inputabcd11 3 Sample Output8 题意：给一个只由大写字母和小写字母52种字符组成的字符串，字符串长度一定为偶数，q次询问，定义一个串是合法的，当且仅当同样字母的在同一半。q次询问，每次询问给两个位置，求两个位置上的字符在同一半的方案数。 思路：不考虑询问的话，答案就是从52个数中选出一个子集使得子集和为n/2的方案数。这是个经典的01背包问题。考虑原题，实际上就是从剩下的那些字母中选出一个子集使得子集和为n/2的方案数2，如果直接枚举两个字母预处理做01背包是$O(n52^3)$，GG，这里可以用可逆背包，就是$O(n*52^2)$，当然其实常数不会那么大。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 57;const ll mod = 1e9+7;int id(char ch)&#123; if(ch&lt;='z'&amp;&amp;ch&gt;='a') return ch-'a'+1; if(ch&lt;='Z'&amp;&amp;ch&gt;='A') return ch-'A'+27;&#125;const int maxL = 1e5+8;ll ans[maxn][maxn], f[maxL], cnt[maxn];ll fac[maxL], finv[maxL], tmp[maxn];ll q_p(ll base, ll n)&#123; ll ans = 1; for(;n;n&gt;&gt;=1, base=base*base%mod)if(n&amp;1)ans=ans*base%mod; return ans;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao string s; cin &gt;&gt;s;int n = (int)s.size(); for(int i=0;i&lt;n;++i) ++cnt[id(s[i])]; fac[0]=1; ll res = 1; for(int i=1;i&lt;=n;++i) &#123;fac[i] = fac[i-1] * i % mod; if(i&lt;=n/2) res = res * i % mod;&#125; finv[n] = q_p(fac[n], mod-2); for(int i=n-1;i&gt;=1;--i) finv[i] = finv[i+1] * (i+1) % mod;finv[0]=1; res = res * res % mod; for(int i=1;i&lt;=52;++i) res = res * finv[cnt[i]] % mod; f[0] = 1; for(int i=1;i&lt;=52;++i) if(cnt[i]) for(int j=n;j&gt;=cnt[i];--j) f[j] = (f[j] + f[j-cnt[i]])%mod; for(int i=1;i&lt;=52;++i) ans[i][i] = f[n/2] * res % mod; for(int i=1;i&lt;=52;++i) &#123; if(cnt[i]==0)continue; for(int i=0;i&lt;=n;++i) tmp[i] = f[i]; for(int j=cnt[i];j&lt;=n;++j) tmp[j] = (mod+tmp[j] - tmp[j-cnt[i]])%mod; for(int j=i+1;j&lt;=52;++j) &#123; if(cnt[j]==0)continue; for(int t=cnt[j];t&lt;=n;++t)tmp[t] = (tmp[t] - tmp[t-cnt[j]]+mod)%mod; ans[i][j] = tmp[n/2]*2*res%mod; for(int t=n;t&gt;=cnt[j];--t) tmp[t] = (tmp[t] + tmp[t-cnt[j]] + mod ) % mod; &#125; &#125; int q, x, y; cin &gt;&gt; q; for(int i=1;i&lt;=q;++i) &#123; scanf(\"%d%d\", &amp;x, &amp;y); x = id(s[x-1]), y=id(s[y-1]); if(x&gt;y)swap(x, y); printf(\"%lld\\n\", ans[x][y]); &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://aoudad.cn/tags/背包/"}]},{"title":"NTT模板","slug":"NTT模板","date":"2019-02-02T17:03:34.000Z","updated":"2019-02-03T14:36:56.907Z","comments":true,"path":"2019/02/03/NTT模板/","link":"","permalink":"http://aoudad.cn/2019/02/03/NTT模板/","excerpt":"","text":"描述NTT和分治NTT模板，修改一下FFT模板就可以得到了。一些素数r⋅2k+1 r k g3 1 1 25 1 2 217 1 4 397 3 5 5193 3 6 5257 1 8 37681 15 9 1712289 3 12 1140961 5 13 365537 1 16 3786433 3 18 105767169 11 19 37340033 7 20 323068673 11 21 3104857601 25 22 3167772161 5 25 3469762049 7 26 3998244353 119 23 31004535809 479 21 32013265921 15 27 312281701377 17 27 33221225473 3 30 575161927681 35 31 377309411329 9 33 7206158430209 3 36 222061584302081 15 37 72748779069441 5 39 36597069766657 3 41 539582418599937 9 42 579164837199873 9 43 5263882790666241 15 44 71231453023109121 35 45 31337006139375617 19 46 33799912185593857 27 47 54222124650659841 15 48 197881299347898369 7 50 631525197391593473 7 52 3180143985094819841 5 55 61945555039024054273 27 56 54179340454199820289 29 57 3 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;const int g = 3;const int mod = 998244353;ll q_p(ll base, int n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;void calc(ll *a,ll *b,int n)&#123; NTT(a,n,1);NTT(b,n,1); for(int i=0;i&lt;=n;i++)a[i]=(a[i]*b[i])%mod; NTT(a,n,-1);&#125;ll x[maxn];ll cnt[maxn], d[maxn];char st[maxn];#define LL long longLL A[maxn],B[maxn];int n;int main()&#123; scanf(\"%s\",st); int len=strlen(st); n=len; for(int i=0;i&lt;=len-1;i++) A[len-1-i]=st[i]-'0'; scanf(\"%s\",st); len=strlen(st); n=max(n,len); for(int i=0;i&lt;=len-1;i++) B[len-1-i]=st[i]-'0'; int _n=1; while(_n&lt;n) _n&lt;&lt;=1; n=_n; n&lt;&lt;=1; calc(A, B, n); for(int i=0;i&lt;=n-1;i++) A[i+1]+=A[i]/10, A[i]%=10; n--; while(A[n]/10) A[n+1]+=A[n]/10, A[n++]%=10; while(!A[n]&amp;&amp;n&gt;0) n--; for(int i=n;i&gt;=0;i--) putchar('0'+A[i]); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 分治NTT#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;ll f[maxn], g[maxn], A[maxn], B[maxn];void cdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; cdqNTT(l, mid); int SZ = r-l+1, len=1; while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;mid-l+1;++i) A[i] = f[i+l];for(int i=mid-l+1;i&lt;len;++i) A[i] = 0; for(int i=0;i&lt;SZ-1;++i) B[i] = g[i+1]; for(int i=SZ-1;i&lt;len;++i) B[i] = 0; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) f[i] = (f[i] + A[i-l-1])%mod; cdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=1;i&lt;n;++i) cin &gt;&gt; g[i]; int len = 1;while(len&lt;n)len&lt;&lt;=1; f[0]=1; cdqNTT(0, len); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/******* *真·NTT *$Calc f(i) = \\Sigma_&#123;j=0&#125;^&#123;i-1&#125; f(j)*f(i-j-1)$ *******/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; f[0]=1; /// 对拍 for(int i=1;i&lt;n;++i) &#123; for(int j=0;j&lt;i;++j) f[i] += f[j]*f[i-j-1]; f[i]%=mod; &#125; for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout &lt;&lt; endl; for(int i=1;i&lt;len;++i) f[i]=0; /// int len = 1;while(len&lt;n)len&lt;&lt;=1; RcdqNTT(0, len-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"分治NTT","slug":"分治NTT","permalink":"http://aoudad.cn/tags/分治NTT/"},{"name":"NTT","slug":"NTT","permalink":"http://aoudad.cn/tags/NTT/"}]},{"title":"HDU 4609 3-idiots","slug":"HDU-4609-3-idiots","date":"2019-02-02T15:31:38.000Z","updated":"2019-02-02T15:48:04.013Z","comments":true,"path":"2019/02/02/HDU-4609-3-idiots/","link":"","permalink":"http://aoudad.cn/2019/02/02/HDU-4609-3-idiots/","excerpt":"","text":"题意描述King OMeGa catched three men who had been streaking in the street. Looking as idiots though, the three men insisted that it was a kind of performance art, and begged the king to free them. Out of hatred to the real idiots, the king wanted to check if they were lying. The three men were sent to the king’s forest, and each of them was asked to pick a branch one after another. If the three branches they bring back can form a triangle, their math ability would save them. Otherwise, they would be sent into jail.However, the three men were exactly idiots, and what they would do is only to pick the branches randomly. Certainly, they couldn’t pick the same branch - but the one with the same length as another is available. Given the lengths of all branches in the forest, determine the probability that they would be saved. InputAn integer T(T≤100) will exist in the first line of input, indicating the number of test cases.Each test case begins with the number of branches N(3≤N≤10 5).The following line contains N integers a_i (1≤a_i≤10 5), which denotes the length of each branch, respectively. OutputOutput the probability that their branches can form a triangle, in accuracy of 7 decimal places. Sample Input241 3 3 442 3 3 4 Sample Output0.50000001.0000000 题意：有n根长度小于$10^5$的木棍，从中任选三根，能组成三角形的概率。 思路：FFT经典题目。设$ans$为从中选出三根能组成三角形的方案数，tot为总方案数，显然tot为$\\binom n 3$。关键是求$ans$。设cnt[j]表示丛中任选两个木棍，长度之和为j的方案数，枚举木棍i，假设目前枚举到的是i，把d[i]当成选到的木棍中最长的，这样就不会重了，那么要算的就是选取两根长度小于d[i]的木棍，且他们的长度之和大于d[i]的方案数，也就是$\\Sigma_{j=i+1}^{len}cnt[j]-$选两根大于d[i]的方案数，一根大一根小的方案数，一根自己一根其他的方案数。cnt可以通过把长度当作指数(下标)，数量当作系数，作一次FFT得到。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;struct Complex&#123; double x, y; Complex(double _x=0, double _y=0):x(_x), y(_y)&#123;&#125; Complex operator-(const Complex&amp;b)&#123;return Complex(x-b.x,y-b.y);&#125; Complex operator+(const Complex&amp;b)&#123;return Complex(x+b.x,y+b.y);&#125; Complex operator*(const Complex&amp;b)&#123;return Complex(x*b.x-y*b.y, x*b.y+y*b.x);&#125;&#125;;int rev[maxn];void fft(Complex y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; Complex wn(cos(-on*2*PI/h), sin(-on*2*PI/h)); for(int j=0;j&lt;len;j+=h) &#123; Complex w(1, 0); for(int k=j;k&lt;j+h/2;++k) &#123; Complex u = y[k], t = w*y[k+h/2]; y[k] = u+t; y[k+h/2] = u-t; w = w*wn; &#125; &#125; &#125; if(on==-1)for(int i=0;i&lt;len;++i) y[i].x/=len;&#125;Complex x[maxn];ll cnt[maxn], d[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int t; cin &gt;&gt; t; while(t--) &#123; int n;scanf(\"%d\", &amp;n); memset(cnt, 0, sizeof cnt); for(int i=0;i&lt;n;++i) scanf(\"%lld\", d+i), cnt[d[i]]++; sort(d, d+n); int len = 1, len1 = d[n-1]+1; while(len&lt;len1*2)len&lt;&lt;=1; for(int i=0;i&lt;len1;++i) x[i] = Complex(cnt[i], 0); for(int i=len1;i&lt;len;++i) x[i] = Complex(0, 0); fft(x, len, 1); for(int i=0;i&lt;len;++i) x[i] = x[i]*x[i]; fft(x, len, -1); for(int i=0;i&lt;len;++i) cnt[i] = (ll)(x[i].x+0.5); for(int i=0;i&lt;n;++i) cnt[d[i]+d[i]]--; for(int i=0;i&lt;len;++i) cnt[i]/=2; for(int i=1;i&lt;len;++i) cnt[i]+=cnt[i-1]; ll ans = 0, tot = 1LL*(n-2)*(n-1)*n/6; for(int i=0;i&lt;n;++i) &#123; ans += cnt[len-1] - cnt[d[i]]; ans -= 1LL*(n-i-1)*(n-i-2)/2; ans -= 1LL*i*(n-i-1); ans -= n-1; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; (double)ans/tot &lt;&lt; endl;; &#125;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://aoudad.cn/tags/FFT/"},{"name":"计数","slug":"计数","permalink":"http://aoudad.cn/tags/计数/"}]},{"title":"Camp Day1 D 拆拆拆数","slug":"Camp-Day1-D-拆拆拆数","date":"2019-02-02T13:56:20.000Z","updated":"2019-02-02T14:05:43.303Z","comments":true,"path":"2019/02/02/Camp-Day1-D-拆拆拆数/","link":"","permalink":"http://aoudad.cn/2019/02/02/Camp-Day1-D-拆拆拆数/","excerpt":"","text":"题意描述读入$A$和$B$，$wls$想请你把$A$拆成$a_1, a_2, …, a_n$​，把$B$拆成$b_1, b_2, …, b_n$​，满足 对于所有的$i(1 \\leq i \\leq n)$，$a_i, b_i \\geq 2i(1≤i≤n)$，$ai​,bi​ \\geq 2$ 且 $gcd(a_i, b_i) = 1$ $\\sum_{i=1}^{n}{a_i} = A$，$\\sum_{i=1}^{n}{b_i} = B$如果有多组满足条件的$a$和$b$，请输出$n$最小的任意一组即可。如果无解，请输出$-1$。 Input第一行一个整数$test$表示数据组数。接下来$test$行，每行两个整数$A$，$B$。$1 \\leq test \\leq 100000$$5 \\leq A, B \\leq 10^{18}$ Output对于每组数据，第一行输出一个整数$n$；接下来$n$行每行输出两个整数$a_i​$，$b_i​$表示答案。 Sample Input26 5100000 100000 Sample Output16 5249999 5000150001 49999 题意：给两个数，分别拆成x组，使得两两之间互质。 思路：分类讨论，如果原本给的两个数就是互质的，显然他们本身就是最优的。如果不是，两个数都是偶数，根据哥德巴赫猜想，都分成两个素数之和是可行的，如果两个都是奇数，那么拆成2，n-2和m-2，2是满足题意的，如果是一奇一偶且奇数（假设为n）大于偶数（假设为m），那么分成2，n-2和3， m-3或者4， n-4和3，m-3是可行的，因为m-3≥3，所以n-2和n-4不可能同时能整除m-3.如果n小于m，那么2，n-2和3， m-3或者2， n-2和5，m-5是可行的，原因类似上一点。当然知道分成两组一定可以的话，直接随机也是可以的【我们队比赛中的做法】。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const ll mod = 1e18;ll get(ll m)&#123; ll x = (ll)rand()*rand()%m*rand()%m; while(x&lt;2||x+2&gt;m) x = (ll)rand()*rand()%m*rand()%m; return x;&#125;int main()&#123; int t; scanf(\"%d\", &amp;t); while(t--) &#123; ll a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); if(__gcd(a, b)==1) printf(\"1\\n%lld %lld\\n\", a, b); else &#123; printf(\"2\\n\"); ll x, y; srand(time(0)); for(;;) &#123; ll x = get(a), y = get(b); if(__gcd(x, y)==1&amp;&amp;__gcd(a-x,b-y)==1) &#123;printf(\"%lld %lld\\n%lld %lld\\n\", x, y, a-x, b-y);break;&#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"HDU1402 A*B problem plus","slug":"HDU1402-A-B-problem-plus","date":"2019-02-02T13:26:25.000Z","updated":"2019-02-02T13:28:38.042Z","comments":true,"path":"2019/02/02/HDU1402-A-B-problem-plus/","link":"","permalink":"http://aoudad.cn/2019/02/02/HDU1402-A-B-problem-plus/","excerpt":"","text":"题意描述Calculate A * B. InputEach line will contain two integers A and B. Process to end of file. Note: the length of each integer will not exceed 50000. OutputFor each case, output A * B in one line. Sample Input1 21000 2 Sample Output22000 题意：求A*B，A，B的长度小于50000。 思路：FFT模板题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;struct Complex&#123; double x, y; Complex(double _x=0, double _y=0):x(_x), y(_y)&#123;&#125; Complex operator-(const Complex&amp; b)const&#123;return Complex(x-b.x, y-b.y);&#125; Complex operator+(const Complex&amp; b)const&#123;return Complex(x+b.x, y+b.y);&#125; Complex operator*(const Complex&amp; b)const&#123;return Complex(x*b.x-y*b.y, x*b.y+y*b.x);&#125;&#125;;int rev[maxn];void fft(Complex y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; Complex wn(cos(-on*2*PI/h), sin(-on*2*PI/h)); for(int j=0;j&lt;len;j+=h) &#123; Complex w(1, 0); for(int k=j;k&lt;j+h/2;k++) &#123; Complex u = y[k]; Complex t = w*y[k+h/2]; y[k] = u+t; y[k+h/2] = u-t; w = w*wn; &#125; &#125; &#125; if(on==-1) for(int i=0;i&lt;len;++i) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char str1[maxn/2], str2[maxn/2];int sum[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao while(~scanf(\"%s%s\", str1, str2)) &#123; int len1 = strlen(str1); int len2 = strlen(str2); int len = 1; while(len&lt;len1*2||len&lt;len2*2) len&lt;&lt;=1; for(int i=0;i&lt;len1;++i) x1[i] = Complex(str1[len1-1-i]-'0', 0); for(int i=len1;i&lt;len;++i) x1[i] = Complex(0, 0); for(int i=0;i&lt;len2;++i) x2[i] = Complex(str2[len2-1-i]-'0', 0); for(int i=len2;i&lt;len;++i) x2[i] = Complex(0, 0); fft(x1, len, 1); fft(x2, len, 1); for(int i=0;i&lt;len;++i) x1[i]=x1[i]*x2[i];//, printf(\"%lf \", x1[i].x);; fft(x1, len, -1); for(int i=0;i&lt;len;++i) sum[i]=(int)(x1[i].x+0.5); for(int i=0;i&lt;len;++i) &#123; sum[i+1] += sum[i] / 10; sum[i] %= 10; &#125; len = len1+len2-1; while(sum[len]&lt;=0&amp;&amp;len&gt;0)--len; for(int i=len;i&gt;=0;--i) printf(\"%c\", sum[i]+'0'); puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://aoudad.cn/tags/FFT/"}]},{"title":"Camp Day8 D 吉良吉影的奇妙计划","slug":"Camp-Day8-D-吉良吉影的奇妙计划","date":"2019-02-02T12:35:19.000Z","updated":"2019-02-03T14:36:41.375Z","comments":true,"path":"2019/02/02/Camp-Day8-D-吉良吉影的奇妙计划/","link":"","permalink":"http://aoudad.cn/2019/02/02/Camp-Day8-D-吉良吉影的奇妙计划/","excerpt":"","text":"题意描述吉良吉影是一个平凡的上班族，他决定在休假的闲暇时光里制定接下来2n2n天的指甲修剪计划。 首先，吉良吉影会在纸上写下2n个字（左、右各n个），表示他每天是修剪左手的指甲还是右手的指甲。但是吉良吉影是一个称职的上班族，不会浪费这么多时间在修剪指甲上，于是他决定将一些位置改成空（即那天不剪指甲）。吉良吉影从头扫视整个计划，如果出现连续两天，剪的是不同的手，那么他就会将这两天改成空，并从头开始重复这个过程。直到不存在连续两天剪不同手的指甲为止。比如初始的计划为左左右左左右右右，那么在第一次修改后变成左空空左左右右右，在第二次修改后变成左空空左空空右右。由于吉良吉影的指甲生长的非常快，所以他不能容忍出现连续4天或以上的空，如果在最终的计划中出现了连续4个的空，那么他认为这样的计划不合法并炸掉计划。 现在吉良吉影想知道，他可能造出多少种合法的计划？两个计划被认为不同，当且仅当存在任意一天的选择不同。 Input第一行包含一个整数 $n(1 \\le n \\le 10^5)$ Output输出仅一行，表示合法计划的数量，对998244353取模。 Sample Input3 Sample Output6 题意：问题可以看成是找到有多少长度为2n的−1, 0, +1组成的序列，满足：0总是成对出现不包含4个连续0+1, −1不能相邻所有数的和为0 思路：这道题实在是太神仙了，搞了两天还是没办法写出来，虽然感觉离正解越来越近了。这是n=6时的方案种类，打表出来的。-1 -1 -1 -1 -1 0 0 1 1 1 1 1-1 -1 -1 -1 0 0 1 0 0 1 1 1-1 -1 -1 -1 0 0 1 1 0 0 1 1-1 -1 -1 -1 0 0 1 1 1 0 0 1-1 -1 -1 -1 0 0 1 1 1 1 0 0-1 -1 -1 0 0 -1 0 0 1 1 1 1-1 -1 -1 0 0 1 0 0 1 0 0 1-1 -1 -1 0 0 1 0 0 1 1 0 0-1 -1 -1 0 0 1 1 0 0 1 0 0-1 -1 -1 0 0 1 1 1 1 0 0 -1-1 -1 0 0 -1 -1 0 0 1 1 1 1-1 -1 0 0 -1 0 0 1 0 0 1 1-1 -1 0 0 -1 0 0 1 1 0 0 1-1 -1 0 0 -1 0 0 1 1 1 0 0-1 -1 0 0 1 0 0 -1 0 0 1 1-1 -1 0 0 1 0 0 1 1 0 0 -1-1 -1 0 0 1 1 0 0 -1 0 0 1-1 -1 0 0 1 1 0 0 1 0 0 -1-1 -1 0 0 1 1 1 0 0 -1 0 0-1 -1 0 0 1 1 1 1 0 0 -1 -1-1 0 0 -1 -1 -1 0 0 1 1 1 1-1 0 0 -1 -1 0 0 1 0 0 1 1-1 0 0 -1 -1 0 0 1 1 0 0 1-1 0 0 -1 -1 0 0 1 1 1 0 0-1 0 0 -1 0 0 -1 0 0 1 1 1-1 0 0 -1 0 0 1 0 0 1 0 0-1 0 0 -1 0 0 1 1 1 0 0 -1-1 0 0 1 0 0 -1 -1 0 0 1 1-1 0 0 1 0 0 -1 0 0 1 0 0-1 0 0 1 0 0 1 0 0 -1 0 0-1 0 0 1 0 0 1 1 0 0 -1 -1-1 0 0 1 1 0 0 -1 -1 0 0 1-1 0 0 1 1 0 0 1 0 0 -1 -1-1 0 0 1 1 1 0 0 -1 -1 0 0-1 0 0 1 1 1 0 0 -1 0 0 -1-1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 1 0 0 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 1 0 0 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 1 0 0 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 1 0 0 -1 0 0 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 1 0 0 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 1 0 0 -1 -1 0 0 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 0 0 -1 0 0 0 0 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 1 0 0 -1 -1 -1 0 0 0 0 1 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 -1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 1 0 0 -1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 1 0 0 -1 -1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 1 0 0 -1 -1 -1 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 0 0 -1 1 0 0 1 1 0 0 -1 0 0 -1 -1 1 0 0 1 1 1 0 0 -1 -1 -1 -1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 -1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 1 0 0 -1 -1 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 -1 1 1 0 0 1 0 0 -1 0 0 -1 -1 1 1 0 0 1 1 0 0 -1 -1 -1 -1 1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 -1 1 1 1 0 0 1 0 0 -1 -1 -1 -1 1 1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 -1 1 1 1 1 0 0 -1 -1 0 0 -1 -1 1 1 1 1 0 0 -1 0 0 -1 -1 -1 1 1 1 1 1 0 0 -1 -1 -1 -1 -1 通过上面的表，可以做以下思考 补充几个在求答案中需要用到的条件： 1.序列的前缀和总是非负2.序列的前缀和总是为正（除了整个序列的和为0）3.序列的结尾是04.序列的结尾非0 现在用$f_{ab···i}$来表示满足额外条件a, b, · · · 的长度为2i的序列数，用$S_i$表示序列前i位（序列位置从1开始标号）的和。目标即求$f_n$。那么有 $f_i = f_{3i} + f_{4i}$ $f_{1i} = f_{13i} + f_{14i}$ $f_{13i} = f_{14i}−1$（因为不能包含4个连续0，对于所有满足条件3的序列去掉末尾的两个0，就会变成满足条件4的序列） $f_{14i} =\\Sigma_{j=0}^{i-1} f_{13j}f_{2i−j}$ （对于每个满足条件14的序列，总可以找到最大的一个$x &lt; 2n$满足$S_x = 0$，容易证明$x$必然为偶数，对于任意的$y(x &lt; y &lt; 2n)$有$Sy = Sy − Sx &gt; 0$，即可以将原序列看成满足条件$13$的长为$x$的序列（这里其实应该是满足条件$1$且末尾不为$−1$的，而由于满足条件$1$末尾不可能为$+1$，所以等价于满足条件$13$）与满足条件$2$的长为$2n − x$的序列（开头必为$+1$，所以前半段末尾不能为$−1$）拼接而成） $f_{2i} = f_{1i−1}$ （满足条件2的序列的开头必然是$+1$，结尾必然是$−1$，将开头与结尾去掉后，满足条件1） $f_{3i} = f_{4i}−1$ $f_{4i} = \\Sigma_{j=0}^{i-1}2f_{3j}f_{2i−j} + f_{4j}f_{2i−j}$ （类似求$f_{14i}$,枚举最大的x&lt;2n满足前缀和为0，分这个位置是0和不为0两种情况统计，显然无论哪种情况，后半段的任意前缀和都不能为0。对于这个位置是0的情况，后半段任意前缀和恒正、恒负都可以，所以有一个常数2；对于这个位置不是0的情况，后半段的前缀和的正负性必须和这个位置相同，因为1和-1不能连续出现。因为序列中只有1,0,-1三种元素，所以前缀和的变化实际上是“连续”的，所以“任意前缀和都不能为0”等价于“前缀和恒正或恒负”）接下来只需要将式子化简使用两次分治NTT即可求出$f_n$。 以上出自出题人的题解，将式子化简之后应该可以推出$f_{14i}$或者$f_{13i}$关于自己的卷积函数，然后这里应该是可以用分治NTT推出来的，然后可以简单的推出$f_{2i}$，然后可以进一步采用正常的分治NTT解出$f_{4i}$，然后使用第一个式子就能得到答案。理论上应该是这样，但是我第一部就卡住了。以下附了一份解决求f(0)=1$$$$f(i)=\\Sigma_{j=0}^{i-1} f(j)*f(i-j-1)的代码，还有一份写了一个下午的假代码，暂时应该是没有能力做出来这道题的了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// https://www.cnblogs.com/yinwuxiao/p/9570533.html/******* *真·NTT *$Calc f(i) = \\Sigma_&#123;j=0&#125;^&#123;i-1&#125; f(j)*f(i-j-1)$ *******/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; f[0]=1; /// 对拍 for(int i=1;i&lt;n;++i) &#123; for(int j=0;j&lt;i;++j) f[i] += f[j]*f[i-j-1]; f[i]%=mod; &#125; for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout &lt;&lt; endl; for(int i=1;i&lt;len;++i) f[i]=0; /// int len = 1;while(len&lt;n)len&lt;&lt;=1; RcdqNTT(0, len-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209//假代码#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;ll A[maxn], B[maxn];/*void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;*/ll f13[maxn], f2[maxn], f4[maxn];//, f[maxn];void solve13(int l, int r)&#123;// if(r&lt;=4)return ; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; solve13(l, mid); error(l, mid, r); if(r-l&lt;l) &#123; int SZ = r-l+1+mid-l+1, len = 1;while(len&lt;SZ)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=r-l;++i) A[i] = f13[i]; for(int i=0;i&lt;mid-l+1;++i) B[i] = f13[i+l]; ll tmp = f13[mid]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; if(i&gt;=l+2) f13[i] = (f13[i]+2*A[i-l-2])%mod; f13[i] = (f13[i]+2*A[i-l-1])%mod; &#125; f13[mid+1] = (f13[mid+1]-tmp%mod+mod)%mod;// if(mid+1&gt;=l+2) f13[mid+1] = (f13[mid+1]-B[SZ-1]*B[mid+0-l-l-SZ]%mod+mod)%mod; &#125; int SZ = mid-l+1, len = 1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i)A[i] = B[i] = 0; for(int i=0;i&lt;SZ;++i) A[i] = B[i] = f13[i+l]; Calc(A, B, len); for(int i=0;i&lt;len;++i) B[i] = 0; for(int i=0;i&lt;SZ;++i) B[i] = f13[i+l];// for(int i=0;i&lt;len;++i) cout &lt;&lt; A[i] &lt;&lt; ' ';cout&lt;&lt;endl; for(int i=mid+1;i&lt;=r;++i) &#123;// error(i, l+l+1, f13[i]); if(i&gt;=l+l+2) f13[i] = (f13[i]+A[i-l-l-2])%mod;// error(i, l+l+1, f13[i]);++ if(i&gt;=l+l+1) f13[i] = (f13[i]+A[i-l-l-1])%mod; error(i, l+l+1, f13[i]); &#125; if(mid+1&gt;=l*2+1) f13[mid+1] = (f13[mid+1]-2*B[SZ-1]*B[mid+1-l-l-SZ]%mod+mod)%mod; if(mid==0) f13[1] = 1; for(int i=0;i&lt;len;++i) cout &lt;&lt; f13[i] &lt;&lt; ' ';cout&lt;&lt;endl;solve13(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n = 8;// cin &gt;&gt; n; memset(f13, 0, sizeof f13); f13[0]=(mod+1)/2, f13[1]=1;//, f13[4] = 2, f13[2] = 0, f13[3] = 1; solve13(1, n-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f13[i] &lt;&lt; ' ';cout&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"分治NTT","slug":"分治NTT","permalink":"http://aoudad.cn/tags/分治NTT/"}]},{"title":"CodeforcesD21106-E Lunar New Year and Red Envelopes","slug":"CodeforcesD21106-E","date":"2019-02-02T06:34:22.000Z","updated":"2019-02-02T06:52:05.925Z","comments":true,"path":"2019/02/02/CodeforcesD21106-E/","link":"","permalink":"http://aoudad.cn/2019/02/02/CodeforcesD21106-E/","excerpt":"","text":"题意描述Lunar New Year is approaching, and Bob is going to receive some red envelopes with countless money! But collecting money from red envelopes is a time-consuming process itself.Let’s describe this problem in a mathematical way. Consider a timeline from time $1$ to $n$. The $i$-th red envelope will be available from time $s_i$ to $t_i$, inclusive, and contain $w_i$ coins. If Bob chooses to collect the coins in the $i$-th red envelope, he can do it only in an integer point of time between $s_i$ and $t_i$, inclusive, and he can’t collect any more envelopes until time $d_i$ (inclusive) after that. Here $s_i \\leq t_i \\leq d_i$ holds.Bob is a greedy man, he collects coins greedily — whenever he can collect coins at some integer time $x$, he collects the available red envelope with the maximum number of coins. If there are multiple envelopes with the same maximum number of coins, Bob would choose the one whose parameter $d$ is the largest. If there are still multiple choices, Bob will choose one from them randomly.However, Alice — his daughter — doesn’t want her father to get too many coins. She could disturb Bob at no more than $m$ integer time moments. If Alice decides to disturb Bob at time $x$, he could not do anything at time $x$ and resumes his usual strategy at the time $x + 1$ (inclusive), which may lead to missing some red envelopes.Calculate the minimum number of coins Bob would get if Alice disturbs him optimally. InputThe first line contains three non-negative integers n, m and k $(1≤n≤10^5, 0≤m≤200, 1≤k≤10^5)$, denoting the length of the timeline, the number of times Alice can disturb Bob and the total number of red envelopes, respectively. The following $k$ lines describe those $k$ red envelopes. The i-th line contains four positive integers si, ti, di and wi ($1 \\leq s_i \\leq t_i≤d_i \\leq n$, $1 \\leq wi \\leq 10^9$ ) — the time segment when the i-th envelope is available, the time moment Bob can continue collecting after collecting the i-th envelope, and the number of coins in this envelope, respectively. OutputOutput one integer — the minimum number of coins Bob would get if Alice disturbs him optimally. Sample Input12 2 61 5 5 44 6 6 23 8 8 32 9 9 56 10 10 78 12 12 9 10 1 61 1 2 42 2 6 23 3 3 34 4 4 55 5 5 76 6 6 9 5 0 21 3 4 52 5 5 8 Sample Output11 2 13 题意：时间长度为n，每一秒SB Bob会拿一次红包，每个红包有三种属性，$s, t, d, w$分别表示这个红包出现的开始时间，结束时间，领这个红包之后d时刻之前都不能再领红包，以及这个红包里面有的钱。每个时刻Bob会贪心的选择(w, d)最大的红包。Alice有m次干扰操作，每次他可以选择一个时刻进行干扰，这个时刻被干扰的话，Bob就不能拿红包。求Bob会拿到的最少金额的红包是多少。 思路：先预处理初每个时刻Bob的决策，再从后往前DP。预处理就是拿个扫描线从左往右扫，用一个multiset维护一下，遇到s就加入multiset，遇到t+1就从multiset中去掉。DP的话，定义$dp[i][j]$ 表示 $i \\dots n$干扰j次的最小硬币数量。状态转移是很显然的，就i时刻干不干扰两种决策。除了dp[n+1][0]为0以外，全都初始化为INF。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 1e5+7;ll dp[maxn][305];struct Node&#123; int w, d, id; friend bool operator&lt;(const Node&amp; a, const Node&amp; b) &#123; if(a.w!=b.w) return a.w&gt;b.w; return a.d &gt; b.d; &#125;&#125;d[maxn];multiset&lt;Node&gt; s;vector&lt;Node&gt; vec[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i=0;i&lt;k;++i) &#123; int s, t, w, d; cin &gt;&gt; s &gt;&gt; t &gt;&gt; d &gt;&gt; w; vec[s].eb((Node)&#123;w, d, 1&#125;); vec[t+1].eb((Node)&#123;w, d,-1&#125;); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;vec[i].size();++j) &#123; if(vec[i][j].id==1) s.insert(vec[i][j]); else &#123;vec[i][j].id=1;s.erase(s.find(vec[i][j]));&#125; &#125; if(s.empty()) &#123; d[i].d = i;d[i].w=d[i].id=0; &#125; else d[i] = *s.begin(); &#125; memset(dp, 0x37, sizeof dp); dp[n+1][0] = 0; for(int i=n;i&gt;=1;--i) &#123; dp[i][0] = min(dp[i][0], d[i].w + dp[d[i].d+1][0]); for(int j=1;j&lt;=m;++j) &#123; dp[i][j] = min(dp[i][j], dp[i+1][j-1]); dp[i][j] = min(dp[i][j], d[i].w + dp[d[i].d+1][j]); &#125; &#125; ll ans = INFLL; for(int i=0;i&lt;=m;++i) ans = min(ans, dp[1][i]); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"CodeforcesD21106 F Lunar New Year and a Recursive Sequence","slug":"CodeforcesD21106-F","date":"2019-02-01T03:56:00.000Z","updated":"2019-02-01T04:11:46.465Z","comments":true,"path":"2019/02/01/CodeforcesD21106-F/","link":"","permalink":"http://aoudad.cn/2019/02/01/CodeforcesD21106-F/","excerpt":"","text":"题意描述Lunar New Year is approaching, and Bob received a gift from his friend recently — a recursive sequence! He loves this sequence very much and wants to play with it.Let $f_1, f_2, \\ldots, f_i, \\ldots$ be an infinite sequence of positive integers. Bob knows that for $i&gt;k$ , $f_i$ can be obtained by the following recursive equation:f_i = \\left(f_{i - 1} ^ {b_1} \\cdot f_{i - 2} ^ {b_2} \\cdot \\cdots \\cdot f_{i - k} ^ {b_k}\\right) \\bmod p,which in short isf_i = \\left(\\prod_{j = 1}^{k} f_{i - j}^{b_j}\\right) \\bmod p,where p=998244353 (a widely-used prime), $b_1, b_2, \\ldots, b_k$ are known integer constants, and $x \\bmod y$ denotes the remainder of x divided by y.Bob lost the values of $f_1, f_2, \\ldots, f_k$, which is extremely troublesome – these are the basis of the sequence! Luckily, Bob remembers the first k−1 elements of the sequence: $f_1 = f_2 = \\ldots = f_{k - 1} = 1$ and the n-th element: $f_n = m$. Please find any possible value of $f_k$. If no solution exists, just tell Bob that it is impossible to recover his favorite sequence, regardless of Bob’s sadness. InputThe first line contains a positive integer k$(1 \\leq k \\leq 100)$, denoting the length of the sequence $b_1, b_2, \\ldots, b_k$ .The second line contains k positive integers $b_1, b_2, \\ldots, b_k$ $(1 \\leq b_i &lt; p)$.The third line contains two positive integers n and m ($k &lt; n \\leq 10^9$, $1 \\leq m &lt; p$), which implies $f_n = m$. OutputOutput a possible value of $f_k$, where $f_k$ is a positive integer satisfying $1 \\leq f_k &lt; p$. If there are multiple answers, print any of them. If no such $f_k$ makes $f_n=m$, output −1 instead. It is easy to show that if there are some possible values of fk, there must be at least one satisfying $1 \\leq f_k &lt; p$. Sample Input10283 463 213 777 346 201 463 283 102 9992333333 6263423 3998244352 998244352 9982443524 2 1288888 66666 82 3 5 6 1 7 9 1023333 1 54 7 1 5 67 14187219 32 3 54 16 Sample Output382480067 -1 -1 1 6 4 题意：一个序列的第n项可以通过前k项推出来，现在告诉你前k-1项都是1，已知第n项是m，求$f_x$。 思路：设 $f_k$ 为X则，可以利用矩阵快速幂和欧拉降幂求出 $f_n$ ，则原题意化为解方程 $x^a=b(mod p)$，这是个套路了，虽然我不会，但是直接扔个板子上去就行了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 3e6+8;;const ll mod = 998244353;int SZ;struct M&#123; ll a[110][110]; M()&#123;memset(a, 0, sizeof a);&#125; friend M operator*(const M&amp;a, const M&amp;b) &#123; M ans; for(int i=1;i&lt;=SZ;++i) for(int j=1;j&lt;=SZ;++j) for(int k=1;k&lt;=SZ;++k) ans.a[i][j] += a.a[i][k] * b.a[k][j], ans.a[i][j]%=(mod-1); return ans; &#125;&#125;;ll b[maxn];ll q_pm(ll n)&#123; M res, base; res.a[1][1] = 1; for(int i=1;i&lt;=SZ;++i) base.a[1][i] = b[i]; for(int i=2;i&lt;=SZ;++i) base.a[i][i-1] = 1; while(n) &#123; if(n&amp;1) res = base * res; base = base * base; n &gt;&gt;= 1; &#125; return res.a[1][1];&#125;#define met(a,b) memset(a, b, sizeof(a));ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base * base % mod; n &gt;&gt;= 1; &#125; return ans;&#125;const ll INF = 0x7fffffff;const int dir[5][2] = &#123;0,0,-1,0,1,0,0,-1,0,1&#125;;const ll MOD = 1e9+7;bool is[maxn]; ll prm[maxn], id;ll getprm(ll n) &#123; n-=10; if(n == 1) return 0; ll k = 0; met(is, 1); is[0] = is[1] = 0; for(ll i = 2; i &lt; n; ++i) &#123; if(is[i]) prm[k++] = i; for(ll j = 0; j &lt; k &amp;&amp; (i*prm[j] &lt; n); ++j) &#123; is[i*prm[j]] = 0; if(i % prm[j] == 0) break; &#125; &#125; return k;&#125;ll Euler(ll x) &#123; //素数的欧拉函数 return x-1;&#125;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a%b) : a;&#125;ll extgcd(ll a, ll b, ll&amp; x, ll&amp; y) &#123; if (b == 0) &#123; x=1; y=0; return a; &#125; ll d = extgcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return d;&#125;//快速乘 -- a*b % modll pow_mul(ll a, ll b, ll p) &#123; ll r = 0; a %= p; while(b) &#123; if(b&amp;1) r = (r+a) % p; a = (a+a) % p; b &gt;&gt;= 1; &#125; return r;&#125;ll pow_mod(ll a, ll b, ll p) &#123; ll r = 1; a %= p; while(b) &#123; if(b&amp;1) r = pow_mul(r, a, p); a = pow_mul(a, a, p); b &gt;&gt;= 1; &#125; return r;&#125;//求原根ll fac[maxn], num[maxn], tot;ll Factor(ll n)&#123; ll ans = 1, temp = n; tot = 0; for (ll i = 0; i &lt; id &amp;&amp; prm[i] * prm[i] &lt;= temp; i++)&#123; if (n % prm[i] == 0)&#123; fac[tot] = prm[i], num[tot] = 0; while (n%prm[i] == 0) n /= prm[i], ++num[tot]; ans *= (num[tot] + 1); ++tot; &#125; &#125; if (n != 1)&#123; fac[tot] = n, num[tot] = 1; ans *=(num[tot]+1); ++tot; &#125; return ans;&#125;ll root(ll p) &#123; ll phi = Euler(p); Factor(phi); for(ll g = 2; ; g++) &#123; bool f = 1; for(int i = 0; i &lt; tot; ++i) &#123; ll t = phi / fac[i]; if(pow_mod(g, t, p) == 1) &#123; f = 0; break; &#125; &#125; if(f) return g; &#125;&#125;//BSGSll BSGS(ll a, ll b, ll p) &#123; a %= p; b %= p; map&lt;ll, ll&gt; h; ll m = ceil(sqrt(p)), x, y, d, t = 1, v = 1; for(ll i = 0; i &lt; m; ++i) &#123; if(h.count(t)) h[t] = min(h[t], i); else h[t] = i; t = pow_mul(t, a, p); &#125; for(ll i = 0; i &lt; m; ++i) &#123; d = extgcd(v, p, x, y); x = (x* b/d % p + p) % (p); if(h.count(x)) return i*m + h[x]; v = pow_mul(v, t, p); &#125; return -1;&#125;//求模线性方程ll modeq(ll a, ll b, ll p, ll r[]) &#123; ll e, i, d, x, y; d = extgcd(a, p, x, y); if (b % d) &#123; return -1; &#125; e = (x * (b / d) + p) % p; r[0] = (e + p) % p; return d;&#125;//开始解决问题ll solve(ll a, ll b, ll p, ll r[], ll ans[]) &#123; ll g = root(p); ll t1 = BSGS(g, b, p); ll phi = Euler(p); ll cnt = modeq(a, t1, phi, r); if(cnt == -1) return -1; ans[0] = pow_mod(g, r[0], p); return cnt;&#125;ll ans[maxn], res[maxn];int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int k; cin &gt;&gt; k; for(int i=1;i&lt;=k;++i) cin &gt;&gt; b[i]; SZ = k; ll n, m; cin &gt;&gt; n &gt;&gt; m; ll tmp = q_pm(n-k);tmp=(tmp%(mod-1)+mod-1)%(mod-1)+mod-1; id = getprm(maxn-1); ll cnt = solve(tmp, m, mod, res, ans); if(cnt==-1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans[0] &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://aoudad.cn/tags/矩阵快速幂/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"http://aoudad.cn/tags/欧拉降幂/"},{"name":"BSGS","slug":"BSGS","permalink":"http://aoudad.cn/tags/BSGS/"},{"name":"原根","slug":"原根","permalink":"http://aoudad.cn/tags/原根/"}]},{"title":"Camp Day8 B 玖凛两开花","slug":"Camp-Day8-B-玖凛两开花","date":"2019-01-30T03:48:10.000Z","updated":"2019-01-30T04:16:07.236Z","comments":true,"path":"2019/01/30/Camp-Day8-B-玖凛两开花/","link":"","permalink":"http://aoudad.cn/2019/01/30/Camp-Day8-B-玖凛两开花/","excerpt":"","text":"题意描述为了拯救重要之人，御原玖音和Rinne Ohara都努力地进行时间机器的研究，为此她们正在学习一些必要的算法。在学习的过程中，她们发现了一个叫做开花（Blossom algorithm，也被称作带花树）的有趣算法。开花算法可以用来解决一般图最大匹配问题，经过一些修改还可以用来解决一般图最大权匹配问题。原始的开花算法的时间复杂度为 $O(|V|^2|E|)$ ，其中 $|V|,|E|$ 分别为图的点数与边数。有很多人对开花算法进行了优化，如Gabow在《 Data structures for weighted matching and nearest common ancestors with linking》一文中将一般图最大权匹配的时间复杂度优化到了 $O(|V|(|E|+|V| \\log |V|))$ 。本着不重复造轮子的心态，Rinne尝试在线搜索开花算法的代码，但是找到的却都是时间复杂度为 $O(V^3)$ 的实现方式。玖音只好自己写出一份代码，对一道例题跑出结果，然后请你检验她的答案对不对。玖音的题目是这样的：给出一张点集为 $V$，边集为 $E$ 的无向图 $G$ ，点的编号为0至 $|V|-1$ ，边 $(u,v)$ 的权值为 $\\min(u,v)$ 。一个边集 $S$ 是图的一个匹配当且仅当 $S \\subseteq E$ ，且 $\\forall e_1,e_2 \\in S \\bigwedge e_1 \\neq e_2$ ，满足 $e_1,e_2$ 无公共端点。对于一个边集 $S$ ，定义 $W_S$为 $S$ 中所有边的权值的集合。对于一个自然数集 $W$ ，定义 $Mex(W)$ 为最小的不属于 $W$ 的自然数。求对于图 $G$ 的匹配 $S$ ， $Mex(W_S)$ 的最大值是多少。好心的Rinne为了减少你的负担，将题目的做法告诉了你，你只需要实现一个高效的开花算法即可。当然，如果你已经会做这道题了，就可以不用继续看下去了。Rinne给出的做法是这样的：对于所有的边 $e \\in E$ ，若其原本的边权为 $w$ ，将其改为 $2^{|V|-w}$ 。求出新图的最大权匹配后，设其权值之和为 $X$ ，将其二进制表示中的最低 $|V|+1$ 位由高位到低位依次写出来，第一个为0的位的出现位置（从0开始编号）就是答案。要想证明正确性又要花费一些时间，不过Rinne是不会骗你的。 Input第一行两个整数 $n,m(1 \\le n \\le 10 ^4, 1 \\le m \\le 2 \\times 10^4)$ ，分别代表图的点数与边数。接下来m行，每行两个整数 $u_i,v_i(0 \\le u_i,v_i &lt; n)$ ，代表有一条连接 $u_i, v_i$ 的边。保证没有重边和自环。 Output输出共一行一个整数，代表 $Mex(W_S)$ 的最大值。 Sample Input5 103 14 01 40 31 22 30 14 24 30 2 Sample Output2 题意：给一个无向带权图，权值是两个节点的编号中的较小值。设S是该图的某个匹配的边权集合，那么 $Mer(S)$就是S中没有的最小自然数。 思路：显然这不是传统的一般图最大权匹配，注意到答案具有单调性，二分答案，则原图相当于二分图，将小于ans放在左边，其他放在右边：左图显然不能和左边匹配，否则矛盾，右边可以和右边匹配，但是不影响答案，所以只剩下左边匹配右边了。每次跑个HK就行了。时间复杂度 $O(\\log n nm)$ ，其实还可以nm的，因为不用二分，每次将点从右边移到左边就行，这里就不深入了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int MAXN = 2e4+7;const int INF = 0x3f3f3f3f;vector&lt;int&gt;G[MAXN];vector&lt;int&gt; Real[MAXN];int uN;int Mx[MAXN],My[MAXN];int dx[MAXN],dy[MAXN];int dis;bool used[MAXN];bool SearchP()&#123; queue&lt;int&gt;Q; dis = INF; memset(dx,-1,sizeof(dx)); memset(dy,-1,sizeof(dy)); for(int i = 0 ; i &lt; uN; i++) if(Mx[i] == -1) &#123; Q.push(i); dx[i] = 0; &#125; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); if(dx[u] &gt; dis) break; int sz = G[u].size(); for(int i = 0; i &lt; sz; i++) &#123; int v = G[u][i]; if(dy[v] == -1) &#123; dy[v] = dx[u] + 1; if(My[v] == -1) dis = dy[v]; else &#123; dx[My[v]] = dy[v] + 1; Q.push(My[v]); &#125; &#125; &#125; &#125; return dis != INF;&#125;bool DFS(int u)&#123; int sz = G[u].size(); for(int i = 0; i &lt; sz; i++) &#123; int v = G[u][i]; if(!used[v] &amp;&amp; dy[v] == dx[u] + 1) &#123; used[v] = true; if(My[v] != -1 &amp;&amp; dy[v] == dis) continue; if(My[v] == -1 || DFS(My[v])) &#123; My[v] = u; Mx[u] = v; return true; &#125; &#125; &#125; return false;&#125;int MaxMatch()&#123; int res = 0; memset(Mx,-1,sizeof(Mx)); memset(My,-1,sizeof(My)); while(SearchP()) &#123; memset(used,false,sizeof(used)); for(int i = 0; i &lt; uN; i++) if(Mx[i] == -1 &amp;&amp; DFS(i)) res++; &#125; return res;&#125;//const int maxn = 2e4+7;//vector&lt;int&gt; G[maxn];void addedge(int u, int v)&#123;Real[u].push_back(v);&#125;int n;int chk(int x)&#123; uN = x; for(int i=0;i&lt;n;++i) G[i].clear(); for(int i=0;i&lt;x;++i) &#123; for(auto tmp:Real[i]) if(tmp&gt;=x) G[i].push_back(tmp-x); &#125; int ans = MaxMatch(); return ans == x;&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt;m; for(int i=0;i&lt;n;++i) G[i].clear(); for(int i=0;i&lt;m;++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v);addedge(v, u); &#125; int L = 0, R = n-1, mid, ans; while(L&lt;R) &#123; mid = (L+R)/2; if(chk(mid)) L = mid + 1, ans = mid; else R = mid; &#125; cout &lt;&lt; ans &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"二分","slug":"二分","permalink":"http://aoudad.cn/tags/二分/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"http://aoudad.cn/tags/二分图匹配/"}]},{"title":"Camp Day8 A Aqous","slug":"Camp-Day8-A-Aqous","date":"2019-01-30T03:03:58.000Z","updated":"2019-01-30T03:47:27.684Z","comments":true,"path":"2019/01/30/Camp-Day8-A-Aqous/","link":"","permalink":"http://aoudad.cn/2019/01/30/Camp-Day8-A-Aqous/","excerpt":"","text":"题意描述Aqours 正在 LoveLive! 决赛中表演，舞台可以看作是一棵 $n$ 个点的有根树，其中根节点是 1 号点，$i$ 号点的父亲节点为 $p_i$ ，保证 $1 \\le p_i &lt; i$ ，而且对于 $2 \\le i &lt; j $\\le n^2$ 有 $p_i \\le p_j$ 。其中的叶子节点（定义为没有孩子节点的点）是与粉丝进行互动的节点，Aqours 会在这些叶子节点之间走动来与更多的粉丝互动，但是她们又要唱歌又要跳舞，要尽快节省走动时间，然后也要做到雨露均沾，所以每次要往编号更小的叶子节点走。所以 Aqours 想知道对于每一个叶子节点 $u$ ，离它最近的编号 $&lt;u$ 的叶子节点到它的距离是多少，若不存在则视距离为 -1。 Input第一行一个正整数 n ( $1 \\le n \\le 3 \\times 10^6$ )，表示树的大小。第二行 $n-1$ 个正整数，其中第 $i$ 个数表示 $p_{i+1}(1 \\le p_{i+1} \\le i)$ 。对于 $2 \\le i &lt; j \\le n^2$ ，保证 $p_i \\le p_j$ 。 Output每个叶子对应的答案输出一行。每行第一个数是叶子节点的编号 $u$，第二个数是离他最近的编号 $&lt;u$ 的叶子节点到它的距离，若不存在则输出 -1。要求按叶子节点编号从小到大输出。 Sample Input101 1 1 1 2 4 5 6 7 Sample Output3 -18 39 410 4 题意：按BFS序给出一个树，求出每个叶子节点到所有标号比他小的叶子节点的最小距离，其中距离就是常规的树的路径的距离。如果不存在就输出-1. 思路：显然是按BFS序给出这个树的，所以可以知道编号小的叶子节点的深度绝对不会大于标号比它大的节点。对每个节点 $u$ 维护一个值 $dis(u)$ 表示离u最近的叶子节点到他的距离。初始时每个dis初始化为0， $dis(0)$ 初始化为INF。按照从小到大的顺序枚举每个叶子节点，然后从每个叶子节点一直往上更新dis(f(u))，同时将访问到的节点塞进栈里，直到某个节点的dis曾经被更新过。然后该节点的答案就是往上跳的步数加上这个节点的dis值。由于所有比目前的叶子节点标号都小的叶子节点都已经访问过了，所以目前跳到的答案一定是最优的。而往下更新的原因是因为可能比较浅的节点到该节点的距离更小。需要注意的是这里最好用数组模拟栈，用自带的栈我一直TLE。感觉效率差了一个数量级。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e6+7;int p[maxn], tag[maxn], ans[maxn], isp[maxn];int st[maxn], tot=0;int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; scanf(\"%d\", &amp;n); for(int i=2;i&lt;=n;++i) &#123;scanf(\"%d\", &amp;p[i]); isp[p[i]] = 1;&#125; if(n==1) &#123; puts(\"1 -1\"); return 0; &#125; tag[0]=INFI; for(int i=2;i&lt;=n;++i) &#123; int t = p[i], cnt = 0; if(isp[i])continue; st[tot++] = t; while(tag[t]==0) &#123; cnt++; tag[t] = cnt; t = p[t]; st[tot++] = t; &#125; ans[i] = cnt + tag[t] + 1; tag[t] = min(tag[t], cnt+1); cnt = 0; while(tot) &#123; tag[st[tot-1]] = min(tag[st[tot-1]], tag[t] + cnt); ++cnt; --tot; &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(isp[i]) continue;; if(ans[i]&gt;=INFI) &#123;printf(\"%d -1\\n\", i);continue;&#125; printf(\"%d %d\\n\", i, ans[i]); &#125;&#125;","categories":[],"tags":[{"name":"思维","slug":"思维","permalink":"http://aoudad.cn/tags/思维/"}]},{"title":"JRY's_Geo","slug":"JRY-s-Geo","date":"2019-01-25T07:54:30.000Z","updated":"2019-01-25T07:55:18.692Z","comments":true,"path":"2019/01/25/JRY-s-Geo/","link":"","permalink":"http://aoudad.cn/2019/01/25/JRY-s-Geo/","excerpt":"","text":"题意描述InputOutputSample InputSample Output题意：吉老师的计算几何板子 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552#define mp make_pair#define fi first#define se second#define pb push_backtypedef double db;const db eps=1e-6;const db pi=acos(-1);int sign(db k)&#123; if (k&gt;eps) return 1; else if (k&lt;-eps) return -1; return 0;&#125;int cmp(db k1,db k2)&#123;return sign(k1-k2);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 struct point&#123; db x,y; point operator + (const point &amp;k1) const&#123;return (point)&#123;k1.x+x,k1.y+y&#125;;&#125; point operator - (const point &amp;k1) const&#123;return (point)&#123;x-k1.x,y-k1.y&#125;;&#125; point operator * (db k1) const&#123;return (point)&#123;x*k1,y*k1&#125;;&#125; point operator / (db k1) const&#123;return (point)&#123;x/k1,y/k1&#125;;&#125; int operator == (const point &amp;k1) const&#123;return cmp(x,k1.x)==0&amp;&amp;cmp(y,k1.y)==0;&#125; // 逆时针旋转 point turn(db k1)&#123;return (point)&#123;x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1)&#125;;&#125; point turn90()&#123;return (point)&#123;-y,x&#125;;&#125; bool operator &lt; (const point k1) const&#123; int a=cmp(x,k1.x); if (a==-1) return 1; else if (a==1) return 0; else return cmp(y,k1.y)==-1; &#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; db dis(point k1)&#123;return ((*this)-k1).abs();&#125; point unit()&#123;db w=abs(); return (point)&#123;x/w,y/w&#125;;&#125; void scan()&#123;double k1,k2; scanf(\"%lf%lf\",&amp;k1,&amp;k2); x=k1; y=k2;&#125; void print()&#123;printf(\"%.11lf %.11lf\\n\",x,y);&#125; db getw()&#123;return atan2(y,x);&#125; point getdel()&#123;if (sign(x)==-1||(sign(x)==0&amp;&amp;sign(y)==-1)) return (*this)*(-1); else return (*this);&#125; int getP() const&#123;return sign(y)==1||(sign(y)==0&amp;&amp;sign(x)==-1);&#125;&#125;;int inmid(point k1,point k2,point k3)&#123;return inmid(k1.x,k2.x,k3.x)&amp;&amp;inmid(k1.y,k2.y,k3.y);&#125;db cross(point k1,point k2)&#123;return k1.x*k2.y-k1.y*k2.x;&#125;db dot(point k1,point k2)&#123;return k1.x*k2.x+k1.y*k2.y;&#125;db rad(point k1,point k2)&#123;return atan2(cross(k1,k2),dot(k1,k2));&#125;// -pi -&gt; piint compareangle (point k1,point k2)&#123; return k1.getP()&lt;k2.getP()||(k1.getP()==k2.getP()&amp;&amp;sign(cross(k1,k2))&gt;0);&#125;point proj(point k1,point k2,point q)&#123; // q 到直线 k1,k2 的投影 point k=k2-k1; return k1+k*(dot(q-k1,k)/k.abs2());&#125;point reflect(point k1,point k2,point q)&#123;return proj(k1,k2,q)*2-q;&#125;int clockwise(point k1,point k2,point k3)&#123;// k1 k2 k3 逆时针 1 顺时针 -1 否则 0 return sign(cross(k2-k1,k3-k1));&#125;int checkLL(point k1,point k2,point k3,point k4)&#123;// 求直线 (L) 线段 (S)k1,k2 和 k3,k4 的交点 return cmp(cross(k3-k1,k4-k1),cross(k3-k2,k4-k2))!=0;&#125;point getLL(point k1,point k2,point k3,point k4)&#123; db w1=cross(k1-k3,k4-k3),w2=cross(k4-k3,k2-k3); return (k1*w2+k2*w1)/(w1+w2);&#125;int intersect(db l1,db r1,db l2,db r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return cmp(r1,l2)!=-1&amp;&amp;cmp(r2,l1)!=-1;&#125;int checkSS(point k1,point k2,point k3,point k4)&#123; return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp; sign(cross(k3-k1,k4-k1))*sign(cross(k3-k2,k4-k2))&lt;=0&amp;&amp; sign(cross(k1-k3,k2-k3))*sign(cross(k1-k4,k2-k4))&lt;=0;&#125;db disSP(point k1,point k2,point q)&#123; point k3=proj(k1,k2,q); if (inmid(k1,k2,k3)) return q.dis(k3); else return min(q.dis(k1),q.dis(k2));&#125;db disSS(point k1,point k2,point k3,point k4)&#123; if (checkSS(k1,k2,k3,k4)) return 0; else return min(min(disSP(k1,k2,k3),disSP(k1,k2,k4)),min(disSP(k3,k4,k1),disSP(k3,k4,k2)));&#125;int onS(point k1,point k2,point q)&#123;return inmid(k1,k2,q)&amp;&amp;sign(cross(k1-q,k2-k1))==0;&#125;struct circle&#123; point o; db r; void scan()&#123;o.scan(); scanf(\"%lf\",&amp;r);&#125; int inside(point k)&#123;return cmp(r,o.dis(k));&#125;&#125;;struct line&#123; // p[0]-&gt;p[1] point p[2]; line(point k1,point k2)&#123;p[0]=k1; p[1]=k2;&#125; point&amp; operator [] (int k)&#123;return p[k];&#125; int include(point k)&#123;return sign(cross(p[1]-p[0],k-p[0]))&gt;0;&#125; point dir()&#123;return p[1]-p[0];&#125; line push()&#123; // 向外 ( 左手边 ) 平移 eps const db eps = 1e-6; point delta=(p[1]-p[0]).turn90().unit()*eps; return &#123;p[0]-delta,p[1]-delta&#125;; &#125;&#125;;point getLL(line k1,line k2)&#123;return getLL(k1[0],k1[1],k2[0],k2[1]);&#125;int parallel(line k1,line k2)&#123;return sign(cross(k1.dir(),k2.dir()))==0;&#125;int sameDir(line k1,line k2)&#123;return parallel(k1,k2)&amp;&amp;sign(dot(k1.dir(),k2.dir()))==1;&#125;int operator &lt; (line k1,line k2)&#123; if (sameDir(k1,k2)) return k2.include(k1[0]); return compareangle(k1.dir(),k2.dir());&#125;int checkpos(line k1,line k2,line k3)&#123;return k3.include(getLL(k1,k2));&#125;vector&lt;line&gt; getHL(vector&lt;line&gt; &amp;L)&#123; // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针 sort(L.begin(),L.end()); deque&lt;line&gt; q; for (int i=0;i&lt;(int)L.size();i++)&#123; if (i&amp;&amp;sameDir(L[i],L[i-1])) continue; while (q.size()&gt;1&amp;&amp;!checkpos(q[q.size()-2],q[q.size()-1],L[i])) q.pop_back(); while (q.size()&gt;1&amp;&amp;!checkpos(q[1],q[0],L[i])) q.pop_front(); q.push_back(L[i]); &#125; while (q.size()&gt;2&amp;&amp;!checkpos(q[q.size()-2],q[q.size()-1],q[0])) q.pop_back(); while (q.size()&gt;2&amp;&amp;!checkpos(q[1],q[0],q[q.size()-1])) q.pop_front(); vector&lt;line&gt;ans; for (int i=0;i&lt;q.size();i++) ans.push_back(q[i]); return ans;&#125;db closepoint(vector&lt;point&gt;&amp;A,int l,int r)&#123; // 最近点对 , 先要按照 x 坐标排序 if (r-l&lt;=5)&#123; db ans=1e20; for (int i=l;i&lt;=r;i++) for (int j=i+1;j&lt;=r;j++) ans=min(ans,A[i].dis(A[j])); return ans; &#125; int mid=l+r&gt;&gt;1; db ans=min(closepoint(A,l,mid),closepoint(A,mid+1,r)); vector&lt;point&gt;B; for (int i=l;i&lt;=r;i++) if (abs(A[i].x-A[mid].x)&lt;=ans) B.push_back(A[i]); sort(B.begin(),B.end(),[](point k1,point k2)&#123;return k1.y&lt;k2.y;&#125;); for (int i=0;i&lt;B.size();i++) for (int j=i+1;j&lt;B.size()&amp;&amp;B[j].y-B[i].y&lt;ans;j++) ans=min(ans,B[i].dis(B[j])); return ans;&#125;int checkposCC(circle k1,circle k2)&#123;// 返回两个圆的公切线数量 if (cmp(k1.r,k2.r)==-1) swap(k1,k2); db dis=k1.o.dis(k2.o); int w1=cmp(dis,k1.r+k2.r),w2=cmp(dis,k1.r-k2.r); if (w1&gt;0) return 4; else if (w1==0) return 3; else if (w2&gt;0) return 2; else if (w2==0) return 1; else return 0;&#125;vector&lt;point&gt; getCL(circle k1,point k2,point k3)&#123; // 沿着 k2-&gt;k3 方向给出 , 相切给出两个 point k=proj(k2,k3,k1.o); db d=k1.r*k1.r-(k-k1.o).abs2(); if (sign(d)==-1) return &#123;&#125;; point del=(k3-k2).unit()*sqrt(max((db)0.0,d)); return &#123;k-del,k+del&#125;;&#125;vector&lt;point&gt; getCC(circle k1,circle k2)&#123;// 沿圆 k1 逆时针给出 , 相切给出两个 int pd=checkposCC(k1,k2); if (pd==0||pd==4) return &#123;&#125;; db a=(k2.o-k1.o).abs2(),cosA=(k1.r*k1.r+a-k2.r*k2.r)/(2*k1.r*sqrt(max(a,(db)0.0))); db b=k1.r*cosA,c=sqrt(max((db)0.0,k1.r*k1.r-b*b)); point k=(k2.o-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c; return &#123;m-del,m+del&#125;;&#125; vector&lt;point&gt; TangentCP(circle k1,point k2)&#123;// 沿圆 k1 逆时针给出 db a=(k2-k1.o).abs(),b=k1.r*k1.r/a,c=sqrt(max((db)0.0,k1.r*k1.r-b*b)); point k=(k2-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c; return &#123;m-del,m+del&#125;;&#125; vector&lt;line&gt; TangentoutCC(circle k1,circle k2)&#123; int pd=checkposCC(k1,k2); if (pd==0) return &#123;&#125;; if (pd==1)&#123;point k=getCC(k1,k2)[0]; return &#123;(line)&#123;k,k&#125;&#125;;&#125; if (cmp(k1.r,k2.r)==0)&#123; point del=(k2.o-k1.o).unit().turn90().getdel(); return &#123;(line)&#123;k1.o-del*k1.r,k2.o-del*k2.r&#125;,(line)&#123;k1.o+del*k1.r,k2.o+del*k2.r&#125;&#125;; &#125; else &#123; point p=(k2.o*k1.r-k1.o*k2.r)/(k1.r-k2.r); vector&lt;point&gt;A=TangentCP(k1,p),B=TangentCP(k2,p); vector&lt;line&gt;ans; for (int i=0;i&lt;A.size();i++) ans.push_back((line)&#123;A[i],B[i]&#125;); return ans; &#125;&#125;vector&lt;line&gt; TangentinCC(circle k1,circle k2)&#123; int pd=checkposCC(k1,k2); if (pd&lt;=2) return &#123;&#125;; if (pd==3)&#123;point k=getCC(k1,k2)[0]; return &#123;(line)&#123;k,k&#125;&#125;;&#125; point p=(k2.o*k1.r+k1.o*k2.r)/(k1.r+k2.r); vector&lt;point&gt;A=TangentCP(k1,p),B=TangentCP(k2,p); vector&lt;line&gt;ans; for (int i=0;i&lt;A.size();i++) ans.push_back((line)&#123;A[i],B[i]&#125;); return ans;&#125;vector&lt;line&gt; TangentCC(circle k1,circle k2)&#123; int flag=0; if (k1.r&lt;k2.r) swap(k1,k2),flag=1; vector&lt;line&gt;A=TangentoutCC(k1,k2),B=TangentinCC(k1,k2); for (line k:B) A.push_back(k); if (flag) for (line &amp;k:A) swap(k[0],k[1]); return A;&#125;db getarea(circle k1,point k2,point k3)&#123; // 圆 k1 与三角形 k2 k3 k1.o 的有向面积交 point k=k1.o; k1.o=k1.o-k; k2=k2-k; k3=k3-k; int pd1=k1.inside(k2),pd2=k1.inside(k3); vector&lt;point&gt;A=getCL(k1,k2,k3); if (pd1&gt;=0)&#123; if (pd2&gt;=0) return cross(k2,k3)/2; return k1.r*k1.r*rad(A[1],k3)/2+cross(k2,A[1])/2; &#125; else if (pd2&gt;=0)&#123; return k1.r*k1.r*rad(k2,A[0])/2+cross(A[0],k3)/2; &#125;else &#123; int pd=cmp(k1.r,disSP(k2,k3,k1.o)); if (pd&lt;=0) return k1.r*k1.r*rad(k2,k3)/2; return cross(A[0],A[1])/2+k1.r*k1.r*(rad(k2,A[0])+rad(A[1],k3))/2; &#125;&#125;circle getcircle(point k1,point k2,point k3)&#123; db a1=k2.x-k1.x,b1=k2.y-k1.y,c1=(a1*a1+b1*b1)/2; db a2=k3.x-k1.x,b2=k3.y-k1.y,c2=(a2*a2+b2*b2)/2; db d=a1*b2-a2*b1; point o=(point)&#123;k1.x+(c1*b2-c2*b1)/d,k1.y+(a1*c2-a2*c1)/d&#125;; return (circle)&#123;o,k1.dis(o)&#125;;&#125;circle getScircle(vector&lt;point&gt; A)&#123; random_shuffle(A.begin(),A.end()); circle ans=(circle)&#123;A[0],0&#125;; for (int i=1;i&lt;A.size();i++) if (ans.inside(A[i])==-1)&#123; ans=(circle)&#123;A[i],0&#125;; for (int j=0;j&lt;i;j++) if (ans.inside(A[j])==-1)&#123; ans.o=(A[i]+A[j])/2; ans.r=ans.o.dis(A[i]); for (int k=0;k&lt;j;k++) if (ans.inside(A[k])==-1) ans=getcircle(A[i],A[j],A[k]); &#125; &#125; return ans;&#125;db area(vector&lt;point&gt; A)&#123; // 多边形用 vector&lt;point&gt; 表示 , 逆时针 db ans=0; for (int i=0;i&lt;A.size();i++) ans+=cross(A[i],A[(i+1)%A.size()]); return ans/2;&#125;int checkconvex(vector&lt;point&gt;A)&#123; int n=A.size(); A.push_back(A[0]); A.push_back(A[1]); for (int i=0;i&lt;n;i++) if (sign(cross(A[i+1]-A[i],A[i+2]-A[i]))==-1) return 0; return 1;&#125;int contain(vector&lt;point&gt;A,point q)&#123; // 2 内部 1 边界 0 外部 int pd=0; A.push_back(A[0]); for (int i=1;i&lt;A.size();i++)&#123; point u=A[i-1],v=A[i]; if (onS(u,v,q)) return 1; if (cmp(u.y,v.y)&gt;0) swap(u,v); if (cmp(u.y,q.y)&gt;=0||cmp(v.y,q.y)&lt;0) continue; if (sign(cross(u-v,q-v))&lt;0) pd^=1; &#125; return pd&lt;&lt;1;&#125;vector&lt;point&gt; ConvexHull(vector&lt;point&gt;A,int flag=1)&#123; // flag=0 不严格 flag=1 严格 int n=A.size(); vector&lt;point&gt;ans(n*2); sort(A.begin(),A.end()); int now=-1; for (int i=0;i&lt;A.size();i++)&#123; while (now&gt;0&amp;&amp;sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))&lt;flag) now--; ans[++now]=A[i]; &#125; int pre=now; for (int i=n-2;i&gt;=0;i--)&#123; while (now&gt;pre&amp;&amp;sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))&lt;flag) now--; ans[++now]=A[i]; &#125; ans.resize(now); return ans;&#125;db convexDiameter(vector&lt;point&gt;A)&#123; int now=0,n=A.size(); db ans=0; for (int i=0;i&lt;A.size();i++)&#123; now=max(now,i); while (1)&#123; db k1=A[i].dis(A[now%n]),k2=A[i].dis(A[(now+1)%n]); ans=max(ans,max(k1,k2)); if (k2&gt;k1) now++; else break; &#125; &#125; return ans;&#125;vector&lt;point&gt; convexcut(vector&lt;point&gt;A,point k1,point k2)&#123; // 保留 k1,k2,p 逆时针的所有点 int n=A.size(); A.push_back(A[0]); vector&lt;point&gt;ans; for (int i=0;i&lt;n;i++)&#123; int w1=clockwise(k1,k2,A[i]),w2=clockwise(k1,k2,A[i+1]); if (w1&gt;=0) ans.push_back(A[i]); if (w1*w2&lt;0) ans.push_back(getLL(k1,k2,A[i],A[i+1])); &#125; return ans;&#125;int checkPoS(vector&lt;point&gt;A,point k1,point k2)&#123; // 多边形 A 和直线 ( 线段 )k1-&gt;k2 严格相交 , 注释部分为线段 struct ins&#123; point m,u,v; int operator &lt; (const ins&amp; k) const &#123;return m&lt;k.m;&#125; &#125;; vector&lt;ins&gt;B; //if (contain(A,k1)==2||contain(A,k2)==2) return 1; vector&lt;point&gt;poly=A; A.push_back(A[0]); for (int i=1;i&lt;A.size();i++) if (checkLL(A[i-1],A[i],k1,k2))&#123; point m=getLL(A[i-1],A[i],k1,k2); if (inmid(A[i-1],A[i],m)/*&amp;&amp;inmid(k1,k2,m)*/) B.push_back((ins)&#123;m,A[i-1],A[i]&#125;); &#125; if (B.size()==0) return 0; sort(B.begin(),B.end()); int now=1; while (now&lt;B.size()&amp;&amp;B[now].m==B[0].m) now++; if (now==B.size()) return 0; int flag=contain(poly,(B[0].m+B[now].m)/2); if (flag==2) return 1; point d=B[now].m-B[0].m; for (int i=now;i&lt;B.size();i++)&#123; if (!(B[i].m==B[i-1].m)&amp;&amp;flag==2) return 1; int tag=sign(cross(B[i].v-B[i].u,B[i].m+d-B[i].u)); if (B[i].m==B[i].u||B[i].m==B[i].v) flag+=tag; else flag+=tag*2; &#125; //return 0; return flag==2;&#125;int checkinp(point r,point l,point m)&#123; if (compareangle(l,r))&#123;return compareangle(l,m)&amp;&amp;compareangle(m,r);&#125; return compareangle(l,m)||compareangle(m,r);&#125;int checkPosFast(vector&lt;point&gt;A,point k1,point k2)&#123; // 快速检查线段是否和多边形严格相交 if (contain(A,k1)==2||contain(A,k2)==2) return 1; if (k1==k2) return 0; A.push_back(A[0]); A.push_back(A[1]); for (int i=1;i+1&lt;A.size();i++) if (checkLL(A[i-1],A[i],k1,k2))&#123; point now=getLL(A[i-1],A[i],k1,k2); if (inmid(A[i-1],A[i],now)==0||inmid(k1,k2,now)==0) continue; if (now==A[i])&#123; if (A[i]==k2) continue; point pre=A[i-1],ne=A[i+1]; if (checkinp(pre-now,ne-now,k2-now)) return 1; &#125; else if (now==k1)&#123; if (k1==A[i-1]||k1==A[i]) continue; if (checkinp(A[i-1]-k1,A[i]-k1,k2-k1)) return 1; &#125; else if (now==k2||now==A[i-1]) continue; else return 1; &#125; return 0;&#125;// 拆分凸包成上下凸壳 凸包尽量都随机旋转一个角度来避免出现相同横坐标 // 尽量特判只有一个点的情况 凸包逆时针void getUDP(vector&lt;point&gt;A,vector&lt;point&gt;&amp;U,vector&lt;point&gt;&amp;D)&#123; db l=1e100,r=-1e100; for (int i=0;i&lt;A.size();i++) l=min(l,A[i].x),r=max(r,A[i].x); int wherel,wherer; for (int i=0;i&lt;A.size();i++) if (cmp(A[i].x,l)==0) wherel=i; for (int i=A.size();i;i--) if (cmp(A[i-1].x,r)==0) wherer=i-1; U.clear(); D.clear(); int now=wherel; while (1)&#123;D.push_back(A[now]); if (now==wherer) break; now++; if (now&gt;=A.size()) now=0;&#125; now=wherel; while (1)&#123;U.push_back(A[now]); if (now==wherer) break; now--; if (now&lt;0) now=A.size()-1;&#125;&#125;// 需要保证凸包点数大于等于 3,2 内部 ,1 边界 ,0 外部int containCoP(const vector&lt;point&gt;&amp;U,const vector&lt;point&gt;&amp;D,point k)&#123; db lx=U[0].x,rx=U[U.size()-1].x; if (k==U[0]||k==U[U.size()-1]) return 1; if (cmp(k.x,lx)==-1||cmp(k.x,rx)==1) return 0; int where1=lower_bound(U.begin(),U.end(),(point)&#123;k.x,-1e100&#125;)-U.begin(); int where2=lower_bound(D.begin(),D.end(),(point)&#123;k.x,-1e100&#125;)-D.begin(); int w1=clockwise(U[where1-1],U[where1],k),w2=clockwise(D[where2-1],D[where2],k); if (w1==1||w2==-1) return 0; else if (w1==0||w2==0) return 1; return 2;&#125;// d 是方向 , 输出上方切点和下方切点pair&lt;point,point&gt; getTangentCow(const vector&lt;point&gt; &amp;U,const vector&lt;point&gt; &amp;D,point d)&#123; if (sign(d.x)&lt;0||(sign(d.x)==0&amp;&amp;sign(d.y)&lt;0)) d=d*(-1); point whereU,whereD; if (sign(d.x)==0) return mp(U[0],U[U.size()-1]); int l=0,r=U.size()-1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (sign(cross(U[mid+1]-U[mid],d))&lt;=0) l=mid+1,ans=mid+1; else r=mid;&#125; whereU=U[ans]; l=0,r=D.size()-1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (sign(cross(D[mid+1]-D[mid],d))&gt;=0) l=mid+1,ans=mid+1; else r=mid;&#125; whereD=D[ans]; return mp(whereU,whereD);&#125;// 先检查 contain, 逆时针给出pair&lt;point,point&gt; getTangentCoP(const vector&lt;point&gt;&amp;U,const vector&lt;point&gt;&amp;D,point k)&#123; db lx=U[0].x,rx=U[U.size()-1].x; if (k.x&lt;lx)&#123; int l=0,r=U.size()-1,ans=U.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;&#125; point w1=U[ans]; l=0,r=D.size()-1,ans=D.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;&#125; point w2=D[ans]; return mp(w1,w2); &#125; else if (k.x&gt;rx)&#123; int l=1,r=U.size(),ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid-1])==-1) r=mid; else ans=mid,l=mid+1;&#125; point w1=U[ans]; l=1,r=D.size(),ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid-1])==1) r=mid; else ans=mid,l=mid+1;&#125; point w2=D[ans]; return mp(w2,w1); &#125; else &#123; int where1=lower_bound(U.begin(),U.end(),(point)&#123;k.x,-1e100&#125;)-U.begin(); int where2=lower_bound(D.begin(),D.end(),(point)&#123;k.x,-1e100&#125;)-D.begin(); if ((k.x==lx&amp;&amp;k.y&gt;U[0].y)||(where1&amp;&amp;clockwise(U[where1-1],U[where1],k)==1))&#123; int l=1,r=where1+1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid-1])==1) ans=mid,l=mid+1; else r=mid;&#125; point w1=U[ans]; l=where1,r=U.size()-1,ans=U.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;&#125; point w2=U[ans]; return mp(w2,w1); &#125; else &#123; int l=1,r=where2+1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid-1])==-1) ans=mid,l=mid+1; else r=mid;&#125; point w1=D[ans]; l=where2,r=D.size()-1,ans=D.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;&#125; point w2=D[ans]; return mp(w1,w2); &#125; &#125;&#125;struct P3&#123; db x,y,z; P3 operator + (P3 k1)&#123;return (P3)&#123;x+k1.x,y+k1.y,z+k1.z&#125;;&#125; P3 operator - (P3 k1)&#123;return (P3)&#123;x-k1.x,y-k1.y,z-k1.z&#125;;&#125; P3 operator * (db k1)&#123;return (P3)&#123;x*k1,y*k1,z*k1&#125;;&#125; P3 operator / (db k1)&#123;return (P3)&#123;x/k1,y/k1,z/k1&#125;;&#125; db abs2()&#123;return x*x+y*y+z*z;&#125; db abs()&#123;return sqrt(x*x+y*y+z*z);&#125; P3 unit()&#123;return (*this)/abs();&#125; int operator &lt; (const P3 k1) const&#123; if (cmp(x,k1.x)!=0) return x&lt;k1.x; if (cmp(y,k1.y)!=0) return y&lt;k1.y; return cmp(z,k1.z)==-1; &#125; int operator == (const P3 k1)&#123; return cmp(x,k1.x)==0&amp;&amp;cmp(y,k1.y)==0&amp;&amp;cmp(z,k1.z)==0; &#125; void scan()&#123; double k1,k2,k3; scanf(\"%lf%lf%lf\",&amp;k1,&amp;k2,&amp;k3); x=k1; y=k2; z=k3; &#125;&#125;;P3 cross(P3 k1,P3 k2)&#123;return (P3)&#123;k1.y*k2.z-k1.z*k2.y,k1.z*k2.x-k1.x*k2.z,k1.x*k2.y-k1.y*k2.x&#125;;&#125;db dot(P3 k1,P3 k2)&#123;return k1.x*k2.x+k1.y*k2.y+k1.z*k2.z;&#125;//p=(3,4,5),l=(13,19,21),theta=85 ans=(2.83,4.62,1.77)P3 turn3D(db k1,P3 l,P3 p)&#123; l=l.unit(); P3 ans; db c=cos(k1),s=sin(k1); ans.x=p.x*(l.x*l.x*(1-c)+c)+p.y*(l.x*l.y*(1-c)-l.z*s)+p.z*(l.x*l.z*(1-c)+l.y*s); ans.y=p.x*(l.x*l.y*(1-c)+l.z*s)+p.y*(l.y*l.y*(1-c)+c)+p.z*(l.y*l.z*(1-c)-l.x*s); ans.z=p.x*(l.x*l.z*(1-c)-l.y*s)+p.y*(l.y*l.z*(1-c)+l.x*s)+p.z*(l.x*l.x*(1-c)+c); return ans;&#125;typedef vector&lt;P3&gt; VP;typedef vector&lt;VP&gt; VVP;db Acos(db x)&#123;return acos(max(-(db)1,min(x,(db)1)));&#125;// 球面距离 , 圆心原点 , 半径 1db Odist(P3 a,P3 b)&#123;db r=Acos(dot(a,b)); return r;&#125;db r; P3 rnd;vector&lt;db&gt; solve(db a,db b,db c)&#123; db r=sqrt(a*a+b*b),th=atan2(b,a); if (cmp(c,-r)==-1) return &#123;0&#125;; else if (cmp(r,c)&lt;=0) return &#123;1&#125;; else &#123; db tr=pi-Acos(c/r); return &#123;th+pi-tr,th+pi+tr&#125;; &#125;&#125;vector&lt;db&gt; jiao(P3 a,P3 b)&#123; // dot(rd+x*cos(t)+y*sin(t),b) &gt;= cos(r) if (cmp(Odist(a,b),2*r)&gt;0) return &#123;0&#125;; P3 rd=a*cos(r),z=a.unit(),y=cross(z,rnd).unit(),x=cross(y,z).unit(); vector&lt;db&gt; ret = solve(-(dot(x,b)*sin(r)),-(dot(y,b)*sin(r)),-(cos(r)-dot(rd,b))); return ret;&#125;db norm(db x,db l=0,db r=2*pi)&#123; // change x into [l,r) while (cmp(x,l)==-1) x+=(r-l); while (cmp(x,r)&gt;=0) x-=(r-l); return x;&#125;db disLP(P3 k1,P3 k2,P3 q)&#123; return (cross(k2-k1,q-k1)).abs()/(k2-k1).abs();&#125;db disLL(P3 k1,P3 k2,P3 k3,P3 k4)&#123; P3 dir=cross(k2-k1,k4-k3); if (sign(dir.abs())==0) return disLP(k1,k2,k3); return fabs(dot(dir.unit(),k1-k2));&#125;VP getFL(P3 p,P3 dir,P3 k1,P3 k2)&#123; db a=dot(k2-p,dir),b=dot(k1-p,dir),d=a-b; if (sign(fabs(d))==0) return &#123;&#125;; return &#123;(k1*a-k2*b)/d&#125;;&#125;VP getFF(P3 p1,P3 dir1,P3 p2,P3 dir2)&#123;// 返回一条线 P3 e=cross(dir1,dir2),v=cross(dir1,e); db d=dot(dir2,v); if (sign(abs(d))==0) return &#123;&#125;; P3 q=p1+v*dot(dir2,p2-p1)/d; return &#123;q,q+e&#125;;&#125;// 3D Covex Hull Templatedb getV(P3 k1,P3 k2,P3 k3,P3 k4)&#123; // get the Volume return dot(cross(k2-k1,k3-k1),k4-k1);&#125;db rand_db()&#123;return 1.0*rand()/RAND_MAX;&#125;VP convexHull2D(VP A,P3 dir)&#123; P3 x=&#123;(db)rand(),(db)rand(),(db)rand()&#125;; x=x.unit(); x=cross(x,dir).unit(); P3 y=cross(x,dir).unit(); P3 vec=dir.unit()*dot(A[0],dir); vector&lt;point&gt;B; for (int i=0;i&lt;A.size();i++) B.push_back((point)&#123;dot(A[i],x),dot(A[i],y)&#125;); B=ConvexHull(B); A.clear(); for (int i=0;i&lt;B.size();i++) A.push_back(x*B[i].x+y*B[i].y+vec); return A;&#125;namespace CH3&#123; VVP ret; set&lt;pair&lt;int,int&gt; &gt;e; int n; VP p,q; void wrap(int a,int b)&#123; if (e.find(&#123;a,b&#125;)==e.end())&#123; int c=-1; for (int i=0;i&lt;n;i++) if (i!=a&amp;&amp;i!=b)&#123; if (c==-1||sign(getV(q[c],q[a],q[b],q[i]))&gt;0) c=i; &#125; if (c!=-1)&#123; ret.push_back(&#123;p[a],p[b],p[c]&#125;); e.insert(&#123;a,b&#125;); e.insert(&#123;b,c&#125;); e.insert(&#123;c,a&#125;); wrap(c,b); wrap(a,c); &#125; &#125; &#125; VVP ConvexHull3D(VP _p)&#123; p=q=_p; n=p.size(); ret.clear(); e.clear(); for (auto &amp;i:q) i=i+(P3)&#123;rand_db()*1e-4,rand_db()*1e-4,rand_db()*1e-4&#125;; for (int i=1;i&lt;n;i++) if (q[i].x&lt;q[0].x) swap(p[0],p[i]),swap(q[0],q[i]); for (int i=2;i&lt;n;i++) if ((q[i].x-q[0].x)*(q[1].y-q[0].y)&gt;(q[i].y-q[0].y)*(q[1].x-q[0].x)) swap(q[1],q[i]),swap(p[1],p[i]); wrap(0,1); return ret; &#125;&#125;VVP reduceCH(VVP A)&#123; VVP ret; map&lt;P3,VP&gt; M; for (VP nowF:A)&#123; P3 dir=cross(nowF[1]-nowF[0],nowF[2]-nowF[0]).unit(); for (P3 k1:nowF) M[dir].pb(k1); &#125; for (pair&lt;P3,VP&gt; nowF:M) ret.pb(convexHull2D(nowF.se,nowF.fi)); return ret;&#125;// 把一个面变成 ( 点 , 法向量 ) 的形式pair&lt;P3,P3&gt; getF(VP F)&#123; return mp(F[0],cross(F[1]-F[0],F[2]-F[0]).unit());&#125;// 3D Cut 保留 dot(dir,x-p)&gt;=0 的部分VVP ConvexCut3D(VVP A,P3 p,P3 dir)&#123; VVP ret; VP sec; for (VP nowF: A)&#123; int n=nowF.size(); VP ans; int dif=0; for (int i=0;i&lt;n;i++)&#123; int d1=sign(dot(dir,nowF[i]-p)); int d2=sign(dot(dir,nowF[(i+1)%n]-p)); if (d1&gt;=0) ans.pb(nowF[i]); if (d1*d2&lt;0)&#123; P3 q=getFL(p,dir,nowF[i],nowF[(i+1)%n])[0]; ans.push_back(q); sec.push_back(q); &#125; if (d1==0) sec.push_back(nowF[i]); else dif=1; dif|=(sign(dot(dir,cross(nowF[(i+1)%n]-nowF[i],nowF[(i+1)%n]-nowF[i])))==-1); &#125; if (ans.size()&gt;0&amp;&amp;dif) ret.push_back(ans); &#125; if (sec.size()&gt;0) ret.push_back(convexHull2D(sec,dir)); return ret;&#125;db vol(VVP A)&#123; if (A.size()==0) return 0; P3 p=A[0][0]; db ans=0; for (VP nowF:A) for (int i=2;i&lt;nowF.size();i++) ans+=abs(getV(p,nowF[0],nowF[i-1],nowF[i])); return ans/6;&#125;VVP init(db INF) &#123; VVP pss(6,VP(4)); pss[0][0] = pss[1][0] = pss[2][0] = &#123;-INF, -INF, -INF&#125;; pss[0][3] = pss[1][1] = pss[5][2] = &#123;-INF, -INF, INF&#125;; pss[0][1] = pss[2][3] = pss[4][2] = &#123;-INF, INF, -INF&#125;; pss[0][2] = pss[5][3] = pss[4][1] = &#123;-INF, INF, INF&#125;; pss[1][3] = pss[2][1] = pss[3][2] = &#123;INF, -INF, -INF&#125;; pss[1][2] = pss[5][1] = pss[3][3] = &#123;INF, -INF, INF&#125;; pss[2][2] = pss[4][3] = pss[3][1] = &#123;INF, INF, -INF&#125;; pss[5][0] = pss[4][0] = pss[3][0] = &#123;INF, INF, INF&#125;; return pss;&#125;","categories":[],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://aoudad.cn/tags/计算几何/"}]},{"title":"线段树模板","slug":"线段树模板","date":"2018-12-28T13:13:24.000Z","updated":"2018-12-28T13:14:13.385Z","comments":true,"path":"2018/12/28/线段树模板/","link":"","permalink":"http://aoudad.cn/2018/12/28/线段树模板/","excerpt":"","text":"题意描述线段树还不是很熟练，拿个Amori的线段树板子 InputOutputSample InputSample Output题意：思路：代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081ll ans[maxn*4];int a[maxn];ll tag[maxn*4];ll sum(ll a,ll b)&#123; return a+b;&#125;void build(int o,int l,int r)&#123; if(l==r) &#123; ans[o]=a[l]; return; &#125; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; build(lson,l,m); build(rson,m+1,r); ans[o]=sum(ans[lson], ans[rson]);&#125;void update(int o,int l,int r,int ql,int qr,int k)//区间修改:将[l,r]区间每个数都加上k&#123; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; if(ql&lt;=l&amp;&amp;qr&gt;=r) &#123; ans[o]+=k*(r-l+1) tag[o]+=k; return; &#125; if(tag[o]) &#123; tag[lson]+=tag[o]; tag[rson]+=tag[o]; ans[lson]+=tag[o]*(m-l+1) ans[rson]+=tag[o]*(r-m); tag[o]=0; &#125; if(qr&lt;=m) update(lson,l,m,ql,qr,k); else if(ql&gt;m) update(rson,m+1,r,ql,qr,k); else &#123; update(lson,l,m,ql,qr,k); update(rson,m+1,r,ql,qr,k); &#125; ans[o]=ans[lson]+ans[rson];&#125;void update_p(int o,int l,int r,int x,int y)//单点修改:将a[x]加上y&#123; if(L==R) &#123; ans[o]+=y return; &#125; int m=(l+r)/2,lson=o&lt;&lt;1,rson=lson|1; if(x&lt;=m)update(lson,l,m,x,y); else update(rson,m+1,r,x,y); ans[o]=ans[lson]+ans[rson];&#125;ll query(int o,int l,int r,int ql,int qr)//区间查询&#123; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; if(ql&lt;=l&amp;&amp;qr&gt;=r) return ans[o]; if(tag[o]) &#123; tag[lson]+=tag[o]; tag[rson]+=tag[o]; ans[lson]+=tag[o]*(m-l+1) ans[rson]+=tag[o]*(r-m); tag[o]=0; &#125; if(qr&lt;=m) return query(lson,l,m,ql,qr); if(ql&gt;m) return query(rson,m+1,r,ql,qr); return query(lson,l,m,ql,qr)+query(rson,m+1,r,ql,qr);&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"}]},{"title":"Codeforces1091Div2D-The Fair Nut and the Best Path","slug":"Codeforces1091Div2D","date":"2018-12-10T20:11:10.000Z","updated":"2018-12-10T20:30:36.822Z","comments":true,"path":"2018/12/11/Codeforces1091Div2D/","link":"","permalink":"http://aoudad.cn/2018/12/11/Codeforces1091Div2D/","excerpt":"","text":"题意描述outputstandard outputThe Fair Nut is going to travel to the Tree Country, in which there are n cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city u and go by a simple path to city v. He hasn’t determined his way, so it’s time to do it. A filling station is located in every city. Because of strange law, Nut can buy only wi liters of gasoline in the i-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can’t choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last. A path can consist of only one vertex. He also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it. InputThe first line contains a single integer n (1≤n≤3⋅105) — the number of cities.The second line contains n integers w1,w2,…,wn (0≤wi≤109) — the maximum amounts of liters of gasoline that Nut can buy in cities.Each of the next n−1 lines describes road and contains three integers u, v, c (1≤u,v≤n, 1≤c≤109, u≠v), where u and v — cities that are connected by this road and c — its length.It is guaranteed that graph of road connectivity is a tree. OutputPrint one number — the maximum amount of gasoline that he can have at the end of the path. Sample Input31 3 31 2 21 3 2 56 3 2 5 01 2 102 3 32 4 11 5 1 Sample Output3 7 题意：给一棵n个节点的树， 每个节点上都有一个权值$w_i$，每条边上有一个花费$c_i$，任意选择起点u和终点v(u和v可以是同一个节点)，定义价值$x(u, v)$为从起点u到终点v的路径上所有的节点的权值之和减去所有的边的花费最大，输出这个最大值，其中，到达任任何一个节点的前一瞬间，x不能是负数。输出最大的x。 思路：树上dp。以节点1为起点dfs，$dp[u]=w[u]+max(0, max(dp[v]-c[u, v]))$,其中dp[i]表示，额，好像没有特别明确的含义，大概是表示经过i节点的最大收益吧，显然不一定非要从叶子节点一直push到根节点，也可以中间节点的某两条子树路径是答案，因此需要拿到(dp[v]-c[u, v])中的最大的两个值，这里可以O(n)做，但是由于排序O(nlogn)是没有卡的，所以直接排序也是可以的，但是我在比赛中用了很蠢的O(n^2)，不知道自己是怎么想的，然后愉快的fst了，掉分哭唧唧。然后就xjb更新答案就行了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1000000007;const ll maxn = 5e5+7;ll a[maxn];vector&lt;pair&lt;ll, ll&gt; &gt; G[maxn];int vis[maxn];ll ans = -1;ll dfs(int f, int u, ll c)&#123; ll res = a[u]; vector&lt;ll&gt; tmp; for(int i=0;i&lt;G[u].size();++i) &#123; if(G[u][i].first==f)continue; ll t = dfs(u, G[u][i].first, G[u][i].second); res = max(res, t+a[u]); tmp.push_back(t); &#125; sort(tmp.begin(), tmp.end(), greater&lt;ll&gt;()); tmp.push_back(0); tmp.push_back(0); ans = max(a[u]+tmp[0]+tmp[1], ans); ans = max(ans, res); return res-c;&#125;int main()&#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; a[i]; for(int i=0;i&lt;n-1;++i) &#123; ll u, v, c; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; G[u].push_back(make_pair(v, c)); G[v].push_back(make_pair(u, c)); &#125; dfs(0, 1, 0); cout &lt;&lt; ans &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"树上DP","slug":"树上DP","permalink":"http://aoudad.cn/tags/树上DP/"}]},{"title":"Codeforces1091Div2E-The Fair Nut and Strings","slug":"Codeforces526Div2E","date":"2018-12-10T19:37:32.000Z","updated":"2018-12-10T20:09:04.604Z","comments":true,"path":"2018/12/11/Codeforces526Div2E/","link":"","permalink":"http://aoudad.cn/2018/12/11/Codeforces526Div2E/","excerpt":"","text":"题意描述Recently, the Fair Nut has written k strings of length n, consisting of letters “a” and “b”. He calculated c — the number of strings that are prefixes of at least one of the written strings. Every string was counted only one time. Then, he lost his sheet with strings. He remembers that all written strings were lexicographically not smaller than string s and not bigger than string t. He is interested: what is the maximum value of c that he could get. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b, but a≠b; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.Input The first line contains two integers n and k (1≤n≤5⋅105, 1≤k≤$10^9$).The second line contains a string s (|s|=n) — the string consisting of letters “a” and “b.The third line contains a string t (|t|=n) — the string consisting of letters “a” and “b.It is guaranteed that string s is lexicographically not bigger than t. OutputPrint one number — maximal value of c. Sample Input2 4aabb 3 3ababba 4 5abbbbaaa Sample Output6 8 8 题意：给两个只由字符ab构成的长度为n的字符串s、t，保证s的字典序一定小于t，求字典序小于t且大于s的所有长度为n的字符串中选出k个，使得从中得到的本质不同的前缀的数量最大，输出这个最大值。 思路：比赛的时候想了一下没有k这个限制的做法，然后没有往深的地方想，结束之后发现原来做法是差不太多的。考虑一个完全二叉字典树，其中每个节点最多只有两个儿子，也就是‘a’和’b’，将s和t插进去，显然答案就是从这个字典树中s的叶子结点和t的叶子节点之间选出k个叶子节点，使得这k条路经上的总结点数最大。但是由于我们只需要统计数量，因此不需要真的把这棵树建起来，我们通过观察这颗字典树可以发现，假设s[i-1]和t[i-1]在树上的距离为d（也就是他们之间的同级节点的个数加1），则分类讨论，当s[i]=t[i]时，他们相对于s[i-1]和t[i-1]的方向都相同，因此的距离为2d-1，如果s[i]&gt;t[i]，那么距离为2d,否则距离为2*d-2。口胡式证明正确性：当两个节点之间的距离小于k的时候，显然每条路径都经过是最优的，当两个节点之间的距离大于k的时候，直接加上k就可以了。首先这样的做法肯定是达到了上界，没有其他做法能比这样的策略获得的贡献更大，其次，如果这层节点的上一层节点距离已经可以走k条路经，显然这一层也可以走k条路经，如果上一层的距离小于k，那么这一层的每个节点肯定都是可达的，可行性得证。所以这个做法是没毛病的。实现起来比较简单。 代码：123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll n, k; string s, t; cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s &gt;&gt; t; ll ans = 0, tmp = 1; for(int i=0;i&lt;n;++i) if(tmp&lt;k) &#123; tmp &lt;&lt;= 1; if(s[i]==t[i]) --tmp; else if(s[i]=='b'&amp;&amp;t[i]=='a')tmp-=2; tmp = min(tmp, k); &#125; ans += tmp; cout &lt;&lt;ans &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://aoudad.cn/tags/贪心/"}]},{"title":"Project Euler","slug":"Project-Euler","date":"2018-11-23T18:20:17.000Z","updated":"2018-11-26T11:31:37.549Z","comments":true,"path":"2018/11/24/Project-Euler/","link":"","permalink":"http://aoudad.cn/2018/11/24/Project-Euler/","excerpt":"","text":"代码：1234567891011121314151617181920212223242526272829// P21#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; set&lt;int&gt; res; for(int i=1;i&lt;=10000;++i) &#123; int tmp = 1; for(int j=2;j*j&lt;=i;++j) &#123; if(i%j==0) tmp += j + i/j; if(j*j==i) tmp -= j; &#125; int t = 1; for(int j=2;j*j&lt;=tmp;++j) &#123; if(tmp%j==0) t += j + tmp/j; if(j*j==tmp) t -= j; &#125; if(t==i&amp;&amp;i!=tmp)res.insert(t), res.insert(i); &#125; int ans = 0; for(auto x:res)ans += x; cout &lt;&lt; ans &lt;&lt; endl;&#125; 123456789101112131415# P22with open(\"in.txt\") as f: s = f.read().split(',') res = 0 cnt = 0 s.sort() for item in s: cnt += 1 tmp = 0 for p in item: if p != '\"': tmp += ( ord(p)-ord('A')+1 ) res += tmp * cnt if item == '\"COLIN\"':print(tmp,cnt,item)print(res) 12345678910111213141516171819202122232425262728293031323334//P23#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint vis[30000];int main()&#123; vector&lt;int&gt; res; for(int i=1;i&lt;=28123;++i) &#123; int tmp = 1; for(int j=2;j*j&lt;=i;++j) &#123; if(i%j==0) tmp += i/j+j; if(j*j==i) tmp -= j; &#125; if(tmp&gt;i) res.push_back(i); &#125; long long ans = 0; for(int i=0;i&lt;res.size();++i) for(int j=i;j&lt;res.size();++j) if(res[i]+res[j]&gt;28123) break; else vis[res[i]+res[j]]++; for(int i=1;i&lt;=28123;++i) if(!vis[i]) ans += i; cout &lt;&lt; ans &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334P24康拓展开裸题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint vis[30000];static const int FAC[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; // 阶乘//康托展开逆运算void decantor(int x, int n)&#123; vector&lt;int&gt; v; // 存放当前可选数 vector&lt;int&gt; a; // 所求排列组合 for(int i=0;i&lt;=n;i++) v.push_back(i); for(int i=10;i&gt;=1;i--) &#123; int r = x % FAC[i-1]; int t = x / FAC[i-1]; x = r; sort(v.begin(),v.end());// 从小到大排序 a.push_back(v[t]); // 剩余数里第t+1个数为当前位 v.erase(v.begin()+t); // 移除选做当前位的数 &#125; for(auto x: a) cout &lt;&lt; x &lt;&lt; ' ' ;&#125;int main()&#123; decantor(999999, 10);&#125; 1234567#P25L = []L.append(1)L.append(1)while(L[-1]&lt;pow(10,999)): L.append(L[-1]+L[-2])print(len(L))","categories":[],"tags":[{"name":"Project_Euler","slug":"Project-Euler","permalink":"http://aoudad.cn/tags/Project-Euler/"}]},{"title":"poj1837","slug":"poj1837","date":"2018-11-23T16:24:31.000Z","updated":"2018-11-23T17:39:21.911Z","comments":true,"path":"2018/11/24/poj1837/","link":"","permalink":"http://aoudad.cn/2018/11/24/poj1837/","excerpt":"","text":"题意描述Gigel has a strange “balance” and he wants to poise it. Actually, the device is different from any other ordinary balance.It orders two arms of negligible weight and each arm’s length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 &lt;= G &lt;= 20) knowing that these weights have distinct values in the range 1..25. Gigel may droop any weight of any hook but he is forced to use all the weights.Finally, Gigel managed to balance the device using the experience he gained at the National Olympiad in Informatics. Now he would like to know in how many ways the device can be balanced. Knowing the repartition of the hooks and the set of the weights write a program that calculates the number of possibilities to balance the device.It is guaranteed that will exist at least one solution for each test case at the evaluation. InputThe input has the following structure:• the first line contains the number C (2 &lt;= C &lt;= 20) and the number G (2 &lt;= G &lt;= 20);• the next line contains C integer numbers (these numbers are also distinct and sorted in ascending order) in the range -15..15 representing the repartition of the hooks; each number represents the position relative to the center of the balance on the X axis (when no weights are attached the device is balanced and lined up to the X axis; the absolute value of the distances represents the distance between the hook and the balance center and the sign of the numbers determines the arm of the balance to which the hook is attached: ‘-‘ for the left arm and ‘+’ for the right arm);• on the next line there are G natural, distinct and sorted in ascending order numbers in the range 1..25 representing the weights’ values. OutputThe output contains the number M representing the number of possibilities to poise the balance. Sample Input2 4-2 33 4 5 8 Sample Output2 题意：天平上有n个不同位置的挂钩，有m种不同质量的钩码，求有多少种让天平平衡的方法。钩码需要全部用上。 思路：设$dp[i][j]$表示前i个钩码，使目前天平的力矩为j的方案有多少种，其中j==0时表示天平平衡。则对于当前第i个钩码如果状态j可以由j-w[i]c[k]得到，那么加上它的方案数.即$$dp[i][j]=\\Sigma_{k=0}^ndp[i][j-w[i]p[k]]$$当然此时j作为下标不能是负数，因此往正方向移动（201525=7500位）。注意处理一下$j-w[i]p[k]$超过范围时不考虑。当然也可以换成扫$j-w[i]p[k]$，这样还可以剪枝。 代码：123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint dp[2][15002], p[50], w[70];int main()&#123; int n, m, t = 0; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;++i) cin &gt;&gt; p[i]; for(int i=0;i&lt;m;++i) cin &gt;&gt; w[i]; dp[t][7500] = 1; for(int i=0;i&lt;m;++i) &#123; t^=1; memset(dp[t], 0, sizeof dp[t]); for(int j=0;j&lt;=15000;++j) if(dp[1^t][j]) for(int k=0;k&lt;n;++k) dp[t][j+w[i]*p[k]] += dp[t^1][j]; &#125; cout &lt;&lt; dp[t][7500] &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"2018青岛区域赛总结","slug":"2018青岛区域赛总结","date":"2018-11-12T14:24:16.000Z","updated":"2018-11-12T14:24:30.886Z","comments":true,"path":"2018/11/12/2018青岛区域赛总结/","link":"","permalink":"http://aoudad.cn/2018/11/12/2018青岛区域赛总结/","excerpt":"","text":"成绩题数：5题罚时：626排名：Rank56奖牌：银牌 比赛过程：热身赛算是第一次参加热身赛【省赛那个也不算吧，当时还一脸懵逼不知道要干嘛刚开始我在搞机器，amori很快看完了所有题目，然后告诉了我做法让我写，然而我不知道是紧张还是什么原因，码的磕磕绊绊的，还直接wa了一发，然后换amori上来写A和B，我看了一下C，感觉是放上来做压力测试的，就不打算交了，打算测其他的东西的时候PC^2挂掉了，于是又等了许久恢复后才继续测其他的，发现了行末空格会返回OFE，评测实在是太慢了，就没测能跑多大的时间复杂度了， 反正也是要莽。 热身赛当晚由于下午的时候我的状态实在是太差，于是当晚拉了几道简单题做，事实证明这是我们当时做的最正确的决定之一了，因为不仅调整了状态，而且还使我(们)更加了解队友的思维习惯和学习经历，而且还刚好做了一道二分最大化最小值的问题。 正式赛当天比赛开始，还是按照原本的开题顺序，amori从头，cmr从D开始，而我先去搞了一下机器和调了下gedit，调好之后看了一眼M，感觉是个签到题，往下一扫，签到成功这是你的签到奖励.jpg，果断直接开始写，交上去1A，然后扫了一眼榜，C和J有人过，然后amori给我讲了J的题意，讨论了一下就开始写了，WA，换amori写，39minA。这时我发现有支中学生队过了G，于是觉得这应该是一个算法题而非思维题，从过的那么快来看amori可能是可做的，于是我就忽悠amori去看G，然后这家伙就看漏题意了。Amori过J之后我和cmr就开始一边讨论C一边写，63min的时候1A。这个时候刷了一下榜，发现冲上了金线【然而并没有什么卵用】，开始了长达一个小时的挂机时间，期间amori和cmr给我讲了BDEFGLK的题意，然而其中有4个题目都是没讲清楚的，L感觉是要推出组合公式，因为看起来就没有啥递推式，然后就自闭了，然后果断把这道题丢给cmr，去仔细的看了一下F题，发现是个构造题，应该是当时最可做的，于是和cmr一边讨论一边写一边调，然后发现是写挫了，换了个写法交上去161min1A，此时大概在银牌头的位置。amori确定了E二分加贪心的做法，避开了爆longlong的坑，但是忘了特判，于是又开始了长达一个小时的xjb搞+莽的自闭时间，所幸250min的时候利用随机数据找到了问题，过了。然后就开始了本次比赛最傻逼的时间。看了看榜，在没有歪榜的情况下，D和L应该是最可做的，但是当时的心态，实在是太跳了，虽然D和L看起来可做但是没有很用心思考。列了列L小数据的答案，决定果断放弃【。然后和cmr一起口头D题，说出了正解，但是很快被我随口说了一个ac自动机给糊弄了，然后还忽悠amori去写了，然后就发现做法不对，浪费了宝贵的半个小时，于是剩下的时间就在吃东西和吹水了。最终是毫无悬念的5题银牌，罚时还算是比较能看的，除了E题，相比我们平时训练来说。 总结首先结论，这次的银牌，关键原因是因为运气好，因为我们队三个人都相信换成大二的其他队伍来QD赛区成绩都应该和我们差不多。其次，这次做得比较好的是，热身赛的时候发现状态不对，当晚便选择做了几道简单题来调整状态。再其次，更加信任队友了，虽然信任了但还是没做出来L，但势必会使得后面的训练更加融洽。再再其次，这次前期没有特别明显的卡题，中期没有死咬着一道题不放。然后，这次暴露出来的比较明显的缺点（主要是指我）是，对于不确定方法对不对的题目，即使是在中后期，我都很难下决心去试试，这个在平时训练的时候已经显示出来了，但是一直没有重视。因为cmr不是代码手，而这种题目一般不经过amori的手，所以我不写的话不行。再然后，还是出现了读错题/读漏题的情况，原本在没有思路的时候我应该把每个题目再好好读一遍的，结果还是没有，这种情况不改的话，随着每个队员能力的提升，对队伍的影响会越来越大。再再然后就是最本质的解题能力太差的问题，包括常规套路和思维题的训练都太少。 未来从下周起直到十二月初的选拔赛结束为止【可能会更久，也可能根据实际情况修改】，我们队都以个人的单挑实力提升为主，在没有其他变数的情况下，每周只会有一场左右的队伍训练。1，在训练时应同时注意常规算法套路和思维题【抖机灵题】的训练。2，注意涉及的广度，尽量做到每个知识点即使没法很快做出来，在和队友讨论或者经提醒之后能知道怎么做，至少在比赛中能和队友讨论相关做法。3，注意深度，对于自己擅长的领域，要做到不依赖任何人和搜索引擎的情况下能独立解出有一定综合难度的问题。4，对今年的杭电多校牛客多校要注意补题。5，关注codeforces的比赛6，注意代码实现能力的培养@cmr。","categories":[],"tags":[]},{"title":"POJ1840Eqs","slug":"POJ1840Eqs","date":"2018-11-08T16:05:58.000Z","updated":"2018-11-08T16:12:40.925Z","comments":true,"path":"2018/11/09/POJ1840Eqs/","link":"","permalink":"http://aoudad.cn/2018/11/09/POJ1840Eqs/","excerpt":"","text":"题意描述Consider equations having the following form:a1x1 3+ a2x2 3+ a3x3 3+ a4x4 3+ a5x5 3=0The coefficients are given integers from the interval [-50,50].It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}. Determine how many solutions satisfy the given equation. InputThe only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks. OutputThe output will contain on the first line the number of the solutions for the given equation. Sample Input37 29 41 43 47 Sample Output654 题意：求满足那个方程的解的个数。 思路：数据范围较小，考虑暴力枚举，对$a_1x_1^3+a_2x_2^3+a_3x_3^3+a_4x_4^3+a_5x_5^3=0$变形得$-(a_1x_1^3+a_2x_2^3)=a_3x_3^3+a_4x_4^3+a_5x_5^3$，枚举左边，存一个hash表，hash[i]表示左边和为i的方案数，再枚举右边即可获取答案。复杂度$O(100^3)$，另外由于可能出现负数，所以要做一下偏移。思路和折半枚举类似，但是那个可以做浮点数的。 代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int s = 25000000;short res[s+10];int main()&#123; int a[5]; for(int i=0;i&lt;5;++i) cin &gt;&gt; a[i]; for(int i=-50;i&lt;=50;++i) for(int j=-50;j&lt;=50;++j) if(i!=0&amp;&amp;j!=0)&#123; int t = i*i*i*a[0]+j*j*j*a[1];t*=-1; if(t&lt;0) t += s; res[t]++; &#125; long long ans = 0; for(int i=-50;i&lt;=50;++i) for(int j=-50;j&lt;=50;++j) for(int k=-50;k&lt;=50;++k) if(i!=0&amp;&amp;j!=0&amp;&amp;k!=0)&#123; int t = i*i*i*a[2]+j*j*j*a[3]+k*k*k*a[4]; if(t&lt;0) t += s; ans += res[t]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[],"tags":[]},{"title":"BZOJ1002轮状病毒","slug":"BZOJ1002轮状病毒","date":"2018-11-08T15:30:04.000Z","updated":"2018-11-08T15:33:50.879Z","comments":true,"path":"2018/11/08/BZOJ1002轮状病毒/","link":"","permalink":"http://aoudad.cn/2018/11/08/BZOJ1002轮状病毒/","excerpt":"","text":"题意描述轮状病毒有很多变种，所有轮状病毒的变种都是从一个轮状基产生的。一个N轮状基由圆环上N个不同的基原子和圆心处一个核原子构成的，2个原子之间的边表示这2个原子之间的信息通道。N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不同的3轮状病毒。现给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒 Input第一行有1个正整数n Output计算出的不同的n轮状病毒数输出 Sample Input3 Sample Output16 题意：给一个车轮状的无向图，生成树计数。 思路：利用基尔霍夫矩阵树定理，打表获得n为3到9时的答案，扔进BM板子里获得递推式，用java的BigInteger根据递推式写出答案。 代码：12345678910111213141516171819import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;import java.math.BigInteger; public class Main&#123; public static void main(String[] args) &#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); BigInteger[] arr = new BigInteger[101]; arr[0] = new BigInteger(\"1\"); arr[1] = new BigInteger(\"1\"); arr[2] = new BigInteger(\"5\"); arr[3] = new BigInteger(\"16\"); for(int i=4;i&lt;=n;++i) arr[i] = arr[i-1].subtract(arr[i-2]).multiply(new BigInteger(\"4\")).add(arr[i-3]); System.out.println(arr[n]); &#125;&#125;","categories":[],"tags":[]},{"title":"BZOJ1001狼抓兔子","slug":"BZOJ1001狼抓兔子","date":"2018-11-08T15:18:29.000Z","updated":"2018-11-08T15:29:18.496Z","comments":true,"path":"2018/11/08/BZOJ1001狼抓兔子/","link":"","permalink":"http://aoudad.cn/2018/11/08/BZOJ1001狼抓兔子/","excerpt":"","text":"题意描述现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路 1:(x,y)&lt;==&gt;(x+1,y) 2:(x,y)&lt;==&gt;(x,y+1) 3:(x,y)&lt;==&gt;(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input3 4 5 6 4 4 3 1 7 5 3 5 6 7 8 8 7 6 5 5 5 5 6 6 6 Sample Output14 题意：给一个网格图，求其最小割。 思路：显然就是给一个无向图，求 S(1，1)到T(n，m)的最小割，但是这里套用普通的dinic等最大流算法是会tle/mle/re的，因为n，m都是1e3的。由于给的是一个平面图，将其转化为对偶图，求最短路即可。对偶图可以在这里学习，最大最小定理(平面图最小割 对偶图)。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=2000110;struct qnode&#123; int v; int c; qnode(int _v=0,int _c=0):v(_v),c(_c) &#123;&#125; bool operator &lt;(const qnode &amp;r)const &#123; return c&gt;r.c; &#125;&#125;;struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt;E[MAXN];bool vis[MAXN];int dist[MAXN];void Dijkstra(int n,int start)&#123; memset(vis,false,sizeof(vis)); for(int i=1; i&lt;=n; i++) dist[i]=INF; priority_queue&lt;qnode&gt;que; while(!que.empty()) que.pop(); dist[start]=0; que.push(qnode(start,0)); qnode tmp; while(!que.empty()) &#123; tmp=que.top(); que.pop(); int u=tmp.v; if(vis[u]) continue; vis[u]=true; for(int i=0; i&lt;E[u].size(); i++) &#123; int v=E[tmp.v][i].v; int cost=E[u][i].cost; if(!vis[v]&amp;&amp;dist[v]&gt;dist[u]+cost) &#123; dist[v]=dist[u]+cost; que.push(qnode(v,dist[v])); &#125; &#125; &#125;&#125;void addedge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w)); E[v].push_back(Edge(u,w));&#125;int main()&#123; int n, m, a; scanf(\"%d%d\", &amp;n, &amp;m); if(n==1) &#123; int mi = 1e9; for(int i=0;i&lt;m-1;++i)&#123;scanf(\"%d\", &amp;a);mi = min(mi, a);&#125; cout &lt;&lt; mi &lt;&lt; endl; return 0; &#125; if(m==1) &#123; int mi = 1e9; for(int i=0;i&lt;n-1;++i)&#123;scanf(\"%d\", &amp;a);mi = min(mi, a);&#125; cout &lt;&lt; mi &lt;&lt; endl; return 0; &#125; int S = (n-1)*(m-1)*2+1, T = S+1; for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;m-1; ++j) &#123; scanf(\"%d\", &amp;a); if(i==0) addedge(S, j+1, a); else if(i==n-1) addedge(2*i*(m-1)-m+j+2, T, a); else addedge(2*i*(m-1)+j-m+2,2*i*(m-1)+j+1, a); &#125; for(int i=0; i&lt;n-1; ++i) for(int j=0; j&lt;m; ++j) &#123; scanf(\"%d\", &amp;a); if(j==m-1) addedge(S, 2*i*(m-1)+j, a); else if(j==0)addedge(2*i*(m-1)+m, T, a); else addedge(2*i*(m-1)+j, 2*i*(m-1)+j+m, a); &#125; for(int i=0; i&lt;n-1; ++i) for(int j=0; j&lt;m-1; ++j) &#123; scanf(\"%d\", &amp;a); addedge(2*(m-1)*i+j+1, 2*(m-1)*i+j+m, a); &#125; Dijkstra(T, S); cout &lt;&lt; dist[T] &lt;&lt; endl;&#125;","categories":[],"tags":[]},{"title":"zuidadaiquanebihezitu","slug":"zuidadaiquanebihezitu","date":"2018-11-01T15:28:00.000Z","updated":"2018-11-01T15:28:50.887Z","comments":true,"path":"2018/11/01/zuidadaiquanebihezitu/","link":"","permalink":"http://aoudad.cn/2018/11/01/zuidadaiquanebihezitu/","excerpt":"","text":"题意描述先说结论，以后有空再补，最大权闭合子图的权值等于所有正权点之和减去最小割 InputOutputSample InputSample Output题意：思路：代码：1","categories":[],"tags":[]},{"title":"BM线性递推式板子","slug":"BM线性递推式板子","date":"2018-10-14T17:53:21.000Z","updated":"2018-10-14T18:02:07.781Z","comments":true,"path":"2018/10/15/BM线性递推式板子/","link":"","permalink":"http://aoudad.cn/2018/10/15/BM线性递推式板子/","excerpt":"","text":"描述先手算/打表找出序列的前几项，然后扔进这两个板子里就可以了，其中杜教的板子可以直接求出第n项的值，而meto的板子则是可以求出递推式，一般8，9项就可以了，需要的项数取决于这个递推式所涉及的项，当然这个序列必须得是线性的 Meto的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-7;const int maxn=1e5;vector&lt;double&gt;ps[maxn+10];int fail[maxn+10];double x[maxn+10],delta[maxn+10];int n,pn;int main()&#123; while(~scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; pn=0; for(int i=1; i&lt;=n; i++) scanf(\"%lf\",x+i); for(int i=1; i&lt;=n; i++) &#123; double dt=-x[i]; for(int j=0; j&lt;ps[pn].size(); j++) dt+=x[i-j-1]*ps[pn][j]; delta[i]=dt; if(fabs(dt)&lt;=eps) continue; fail[pn]=i; if(!pn) &#123; ps[++pn].resize(1); continue; &#125; vector&lt;double&gt; &amp;ls=ps[pn-1]; double k=-dt/delta[fail[pn-1]]; vector&lt;double&gt;cur; cur.resize(i-fail[pn-1]-1); cur.push_back(-k); for(int j=0; j&lt;ls.size(); j++) cur.push_back(ls[j]*k); if(cur.size()&lt;ps[pn].size()) cur.resize(ps[pn].size()); for(int j=0; j&lt;ps[pn].size(); j++) cur[j]+=ps[pn][j]; ps[++pn]=cur; &#125; int len=(int)ps[pn].size(); for(int i=0; i&lt;len; ++i) printf(\"%g%c\",ps[pn][i],\" \\n\"[i==len-1]); &#125; return 0;&#125; 杜教的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b)&#123; ll res=1; a%=mod; assert(b&gt;=0); for(; b; b&gt;&gt;=1) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; &#125; return res;&#125;// headint _,n;namespace linear_seq&#123;const int N=10010;ll res[N],base[N],_c[N],_md[N];vector&lt;int&gt; Md;void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1; i&gt;=k; i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i];&#125;int solve(ll n,VI a,VI b) // a 系数 b 初值 b[n+1]=a[0]*b[n]+...&#123;// printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt; p&gt;=0; p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1; i&gt;=0; i--) res[i+1]=res[i]; res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans;&#125;VI BM(VI s)&#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C;&#125;int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));&#125;&#125;;int main()&#123; ll n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v&#123;1,5,11,36,95,281,781,2245,6336,18061&#125;; printf(\"%d\\n\",linear_seq::gao(v,n-1)); &#125;&#125; 例题：HDU6172，HDU6185 其中6185的打表代码为： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mz[10][15];int x, y, n,cnt;int ok()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) if(mz[i][j]==0) &#123; x=i;y=j; return false; &#125; return 1;&#125;void s()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) printf(\"%d%c\", mz[i][j], \" \\n\"[j==n]);&#125;void dfs(int i, int j)&#123; //s(); if(i&lt;=3&amp;&amp;mz[i+1][j]==0) &#123; mz[i][j]=mz[i+1][j]=1; if(ok()) &#123; mz[i][j]=mz[i+1][j]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i+1][j]=0; &#125; if(j&lt;n&amp;&amp;mz[i][j+1]==0) &#123; mz[i][j]=mz[i][j+1]=1; if(ok()) &#123; mz[i][j]=mz[i][j+1]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i][j+1]=0; &#125;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) &#123; memset(mz, 0, sizeof mz); n = i;cnt=0;dfs(1, 1); cout &lt;&lt; cnt &lt;&lt; ','; &#125;&#125;","categories":[],"tags":[]},{"title":"各种板子","slug":"temp","date":"2018-10-14T17:53:21.000Z","updated":"2018-10-29T10:25:00.550Z","comments":true,"path":"2018/10/15/temp/","link":"","permalink":"http://aoudad.cn/2018/10/15/temp/","excerpt":"","text":"BM线性递推式板子先手算/打表找出序列的前几项，然后扔进这两个板子里就可以了，其中杜教的板子可以直接求出第n项的值，而meto的板子则是可以求出递推式，一般8，9项就可以了，需要的项数取决于这个递推式所涉及的项，当然这个序列必须得是线性的 Meto的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-7;const int maxn=1e5;vector&lt;double&gt;ps[maxn+10];int fail[maxn+10];double x[maxn+10],delta[maxn+10];int n,pn;int main()&#123; while(~scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; pn=0; for(int i=1; i&lt;=n; i++) scanf(\"%lf\",x+i); for(int i=1; i&lt;=n; i++) &#123; double dt=-x[i]; for(int j=0; j&lt;ps[pn].size(); j++) dt+=x[i-j-1]*ps[pn][j]; delta[i]=dt; if(fabs(dt)&lt;=eps) continue; fail[pn]=i; if(!pn) &#123; ps[++pn].resize(1); continue; &#125; vector&lt;double&gt; &amp;ls=ps[pn-1]; double k=-dt/delta[fail[pn-1]]; vector&lt;double&gt;cur; cur.resize(i-fail[pn-1]-1); cur.push_back(-k); for(int j=0; j&lt;ls.size(); j++) cur.push_back(ls[j]*k); if(cur.size()&lt;ps[pn].size()) cur.resize(ps[pn].size()); for(int j=0; j&lt;ps[pn].size(); j++) cur[j]+=ps[pn][j]; ps[++pn]=cur; &#125; int len=(int)ps[pn].size(); for(int i=0; i&lt;len; ++i) printf(\"%g%c\",ps[pn][i],\" \\n\"[i==len-1]); &#125; return 0;&#125; 杜教的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b)&#123; ll res=1; a%=mod; assert(b&gt;=0); for(; b; b&gt;&gt;=1) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; &#125; return res;&#125;// headint _,n;namespace linear_seq&#123;const int N=10010;ll res[N],base[N],_c[N],_md[N];vector&lt;int&gt; Md;void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1; i&gt;=k; i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i];&#125;int solve(ll n,VI a,VI b) // a 系数 b 初值 b[n+1]=a[0]*b[n]+...&#123;// printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt; p&gt;=0; p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1; i&gt;=0; i--) res[i+1]=res[i]; res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans;&#125;VI BM(VI s)&#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C;&#125;int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));&#125;&#125;;int main()&#123; ll n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v&#123;1,5,11,36,95,281,781,2245,6336,18061&#125;; printf(\"%d\\n\",linear_seq::gao(v,n-1)); &#125;&#125; 例题：HDU6172，HDU6185 其中6185的打表代码为： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mz[10][15];int x, y, n,cnt;int ok()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) if(mz[i][j]==0) &#123; x=i;y=j; return false; &#125; return 1;&#125;void s()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) printf(\"%d%c\", mz[i][j], \" \\n\"[j==n]);&#125;void dfs(int i, int j)&#123; //s(); if(i&lt;=3&amp;&amp;mz[i+1][j]==0) &#123; mz[i][j]=mz[i+1][j]=1; if(ok()) &#123; mz[i][j]=mz[i+1][j]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i+1][j]=0; &#125; if(j&lt;n&amp;&amp;mz[i][j+1]==0) &#123; mz[i][j]=mz[i][j+1]=1; if(ok()) &#123; mz[i][j]=mz[i][j+1]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i][j+1]=0; &#125;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) &#123; memset(mz, 0, sizeof mz); n = i;cnt=0;dfs(1, 1); cout &lt;&lt; cnt &lt;&lt; ','; &#125;&#125; 快速读入123456789101112131415161718192021222324252627282930313233343536// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000 // fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin);// cout &lt;&lt; 23 &lt;&lt; endl; if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO; 第K短路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std;#define INF 0xffffff#define MAXN 100010struct node&#123; int to; int val; int next;&#125;;struct node2&#123; int to; int g,f; bool operator&lt;(const node2 &amp;r ) const &#123; if(r.f==f) return r.g&lt;g; return r.f&lt;f; &#125; &#125;;node edge[MAXN],edge2[MAXN];int n,m,s,t,k,cnt,cnt2,ans;int dis[1010],visit[1010],head[1010],head2[1010];void init()&#123; memset(head,-1,sizeof(head)); memset(head2,-1,sizeof(head2)); cnt=cnt2=1;&#125;void addedge(int from,int to,int val)&#123; edge[cnt].to=to; edge[cnt].val=val; edge[cnt].next=head[from]; head[from]=cnt++;&#125;void addedge2(int from,int to,int val)&#123; edge2[cnt2].to=to; edge2[cnt2].val=val; edge2[cnt2].next=head2[from]; head2[from]=cnt2++;&#125;bool spfa(int s,int n,int head[],node edge[],int dist[]) &#123; queue&lt;int&gt;Q1; int inq[1010]; for(int i=0;i&lt;=n;i++) &#123; dis[i]=INF; inq[i]=0; &#125; dis[s]=0; Q1.push(s); inq[s]++; while(!Q1.empty()) &#123; int q=Q1.front(); Q1.pop(); inq[q]--; if(inq[q]&gt;n) return false; int k=head[q]; while(k&gt;=0) &#123; if(dist[edge[k].to]&gt;dist[q]+edge[k].val) &#123; dist[edge[k].to]=edge[k].val+dist[q]; if(!inq[edge[k].to]) &#123; inq[edge[k].to]++; Q1.push(edge[k].to); &#125; &#125; k=edge[k].next; &#125; &#125; return true; &#125;int A_star(int s,int t,int n,int k,int head[],node edge[],int dist[]) &#123; node2 e,ne; int cnt=0; priority_queue&lt;node2&gt;Q; if(s==t) k++; if(dis[s]==INF) return -1; e.to=s; e.g=0; e.f=e.g+dis[e.to]; Q.push(e); while(!Q.empty()) &#123; e=Q.top(); Q.pop(); if(e.to==t)//找到一条最短路径 &#123; cnt++; &#125; if(cnt==k)//找到k短路 &#123; return e.g; &#125; for(int i=head[e.to]; i!=-1; i=edge[i].next) &#123; ne.to=edge[i].to; ne.g=e.g+edge[i].val; ne.f=ne.g+dis[ne.to]; Q.push(ne); &#125; &#125; return -1; &#125; int main()&#123; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; init(); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addedge(a,b,c); addedge2(b,a,c); &#125; scanf(\"%d%d%d\",&amp;s,&amp;t,&amp;k); spfa(t,n,head2,edge2,dis); ans=A_star(s,t,n,k,head,edge,dis); printf(\"%d\\n\",ans); &#125; return 0;&#125; 阶乘逆元线性预处理1234fac[0]=fac[1]=1;for(int i=2;i&lt;=MAXN;i++) fac[i]=fac[i-1]*i%mod;inv[MAXN]=quipow(fac[MAXN],mod-2);for(int i=MAXN-1;i&gt;=0;i--)inv[i]=inv[i+1]*(i+1)%mod; 线性求所有数的逆元12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int A[100001];int p;int main()&#123; cin&gt;&gt;p; A[1]=1; for(int i=2;i&lt;=10;i++) &#123; A[i]=(p-(p/i))*A[p%i]%p; printf(\"%d %d %d\\n\",i,A[i],(i*A[i])%p); &#125;&#125; SG函数模板123456789101112131415161718192021//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N];//可以取走的石子个数int sg[N];//0~n的SG函数值int Hash[N]; void getSG(int n)&#123; memset(sg,0,sizeof(sg)); for(int i = 1; i &lt;= n; i++)&#123; memset(Hash,0,sizeof(Hash)); for(int j = 1; f[j] &lt;= i; j++) Hash[sg[i-f[j]]] = 1; for(int j = 0; j &lt;= n; j++)&#123; //求mes&#123;&#125;中未出现的最小的非负整数 if(Hash[j] == 0)&#123; sg[i] = j; break; &#125; &#125; &#125;&#125; 数位dp基本模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef long long ll;int a[20];ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零&#123; //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 &#123; if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ &#125; //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans;&#125;ll solve(ll x)&#123; int pos=0; while(x)//把数位都分解出来 &#123; a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; &#125; return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true); //刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛&#125;int main()&#123; ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri)) &#123; //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(\"%lld\\n\",solve(ri)-solve(le-1)); &#125;&#125; n queen11, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624, 4968057848, 39029188884, 314666222712, 2691008701644, 24233937684440, 227514171973736, 2207893435808352, 22317699616364044, 234907967154122528 最大最小表示模板12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+5;char s[maxn&lt;&lt;1];inline int max(int a,int b)&#123;return a&gt;b?a:b;&#125;inline int min(int a,int b)&#123;return a&lt;b?a:b;&#125;int MINR(char s[],int l)&#123; //s是原串（未加倍过），l是原串长 for(int i=0;i&lt;l;++i)s[l+i]=s[i]; //将s串加倍 s[2*l]=0; int i=0,j=1; //利用i，j指针移动 while(i&lt;l&amp;&amp;j&lt;l)&#123; int k=0; while(s[i+k]==s[j+k]&amp;&amp;k&lt;l)++k; //不断比较直到比较完长度为l的串或两个子串不相等 if(k==l)return min(i,j); //若比较出长度为l则直接返回靠前的那个串的开始位置 if(s[i+k]&gt;s[j+k])i=max(i+k+1,j+1); //i串比j串大，那么i到i+k中的串都比j串大，i可以直接移动到i+k+1位置，而起始位置比j小的肯定都在j移动过程中比较过，所以i可以直接移动到j+1位置，因此取这两值的最大值 else j=max(j+k+1,i+1); //同上 &#125; return min(i,j); //返回位置靠前的下标&#125;int MAXR(char s[],int l)&#123; for(int i=0;i&lt;l;++i)s[l+i]=s[i]; s[2*l]=0; int i=0,j=1; while(i&lt;l&amp;&amp;j&lt;l)&#123; int k=0; while(s[i+k]==s[j+k]&amp;&amp;k&lt;l)++k; if(k==l)return min(i,j); if(s[i+k]&lt;s[j+k])i=max(i+k+1,j+1); else j=max(j+k+1,i+1); &#125; return min(i,j);&#125; 长整型乘法取模123456LL mul(LL a, LL b, LL c)&#123; const double eps = 1e-8; a %= c, b %= c; LL ans = a * b - (LL)((long double)a*b/c+eps)*c; return ans &lt; 0 ? ans+c : ans;&#125; 快速统计1-n范围内的素数个数12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))namespace pcf&#123; long long dp[MAXN][MAXM]; unsigned int ar[(MAX &gt;&gt; 6) + 5] = &#123;0&#125;; int len = 0, primes[MAXP], counter[MAX]; void Sieve()&#123; setbit(ar, 0), setbit(ar, 1); for (int i = 3; (i * i) &lt; MAX; i++, i++)&#123; if (!chkbit(ar, i))&#123; int k = i &lt;&lt; 1; for (int j = (i * i); j &lt; MAX; j += k) setbit(ar, j); &#125; &#125; for (int i = 1; i &lt; MAX; i++)&#123; counter[i] = counter[i - 1]; if (isprime(i)) primes[len++] = i, counter[i]++; &#125; &#125; void init()&#123; Sieve(); for (int n = 0; n &lt; MAXN; n++)&#123; for (int m = 0; m &lt; MAXM; m++)&#123; if (!n) dp[n][m] = m; else dp[n][m] = dp[n - 1][m] - dp[n - 1][m / primes[n - 1]]; &#125; &#125; &#125; long long phi(long long m, int n)&#123; if (n == 0) return m; if (primes[n - 1] &gt;= m) return 1; if (m &lt; MAXM &amp;&amp; n &lt; MAXN) return dp[n][m]; return phi(m, n - 1) - phi(m / primes[n - 1], n - 1); &#125; long long Lehmer(long long m)&#123; if (m &lt; MAX) return counter[m]; long long w, res = 0; int i, a, s, c, x, y; s = sqrt(0.9 + m), y = c = cbrt(0.9 + m); a = counter[y], res = phi(m, a) + a - 1; for (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - 1; return res; &#125;&#125; Lucas 定理用于计算二项式系数C(n, m)被质数 p 除的所得的余数123456789101112LL Cm(LL n,LL m,LL p)&#123; LL a=1,b=1; if(m&gt;n)return 0; while(m)&#123; a=(a*n--)%p; b=(b*m--)%p; &#125; return a*inv(b,p)%p;&#125;LL Lucas(LL n,LL m,LL p)&#123; return m?Cm(n%p,m%p,p)*Lucas(n/p,m/p,p)%p:1;&#125; simpson积分12345678910111213141516double simpson(double L,double R,int n)&#123; const double h=(R-L)/n; double ans=f(L)+f(R); for(int i=1;i&lt;n;i+=2)ans+=4*f(L+i*h); for(int i=2;i&lt;n;i+=2)ans+=2*f(L+i*h); return ans*h/3;&#125;double asr(double L,double R,double eps,double A)&#123; double mid=L+(R-L)/2; double Ls=simpson(L,mid,2),Rs=simpson(mid,R,2); if(fabs(Ls+Rs-A)&lt;=15*eps)return Ls+Rs+(Ls+Rs-A)/15.0; return asr(L,mid,eps/2,Ls)+asr(mid,R,eps/2,Rs);&#125;double asr(double L,double R,double eps)&#123; return asr(L,R,eps,simpson(L,R,2));&#125; 对于指定日期，计算星期几。1234567int whatday(int y,int m,int d)&#123; if(m&lt;3)m+=12,y--; if(y&lt;1752||y==1752&amp;&amp;m&lt;9||y==1752&amp;&amp;m==9&amp;&amp;d&lt;3) return (d+2*m+3*(m+1)/5+y+y/4+5)%7; else return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;&#125;","categories":[],"tags":[]},{"title":"poj2109","slug":"poj2109","date":"2018-10-07T14:53:56.000Z","updated":"2018-10-07T15:05:59.108Z","comments":true,"path":"2018/10/07/poj2109/","link":"","permalink":"http://aoudad.cn/2018/10/07/poj2109/","excerpt":"","text":"题意描述Current work in cryptography involves (among other things) large prime numbers and computing powers of numbers among these primes. Work in this area has resulted in the practical use of results from number theory and other branches of mathematics once considered to be only of theoretical interest.This problem involves the efficient computation of integer roots of numbers.Given an integer n&gt;=1 and an integer p&gt;= 1 you have to write a program that determines the n th positive root of p. In this problem, given such integers n and p, p will always be of the form k to the n th. power, for an integer k (this integer is what your program must find). InputThe input consists of a sequence of integer pairs n and p with each integer on a line by itself. For all such pairs 1&lt;=n&lt;= 200, 1&lt;=p&lt;10^101 and there exists an integer k, $1\\le k\\le10^9$ such that k^n = p. OutputFor each integer pair n and p the value k should be printed, i.e., the number k such that $k^n=p$. Sample Input2 163 277 4357186184021382204544 Sample Output431234 题意：给定两个正整数n和p，求一个整数k使得$k^n=p$，保证这样的整数k一定存在 思路：原本想着二分加高精度或者直接用JAVA二分的，搜了一下直接用double和pow就可以了，因为在这道题中，整数k一定存在且$1\\le k\\le10^9$，因此k的有效位数最大为9，double的精度够用，直接pow没毛病。 代码：1234567891011#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double n, m; while(cin &gt;&gt; n &gt;&gt; m) cout &lt;&lt; (int)(pow(m, 1.0/n)+0.3) &lt;&lt; '\\n';&#125;","categories":[],"tags":[]},{"title":"20180927Training","slug":"20180927Training","date":"2018-09-28T08:36:41.000Z","updated":"2018-09-30T03:30:21.686Z","comments":true,"path":"2018/09/28/20180927Training/","link":"","permalink":"http://aoudad.cn/2018/09/28/20180927Training/","excerpt":"","text":"训练结果训练赛题目： Gym 101572过题数： 3题 ( B, I, J )终榜rank： 97/298 过程：13:45分左右Amori才过来，所以从这时候开始做题，J签到题，B题给Amori解释题意之后，他给了个暴力的做法，然后我上去写写了很久写挂了，换他上去写，同时他把D题题意告诉了我，还提到了可能是道图论题，然而我并没有往那边想2333。然后他码了一会儿就AC了，我没啥想法就码了个D的假做法交上去，果不其然WA10，然后我把G题题意描述了一下，Amori给出了很多方案，比如用set维护等，但是因为没有一个具体的方案所以我都给拒绝了2333，然后我开了I题，发现这题可做，建个有向图然后找最小环即可，然后我就因为字符串读入写挂，建图写自闭了。之后换Amori上去写写写就过了【1.25e8都能过也太cf了】，然后看了一眼E死活看不懂题意就放弃了。 总结：这场主要还是一些很常见的套路，然后大概比较注重思维，理论上能做的题目还是挺多的，但是还是做的不好，大概是周四下午的状态一直都很不好吧，然后我应该调整一下自己的性格，队伍自己不了解/没听懂的东西不应该直接cha掉，也要注重队友的想法，然后青岛赛还有一个月就要开始了，这场有可能是数据结构和数学数论题专场，所以接下来训练会集中在这几个领域吧，然后现在的题目越来越注重思维了，所以原本打算放弃的cf也得拾起来，现在争取每两天刷完一场div2，每三天刷完一场div1吧。 题目（按过题顺序）： Problem J: Judging Moose 题意：签到题 思路：签到题 代码：12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int l, r; cin &gt;&gt; l &gt;&gt; r; if(l==0&amp;&amp;r==0) puts(\"Not a moose\"); else if(l==r) printf(\"Even %d\\n\", l+r); else printf(\"Odd %d\\n\", max(l, r) * 2);&#125; Problem B: Best Relay Team 题意：给两个长度为n的序列（$4\\le n \\le 500$）{$a_1, a_2, \\dots,\\a_n$}与{$b_1, b_2, \\dots,\\b_n$},其中$2\\le a_i, b_i\\le 20$，找出四个不同的下标$i_1, i_2, i_3,i_4$使得$a_{i1}+b_{i2}+b_{i3}+b_{i4}$最小 思路：直接枚举a较小或b较小的那几个就可以了【然而我蜜汁写挂了】 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;struct sol&#123; int id; double val; string name;&#125;;bool cmp(sol a,sol b)&#123; return a.val&lt;b.val;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; sol a[505],b[505]; for(int i=1;i&lt;=n;i++) &#123; a[i].id=b[i].id=i; cin&gt;&gt;a[i].name; b[i].name=a[i].name; cin&gt;&gt;a[i].val; cin&gt;&gt;b[i].val; &#125; sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); map&lt;int,int&gt;mpa; map&lt;int,int&gt;mpb; for(int i=1;i&lt;=n;i++) &#123; mpa[a[i].id]=i; mpb[b[i].id]=i; &#125; double ans=1e9; vector&lt;int&gt;res; for(int i=1;i&lt;=n;i++) &#123; double sum=0; vector&lt;int&gt;v; sum+=a[i].val; v.push_back(a[i].id); while(1) &#123; int cnt=0; for(int j=1;j&lt;=n;j++) &#123; if(b[j].id!=a[i].id) &#123; sum+=b[j].val; cnt++; v.push_back(b[j].id); &#125; if(cnt==3) break; &#125; if(cnt==3) break; &#125; if(ans&gt;sum) &#123; ans=sum; res=v; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;a[mpa[res[0]]].name&lt;&lt;endl; for(int i=1;i&lt;4;i++) cout&lt;&lt;b[mpb[res[i]]].name&lt;&lt;endl; &#125;&#125; Problem I: Import Spaghetti 题意：给一个有向图，求最小环 思路：根据题意建一个有向图，然后跑floyd求最小环，然后对最小环bfs求出路径【然后我建图写自闭了】 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e2+5;int G[maxn][maxn];const int INF = 1e7;int n;vector&lt;int&gt;g[maxn];map&lt;int,string&gt; mp2;void floyd()&#123; int i,j,k; for(k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(G[i][j]&gt;G[i][k]+G[k][j]) G[i][j]=G[i][k]+G[k][j];&#125;int mark;int fa[maxn];void dfs(int cur)&#123; if(cur==mark) &#123; cout&lt;&lt;mp2[cur]&lt;&lt;\" \"; return; &#125; dfs(fa[cur]); cout&lt;&lt;mp2[cur]&lt;&lt;\" \";&#125;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) G[i][j]=INF; string s; map&lt;string, int&gt; mp; mp2.clear(); for(int i=0;i&lt;n;++i) &#123; cin &gt;&gt; s; mp[s] = i; mp2[i]=s; &#125; int k ; for(int i=0;i&lt;n;++i) &#123; cin &gt;&gt; s &gt;&gt; k; getchar(); for(int p=0;p&lt;k;++p)&#123; getline(cin, s); int l = s.length(); string tmp=\"\"; for(int j=7;j&lt;l;++j) &#123; if(s[j]==' ') continue; if(s[j]==',') &#123; G[i][mp[tmp]] = 1; g[i].push_back(mp[tmp]); tmp = \"\"; &#125; else tmp = tmp + s[j]; &#125; G[i][mp[tmp]] = 1; g[i].push_back(mp[tmp]); &#125; &#125; floyd(); int ans=INF; mark=-1; for(int i=0;i&lt;n;i++) &#123; if(G[i][i]&lt;ans) &#123; ans=G[i][i]; mark=i; &#125; &#125; if(ans==INF) &#123; puts(\"SHIP IT\"); return 0; &#125; queue&lt;int&gt;q; q.push(mark); memset(fa,-1,sizeof fa); while(!q.empty()) &#123; int cur=q.front(); q.pop(); if(cur==mark&amp;&amp;fa[cur]!=-1) break; for(int i=0;i&lt;g[cur].size();i++) &#123; int p=g[cur][i]; if(fa[p]==-1) &#123; fa[p]=cur; q.push(p); &#125; &#125; &#125; dfs(fa[mark]);&#125; Problem G: Galactic Collegiate Programming Contest 题意：有n支队伍，m个事件，每个事件包括p和t，表示p队在时间t做出了一道题，相同题数下时间t总和小的排名靠前，相同的并列，求每一个事件之后1队的排名。 思路：【比赛中觉得是平衡树的裸题，但是太菜了不会，还cha掉了amori一些有可能做出来的思路2333】其实可以直接用multiset维护当前排名在1队之前的队伍数量，每个事件如果是1队，则直接修改1队的信息就可以，否则如果在这之前队伍p排名在1之前，则先拿出来修改，如果在p之后，则直接修改，之后都扔进multiset里，从最后开始如果比1队排名靠后就删掉。最后multiset的大小再加一就是1队的rank，需要注意的是multiset的删除要用**.erase(迭代器)**，不然会把所有的值都删掉的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;struct Node&#123; int p, t; bool operator&lt;(const Node&amp; a)const &#123; if(p!=a.p) return p &gt; a.p; return t &lt; a.t; &#125;&#125; ans[maxn];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; multiset&lt;Node&gt; res; for(int i=0; i&lt;m; ++i) &#123; int p, t; cin &gt;&gt; p &gt;&gt; t; if(p==1) &#123; ans[1].p ++; ans[1].t += t; &#125; else &#123; if(ans[p]&lt;ans[1]) res.erase(res.find(ans[p])); ans[p].p ++; ans[p].t += t; res.insert(ans[p]); &#125; while(!res.empty()&amp;&amp; !( *--res.end()&lt;ans[1] ) ) res.erase(--res.end()); cout &lt;&lt;res.size() + 1 &lt;&lt; endl; &#125;&#125; Problem D: Distinctive Character 题意：给n个k长度的01串，定义两个01串之间的距离为两个串位与位之间字符相同的个数，求出使到这n个串的最大距离最小的01串 思路：比赛场上想到了可能和最短路有关，但是没有深入去思考。可以定义$f(S)$表示01串S到给定串的最大距离，则有$f(a_i)$=k，由他们改变其中其中一个位的得到的串的f函数值应该是k（该串已经在$a_i$中）或者k-1，用队列维护一下。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int f[1&lt;&lt;21], vis[1&lt;&lt;21];int main()&#123; int n, k;queue&lt;int&gt; q; cin &gt;&gt; n &gt;&gt; k; for(int i=0;i&lt;n;++i) &#123; string s;int tmp=0; cin &gt;&gt; s; for(int j=0;j&lt;k;++j) tmp = (tmp&lt;&lt;1)+s[j]-'0'; f[tmp] = k; vis[tmp] = 1; q.push(tmp); &#125; int x, y; while(!q.empty()) &#123; x = q.front();q.pop(); for(int j=0;j&lt;k;++j) &#123; y = x^(1&lt;&lt;j); if(!vis[y]) &#123; vis[y]=1; f[y] = f[x]-1; q.push(y); &#125; &#125; &#125; for(int i=k-1;i&gt;=0;--i) cout &lt;&lt; ((x&gt;&gt;i)&amp;1);// cout &lt;&lt; endl;&#125;","categories":[],"tags":[]},{"title":"2018ACM-ICPC青岛赛区网络赛A","slug":"2018ACM-ICPC青岛赛区网络赛A","date":"2018-09-19T16:48:43.000Z","updated":"2018-09-19T17:21:02.393Z","comments":true,"path":"2018/09/20/2018ACM-ICPC青岛赛区网络赛A/","link":"","permalink":"http://aoudad.cn/2018/09/20/2018ACM-ICPC青岛赛区网络赛A/","excerpt":"","text":"题意描述DreamGrid is playing the music game Live Love. He has just finished a song consisting of $n$ notes and got a result sequence $A_1,A_2,\\dots,A_n$ ( $A_i \\in$ {PERFECT, NON-PERFECT}). The score of the song is equal to the $\\textit{max-combo}$ of the result sequence, which is defined as the maximum number of continuous PERFECTs in the sequence. Formally speaking, $\\text{max-combo}(A) = \\max\\{ k | k$ is an integer and there exists an integer $i$ ($1 \\le i \\le n-k+1$) such that $A_i = A_{i+1} = A_{i+2} = \\dots = A_{i+k-1} = PERFECT\\}$. For completeness, we define max($\\emptyset$) = 0. As DreamGrid is forgetful, he forgets the result sequence immediately after finishing the song. All he knows is the sequence length $n$ and the total number of PERFECTs in the sequence, indicated by $m$. Any possible score $s$ he may get must satisfy that there exists a sequence $A’$ of length $n$ containing exactly $m$ PERFECTs and $(n-m)$ NON-PERFECTs and \\text{max-combo}(A’) = s. Now he needs your help to find the maximum and minimum $s$ among all possible scores. InputThere are multiple test cases. The first line of the input contains an integer $T$($1 \\le T \\le 100$), indicating the number of test cases. For each test case: The only line contains two integers $n$ and $m$ ($1 \\le n \\le 10^3$, $0\\le m \\le 10^3$, $m\\le n$), indicating the sequence length and the number of PERFECTs DreamGrid gets. OutputFor each test case output one line containing two integers $s_{max}$ and $s_{min}$ , indicating the maximum and minimum possible score. Sample Input55 4100 50252 523 010 10 Sample Output4 250 152 10 010 10 题意：给一个含有m个1的01序列，求该序列连续的1的最大长度的最大值和最小值 思路：m即为最大值，0尽量均分1时得到最小值，除一下上取整即可，0特殊处理一下 代码：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std; int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; LL n, m; cin &gt;&gt; n &gt;&gt; m; if (m == 0) cout &lt;&lt; \"0 0\" &lt;&lt; endl; else cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (m - 1) / (n - m + 1) +1 &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"2018ACM-ICPC青岛赛区网络赛","slug":"2018ACM-ICPC青岛赛区网络赛","permalink":"http://aoudad.cn/tags/2018ACM-ICPC青岛赛区网络赛/"}]},{"title":"2018ACM-ICPC青岛赛区网络赛K","slug":"2018ACM-ICPC青岛赛区网络赛K","date":"2018-09-19T09:34:03.000Z","updated":"2018-09-19T09:37:57.242Z","comments":true,"path":"2018/09/19/2018ACM-ICPC青岛赛区网络赛K/","link":"","permalink":"http://aoudad.cn/2018/09/19/2018ACM-ICPC青岛赛区网络赛K/","excerpt":"","text":"题目描述：BaoBao has a sequence $a_1,a_2,\\dots,a_n$. He would like to find a subset $S$ of $\\{1, 2, \\dots, n\\}$ such that $\\forall i, j \\in S$, $a_i \\oplus a_j &lt; \\min(a_i,a_j)$ and $|S|$ is maximum, where means bitwise exclusive or. InputThere are multiple test cases. The first line of input contains an integer $T$ , indicating the number of test cases. For each test case:The first line contains an integer $n$ ($1\\le n \\le 10^5$), indicating the length of the sequence.The second line contains n integers: $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), indicating the sequence.It is guaranteed that the sum of $n$ in all cases does not exceed $10^5$. OutputFor each test case, output an integer denoting the maximum size of $S$ . 题意给n个数，从中选出最大的子集合，使得该集合中的数两两之间的异或值小于他们各自本身，输出最大的子集合大小。 思路：当两个数的最大二进制位不同时，两者的异或值肯定大于两者中的较小值，故按照二进制位最高位的位置来分组，输出最大那一组的大小即可。 代码：1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 32;int ans[maxn];int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; int n, x; scanf(\"%d\", &amp;n); memset(ans, 0, sizeof(ans)); while(n--) &#123; scanf(\"%d\", &amp;x); int t = 0; while(x) &#123; x&gt;&gt;=1; ++t; &#125; ++ans[t]; &#125; printf(\"%d\\n\", *max_element(ans, ans+maxn)); &#125;&#125;","categories":[],"tags":[{"name":"2018ACM-ICPC青岛赛区网络赛","slug":"2018ACM-ICPC青岛赛区网络赛","permalink":"http://aoudad.cn/tags/2018ACM-ICPC青岛赛区网络赛/"}]}]}