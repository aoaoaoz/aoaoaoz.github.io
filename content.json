{"meta":{"title":"嗷嗷嗷's Blog","subtitle":"aoaoao's Blog","description":"算法竞赛, 数学, 怪物猎人(?)","author":"嗷嗷嗷","url":"http://aoudad.cn"},"pages":[{"title":"categories","date":"2019-02-14T14:25:08.000Z","updated":"2019-02-14T14:34:56.040Z","comments":true,"path":"categories/index.html","permalink":"http://aoudad.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-14T14:25:47.000Z","updated":"2019-02-14T14:33:59.142Z","comments":true,"path":"tags/index.html","permalink":"http://aoudad.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"组队赛 Day1 E CC的简单多项式","slug":"组队赛-Day1-E-CC的简单多项式","date":"2019-02-24T12:18:16.000Z","updated":"2019-02-24T13:03:36.860Z","comments":true,"path":"2019/02/24/组队赛-Day1-E-CC的简单多项式/","link":"","permalink":"http://aoudad.cn/2019/02/24/组队赛-Day1-E-CC的简单多项式/","excerpt":"","text":"题意链接https://scut.online/contest/41/E 题意：求那个奇怪的多项式卷积在 $x=1$ 时候的取值 思路：需要的技能点：积性函数前缀和，杜教筛实际上就是求两个多项式的系数两两之间的gcd之和，也就是求 S = \\Sigma_{i=1}^{n}\\Sigma_{j=1}^ngcd(i^2,(n-j)^2)其中 gcd(i^2,(n-j)^2)=gcd(i,n-j)^2换个枚举顺序的话就是$gcd(i,j)^2$，所以就是求 \\Sigma_{i=1}^{n}\\Sigma_{j=1}^ngcd(i,j)^2改为枚举gcd得到 \\Sigma_{d=1}^nd^2\\ \\Sigma_{i=1}^{n/d}\\ \\Sigma_{j=1}^{n/d}[gcd(i,j)=1]用莫比乌斯函数替换 \\Sigma_{d=1}^nd^2\\ \\Sigma_{i=1}^{n/d}\\ \\Sigma_{j=1}^{n/d}\\ \\Sigma_{D|(i,j)} \\mu(D)枚举D得到 \\Sigma_{d=1}^nd^2\\ \\Sigma_{D=1}^{n/d}\\mu(D)\\lfloor \\frac{n}{Dd}\\rfloor^2设$T=Dd$，得到 \\Sigma_{T=1}^{n}\\Sigma_{d|T}\\ d^2\\mu(T/d)\\ \\lfloor \\frac{n}{Dd}\\rfloor^2中间那个是$id^2$和$\\mu$的迪利克雷卷积 \\Sigma_{T=1}^{n}\\ id^2*\\mu\\ \\lfloor \\frac{n}{Dd}\\rfloor^2假设已经知道中间那个卷积的前缀和，那我们就可以 $O(n^{1/2})$求出答案。 其中$id$，$\\mu$都是积性函数，所以中间那个是积性函数，所以可以用线性筛筛出前$1e7$的答案，后面的套用一下杜教筛的公式： g(1)S(n)=\\Sigma f*g-\\Sigma_{i=2}^{n}g(i)S(\\lfloor \\frac{n}{i} \\rfloor)取$g=I_1$就可以了好像，这个时候 f*g(n)=\\Sigma_{d|n}d^2*\\mu*I_1f*g(n)=\\Sigma_{d|n}d^2*e=id^2就没了……注意取模…… 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(), x.end()#define SZ(x) (int)(x.size())#define mem(x, y) memset(x, y, sizeof(x))#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 6e6+8;const ll mod = 998244353;int isp[maxn+6], p[maxn+5], f[maxn+5], low[maxn+5];void init()&#123; f[1]=low[1]=1;int tot=0; for(int i=2;i&lt;=maxn;++i) &#123; if(!isp[i]) &#123;p[tot++] = i; f[i] = (1LL*i*i-1)%mod; low[i]=i;&#125; for(int j=0;j&lt;tot&amp;&amp;1LL*i*p[j]&lt;=maxn;++j) &#123; int tmp = p[j]*i; isp[tmp] = 1; if(i%p[j]==0) &#123; if(low[i]==i) f[tmp] = 1LL*f[i]*p[j]%mod*p[j]%mod, low[tmp]=low[i]*p[j]; else f[tmp] = 1LL*f[i/low[i]]*f[low[i]*p[j]]%mod, low[tmp] = low[i]*p[j]; break; &#125; f[tmp] = 1LL*f[i] * f[p[j]]%mod; low[tmp] = p[j]; &#125; &#125; for(int i=2;i&lt;=maxn;++i) f[i]+=f[i-1], f[i]%=mod;&#125;const ll inv = ((mod+1)/2)*((mod+1)/3)%mod;#include&lt;ext/pb_ds/assoc_container.hpp&gt;#include&lt;ext/pb_ds/hash_policy.hpp&gt;using namespace __gnu_pbds;cc_hash_table&lt;ll, ll&gt; S1;ll sum(ll n)&#123;n%=mod;return n*(n+1)%mod*(2*n+1)%mod*inv%mod;&#125;ll M1(ll n)&#123; if(n&lt;=maxn) return f[n]; if(S1[n]) return S1[n]; ll res = sum(n); for(ll L=2, R;L&lt;=n;L=R+1) &#123; R = n/(n/L); res -= (R-L+1)*M1(n/L)%mod; res %= mod; &#125; return S1[n] = (res+mod)%mod;&#125;int main()&#123;#ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);#endif // aoaoao init(); int t;scanf(\"%d\", &amp;t); while(t--) &#123; ll res = 0; ll n;scanf(\"%lld\", &amp;n); for(ll L=1, R;L&lt;=n;L=R+1) &#123; R = n/(n/L); ll tmp = n/L; res = (res+(M1(R)-M1(L-1))%mod*tmp%mod*tmp%mod)%mod; &#125; cout &lt;&lt; (res+mod)%mod &lt;&lt; endl; &#125;&#125;","categories":[{"name":"组队赛","slug":"组队赛","permalink":"http://aoudad.cn/categories/组队赛/"}],"tags":[{"name":"杜教筛","slug":"杜教筛","permalink":"http://aoudad.cn/tags/杜教筛/"}]},{"title":"Camp Day8 G 穗乃果的考试","slug":"Camp-Day8-G-穗乃果的考试","date":"2019-02-17T16:08:33.000Z","updated":"2019-02-17T16:17:05.092Z","comments":true,"path":"2019/02/18/Camp-Day8-G-穗乃果的考试/","link":"","permalink":"http://aoudad.cn/2019/02/18/Camp-Day8-G-穗乃果的考试/","excerpt":"","text":"题意描述为了能在新学期获得$LoveLive!$ 的出场资格，$\\mu′s$ 的成员们必须所有考试都要及格才能继续活动。但高坂穗乃果的数学不太好，需要大家的帮助才能及格。有一天，穗乃果碰到了一个这样的数学题，她不太会做，但是如果说自己不会做很可能会被希给予严厉的惩罚，所以她在 $\\mu′s$ 粉丝群中找到了学霸的你，希望能请你帮帮她。题目是这样的：给定一个 $n\\times m$ 的 $01$ 矩阵，记 $f_i$​ 为恰有 $i$ 个 $1$ 的子矩阵的个数，求：$\\sum_{i=0}^{nm}i^2 \\cdot f_i$输出答案对 $998244353$ 取模的结果。 Input第一行两个正整数 $n,m$($1\\le n,m \\le 2000$)，表示矩阵的大小。接下来 $n$ 行，每行$m$个为$0$或为$1$的字符。第$i$行的第$j$个字符代表矩阵的第$i$行的第$j$个元素的值。 Output仅一行一个非负整数表示答案对 998244353 取模的结果。 Sample Input3 3010111010 Sample Output176 思路：所求的东西就是对每个子矩阵，设该矩阵的权值为这个矩阵内的$1$的个数的平方，设$sum_{ij}$表示二位前缀和，那么答案就是\\Sigma_{i=1}^n\\ \\Sigma_{j=1}^m\\ \\Sigma_{k=0}^{i-1}\\ \\Sigma_{t=0}^{j-1}(sum_{ij}+sum_{kt}-sum_{it}-sum_{kj})^2拆出来分别算一下贡献就好了，复杂度$O(nm)$。感觉有点神奇的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(), x.end()#define SZ(x) (int)(x.size())#define mem(x, y) memset(x, y, sizeof(x))#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e3+7;char s[maxn];const ll mod = 998244353;ll a[maxn][maxn], sum[maxn][maxn];ll g(int x, int X, int y, int Y)&#123; if(X&lt;=0||y&lt;=0) return 0; return (sum[X][Y]-sum[X][y-1]-sum[x-1][Y]+sum[x-1][y-1]+mod+mod)%mod;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=n;++i) &#123; scanf(\"%s\", s+1); for(int j=1;j&lt;=m;++j) a[i][j] = s[j]-'0'; &#125; rep(i, 1, n+1) rep(j, 1, m+1)a[i][j]+=a[i][j-1], a[i][j]%=mod; rep(i, 1, n+1) rep(j, 1, m+1)a[i][j]+=a[i-1][j], a[i][j]%=mod; rep(i, 1, n+1) rep(j, 1, m+1)sum[i][j]=a[i][j]; rep(i, 1, n+1) rep(j, 1, m+1)sum[i][j]+=sum[i][j-1], sum[i][j]%=mod; rep(i, 1, n+1) rep(j, 1, m+1)sum[i][j]+=sum[i-1][j], sum[i][j]%=mod; ll res = 0; rep(i, 1, n+1) rep(j, 1, m+1) &#123; ll s = a[i][j]*a[i][j]%mod; res = (res+s*i%mod*j%mod)%mod; res = (res+s*i%mod*(m-j)%mod)%mod; res = (res+s*(n-i)%mod*(m-j)%mod)%mod; res = (res+s*(n-i)%mod*j%mod)%mod; &#125; rep(i, 1, n+1) rep(j, 1, m+1) res = (res+2*a[i][j]*g(1, i-1, 1, j-1))%mod; rep(i, 1, n+1) rep(j, 0, m) res = (res+2*a[i][j]*g(1, i-1, j+1, m))%mod; ll tmp = 0; rep(i, 1, n+1) rep(j, 1, m+1) &#123; tmp = (tmp+a[i][j]*i*2%mod*g(i, i, 1, j-1)%mod)%mod; tmp = (tmp+a[i][j]*j*2%mod*g(1, i-1, j, j)%mod)%mod; tmp = (tmp+2*(m-j+1)*a[i][j-1]%mod*g(1, i-1, j-1, j-1)%mod)%mod; tmp = (tmp+2*(n-i+1)*a[i-1][j]%mod*g(i-1, i-1, 1, j-1)%mod)%mod; &#125; cout &lt;&lt; (res-tmp+mod)%mod &lt;&lt; endl;&#125;","categories":[{"name":"Camp day8","slug":"Camp-day8","permalink":"http://aoudad.cn/categories/Camp-day8/"}],"tags":[{"name":"计数","slug":"计数","permalink":"http://aoudad.cn/tags/计数/"},{"name":"线性独立","slug":"线性独立","permalink":"http://aoudad.cn/tags/线性独立/"}]},{"title":"Camp Day5 I Sorting","slug":"Camp-Day5-I-Sorting","date":"2019-02-17T13:49:21.000Z","updated":"2019-02-17T13:59:06.647Z","comments":true,"path":"2019/02/17/Camp-Day5-I-Sorting/","link":"","permalink":"http://aoudad.cn/2019/02/17/Camp-Day5-I-Sorting/","excerpt":"","text":"题意描述你有一个数列$a_1, a_2, \\dots, a_$​，你要模拟一个类似于快速排序的过程。有一个固定的数字$x$。你要支持三种操作： 询问区间$[l, r]$之间的元素的和，也就是$\\sum_{i=l}^r a_i$​。 对区间$[l,r]$进行操作，也就是说你把区间中所有的数字拿出来，然后把小于等于$x$的数字按顺序放在左边，把大于$x$的数字按顺序放在右边，把这些数字接起来，放回到数列中。比如说$x=3$，你的区间里的数字是$1,5,3,2,4$，那么操作完之后区间里面的数字变为$1,3,2,5,4$。 对区间$[l,r]$进行操作，也就是说你把区间中所有的数字拿出来，然后把大于$x$的数字按顺序放在左边，把小于等于$x$的数字按顺序放在右边，把这些数字接起来，放回到数列中。 Input第一行三个整数$n, q, x$ ( $1\\leq n, q \\leq 2*10^5, 0\\leq x\\leq 10^9)$表示元素的个数和询问的个数。接下来一行$n$个整数$a_1, a_2, \\dots, a_n(1\\leq a_i\\leq 10^9)$。接下来$q$行，每行三个正整数$p, l, r (1\\leq p\\leq 3), 1\\leq l\\leq r\\leq n$表示操作种类和区间。 Output对于每个第一种操作，输出一行，表示答案。 Sample Input5 9 31 5 3 2 41 1 52 1 51 1 11 2 21 3 31 4 41 5 53 3 51 1 4 Sample Output151325413 思路：进行操作二的时候，小于等于$x$的数和大于$x$的数各自之间的相对顺序是不变的。分别用$0$和$1$标记$a[i]$，$0$表示这个数小于等于$x$，那么操作二就是将当前区间中的所有$0$移到左半部分，$1$移到右半部分，操作三相反，询问$1$只需要知道在当前区间内的是哪几个$0$哪几个$1$就行了，所以用个线段树维护一下区间和就可以了。另外分别提前处理一下前缀和，复杂度$O(q\\log n)$。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(), x.end()#define SZ(x) (int)(x.size())#define mem(x, y) memset(x, y, sizeof(x))#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;int sum[maxn&lt;&lt;2], st[maxn&lt;&lt;2];void pushup(int rt)&#123;sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void pushdown(int rt, int len)&#123; if(st[rt]==-1)return; st[rt&lt;&lt;1]=st[rt&lt;&lt;1|1]=st[rt]; sum[rt&lt;&lt;1] = st[rt]*(len-len/2); sum[rt&lt;&lt;1|1] = st[rt] * (len/2); st[rt]=-1;&#125;int a[maxn], x;void build(int l, int r, int rt)&#123; st[rt]=-1; if(l==r)&#123;sum[rt]=a[l]&gt;x;return ;&#125; int mid = (l+r)&gt;&gt;1; build(lson);build(rson); pushup(rt);&#125;int query(int L, int R, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;return sum[rt];&#125; int mid = (l+r)&gt;&gt;1, res=0; pushdown(rt, r-l+1); if(L&lt;=mid) res = query(L, R, lson); if(mid&lt;R) res+=query(L, R, rson); return res;&#125;void update(int L, int R, int x, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;st[rt]=x;sum[rt]=x*(r-l+1);return ;&#125; int mid = (l+r)&gt;&gt;1;pushdown(rt, r-l+1); if(L&lt;=mid) update(L, R, x, lson); if(mid&lt;R) update(L, R, x, rson); pushup(rt);&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;vector&lt;ll&gt; res[2];res[0].eb(0), res[1].eb(0); for(int i=1;i&lt;=n;++i)&#123;scanf(\"%d\", a+i);res[a[i]&gt;x].eb(a[i]);&#125; for(int i=1;i&lt;res[0].size();++i) res[0][i]+=res[0][i-1]; for(int i=1;i&lt;res[1].size();++i) res[1][i]+=res[1][i-1]; build(1, n, 1); for(int i=0;i&lt;m;++i) &#123; int opt, x, y; scanf(\"%d%d%d\", &amp;opt, &amp;x, &amp;y); if(opt==1) &#123; int pre = 0, now = 0; if(x&gt;1) pre = query(1, x-1, 1, n, 1); now = query(x, y, 1, n, 1); ll ans = 0; ans += res[1][pre+now] - res[1][pre]; ans += res[0][y-pre-now] - res[0][x-1-pre]; printf(\"%lld\\n\", ans); &#125; else if(opt==2) &#123; int one = query(x, y, 1, n, 1), zero = y-x+1-one; update(x, x+zero-1, 0, 1, n, 1); update(x+zero, y, 1, 1, n, 1); &#125; else if(opt==3) &#123; int one = query(x, y, 1, n, 1), zero = y-x+1-one; update(x, x+one-1, 1, 1, n, 1); update(x+one, y, 0, 1, n, 1); &#125; &#125;&#125;","categories":[{"name":"Camp day5","slug":"Camp-day5","permalink":"http://aoudad.cn/categories/Camp-day5/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"}]},{"title":"Camp Day5 E Fast Kronecker Transform","slug":"Camp-Day5-E-Fast-Kronecker-Transform","date":"2019-02-17T13:08:27.000Z","updated":"2019-02-17T13:14:24.821Z","comments":true,"path":"2019/02/17/Camp-Day5-E-Fast-Kronecker-Transform/","link":"","permalink":"http://aoudad.cn/2019/02/17/Camp-Day5-E-Fast-Kronecker-Transform/","excerpt":"","text":"题意描述给你两个数列$a_0, a_1, \\dots, a_n$​，$b_0, b_1, \\dots, b_m$。求一个数列$c_k$ ($0\\leq k\\leq n+m$)，其中$c_k=(\\sum_{i+j=k} ij\\delta_{a_i, b_j}) \\bmod 998244353$，其中$\\delta_{a,b}$​为$Kronecker$符号，当$a=b$是$\\delta_{a,b}=1$，否则为$0$。 Input第一行输入两个整数$n,m$ ($1\\leq n,m\\leq 10^5$)。接下来一行$n+1$个整数$a_0, a_1, \\dots, a_n$​，接下来一行$m+1$个整数$b_0, b_1, \\dots, b_m$ ($1\\leq a_i,b_i\\leq 10^9$)。 Output输出$n+m+1$个整数，表示$c_0, c_1, \\dots, c_{n+m}$。 Sample Input—-5 51 2 1 3 2 23 1 2 3 1 2 Sample Output0 0 0 4 0 0 30 10 0 20 25 思路：枚举每个数，拎出来做卷积，当该数的出现次数较少时（我是上面的数量乘下面的数量小于1e7时），直接暴力比较快，不然就做 $NTT$ 。注意爆 $int$ 和离散化…… 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(), x.end()#define SZ(x) (int)(x.size())#define mem(x, y) memset(x, y, sizeof(x))#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;const ll mod = 998244353;const ll g = 3;int rev[maxn];ll qp(ll b, ll n)&#123;ll r=1;for(;n;b=b*b%mod,n&gt;&gt;=1)if(n&amp;1)r=r*b%mod;return r;&#125;void NTT(ll x[], int len, int on)&#123; int bit=suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = ((rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1))); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(x[i], x[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = qp(g, (mod-1)/h); if(on==-1) wn=qp(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = x[k], t = w*x[k+h/2]%mod; x[k] = (u+t)%mod; x[k+h/2] = (u-t+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=qp(len, mod-2);for(int i=0;i&lt;len;++i)x[i]=x[i]*t%mod;&#125;&#125;void calc(ll x[], ll y[], int len)&#123; NTT(x, len, 1);NTT(y, len, 1); for(int i=0;i&lt;len;++i) x[i]=x[i]*y[i]%mod; NTT(x, len, -1);&#125;ll x[maxn], y[maxn];int head[2][maxn], nxt[2][maxn], sz[2][maxn];ll resx[maxn], resy[maxn];ll res[maxn];const ll LIMIT = 1e7;int main()&#123; int n, m;cin &gt;&gt; n &gt;&gt; m; mem(head, -1);mem(nxt, -1);vector&lt;ll&gt; MP; for(int i=0;i&lt;=n;++i) scanf(\"%lld\", x+i), MP.eb(x[i]); for(int i=0;i&lt;=m;++i) scanf(\"%lld\", y+i), MP.eb(y[i]); sort(all(MP));MP.erase(unique(all(MP)), MP.end()); for(int i=0;i&lt;=n;++i) &#123; x[i] = lower_bound(all(MP), x[i])-MP.begin(); nxt[0][i] = head[0][x[i]]; head[0][x[i]] = i; ++sz[0][x[i]]; &#125; for(int i=0;i&lt;=m;++i) &#123; y[i] = lower_bound(all(MP), y[i])-MP.begin(); nxt[1][i] = head[1][y[i]]; head[1][y[i]] = i; ++sz[1][y[i]]; &#125; int len=1;while(len&lt;n+1+m+1)len&lt;&lt;=1; for(int i=0;i&lt;SZ(MP);++i) &#123; if(sz[0][i]*1LL*sz[1][i]&lt;=LIMIT) &#123; for(int x=head[0][i];x!=-1;x=nxt[0][x]) for(int y=head[1][i];y!=-1;y=nxt[1][y]) &#123; res[x+y] += 1LL*x*y%mod; res[x+y] %= mod; &#125; &#125; else &#123; for(int x=head[0][i];x!=-1;x=nxt[0][x]) resx[x] = x; for(int y=head[1][i];y!=-1;y=nxt[1][y]) resy[y] = y; calc(resx, resy, len); for(int i=0;i&lt;len;++i) res[i]=(res[i]+resx[i])%mod; mem(resx,0);mem(resy,0); &#125; &#125; for(int i=0;i&lt;=n+m;++i) printf(\"%lld%c\", res[i], \" \\n\"[i==n+m]);&#125;","categories":[{"name":"Camp day5","slug":"Camp-day5","permalink":"http://aoudad.cn/categories/Camp-day5/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"http://aoudad.cn/tags/NTT/"}]},{"title":"Camp Day1 G 双重矩阵","slug":"Camp-Day1-G-双重矩阵","date":"2019-02-16T11:28:01.000Z","updated":"2019-02-16T11:40:40.210Z","comments":true,"path":"2019/02/16/Camp-Day1-G-双重矩阵/","link":"","permalink":"http://aoudad.cn/2019/02/16/Camp-Day1-G-双重矩阵/","excerpt":"","text":"题意描述$wls$有一个 $n$ 行 $m$ 列的矩阵，矩阵中的每个元素都是一个整数。$wls$ 以这个矩阵为基础，构造了一个更大的 $x$ 行 $y$ 列的矩阵，大矩阵中的每个元素都是这个 $n$ 行 $m$ 列的小矩阵。现在 $wls$想知道，在这个大矩阵中，最大公约数不为 $1$ 的最大的子矩阵包含多少个元素？ Input第一行四个整数 $n$，$m$，$x$，$y$。接下来 $n$ 行，每行 $m$ 个整数表示矩阵。$1 \\leq n, m \\leq 100$$1 \\leq x, y \\leq 1000000$$1 \\leq 矩阵元素 \\leq 1000000000$ Output一行一个整数表示答案。 Sample Input3 3 2 22 3 22 3 22 3 2 Sample Output12 思路：假设$xy$都大于等于$2$，将矩阵横宽翻两倍，结果就是那么就只有四种情况，全都可以，一整行，一整列，还有一个块。所以现在问题就是怎么找一个矩阵里面$gcd$大于$1$的最大子矩阵。先枚举上下界，取$gcd$压成一行，$st$表处理一下，枚举左边界二分右边界，复杂度$O(n^3logn)。$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const int maxn = 405;int mm[maxn], a[maxn][maxn];void init(int n, int m)&#123; mm[0]=-1; for(int i=1;i&lt;maxn;++i) mm[i] = mm[i-1]+((i&amp;(i-1))==0);&#125;int st[maxn][20], dd[maxn];int binchk(int i, int x)&#123; int t = mm[x-i+1]; return __gcd(st[i][t], st[x-(1&lt;&lt;t)+1][t]) &gt; 1;&#125;int chk(int m)&#123; for(int i=1;i&lt;=m;++i) st[i][0] = dd[i]; for(int k=1;k&lt;=mm[m];++k) for(int i=1;i&lt;=m-(1&lt;&lt;k)+1;++i) st[i][k] = __gcd(st[i][k-1], st[i+(1&lt;&lt;(k-1))][k-1]); int tmp = 0; for(int i=1;i&lt;=m;++i) &#123; int L = i, R = m, mid, ans=i-1; while(L&lt;=R) &#123; mid = (L+R)&gt;&gt;1; if(binchk(i, mid)) L = mid + 1, ans = mid; else R = mid - 1;// error(i, mid); &#125; tmp = max(tmp, ans-i+1); &#125; return tmp;&#125;int main()&#123; int n, m, x, y; scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;x, &amp;y); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)&#123; scanf(\"%d\", &amp;a[i][j]); a[i+n][j]=a[i][j+m]=a[i+n][j+m]=a[i][j]; &#125; int tn = n, tm = m; n*=2;m*=2; if(x==1)n/=2;if(y==1)m/=2; init(n, m); ll ans = 0, Lflag=0, Rflag=0, area = 0; for(int i=1;i&lt;=n;++i) &#123; for(int j=i;j&lt;=n;++j) &#123; if(j==i) for(int k=1;k&lt;=m;++k) dd[k] = a[i][k]; else for(int k=1;k&lt;=m;++k) dd[k] = __gcd(dd[k], a[j][k]); ll chkm = chk(m); area = max(area, chkm*(j-i+1)); if(j-i+1==n) Lflag = max(Lflag, (ll)chkm); if(chkm==m) Rflag = max(Rflag, (ll)j-i+1);// error(ans, area, chkm, i, j); &#125; &#125;// error(Rflag, Lflag, area); if(Rflag*Lflag==n*m) area = 1LL*tn*tm*x*y; if(Rflag) area = max(area, Rflag*tm*y); if(Lflag) area = max(area, Lflag*tn*x); printf(\"%lld\\n\", area);&#125;/*2 2 3 42 22 33 3 2 22 3 25 7 92 11 2*/","categories":[{"name":"Camp day1","slug":"Camp-day1","permalink":"http://aoudad.cn/categories/Camp-day1/"}],"tags":[{"name":"RMQ","slug":"RMQ","permalink":"http://aoudad.cn/tags/RMQ/"},{"name":"二分","slug":"二分","permalink":"http://aoudad.cn/tags/二分/"}]},{"title":"Camp Day3 B 集合","slug":"Camp-Day3-B-集合","date":"2019-02-16T11:18:25.000Z","updated":"2019-02-16T11:26:15.611Z","comments":true,"path":"2019/02/16/Camp-Day3-B-集合/","link":"","permalink":"http://aoudad.cn/2019/02/16/Camp-Day3-B-集合/","excerpt":"","text":"题意描述最近放假了，可怜计划和她的好朋友$Sylvia$ 去公园玩。我们可以把地图抽象成一个二维平面，可怜最开始的位置是点 $x$，$Sylvia$ 最开始的位置是点 $y$，公园是一个以点 $o$ 为圆心，半径为 $r$ 的圆 $O$。因为进入公园要买票，因此她们约好了先在不进入公园的情况下，在公园的边界上集合，然后在一起买票进公园。她们想要选择一个最优的集合地点使得双方要走的距离长度和最小。换句话说，令 $d(s,t)$为在平面上，不经过圆 $O$ 的内部，从 $s$ 走到 $t$ 的最短距离，可怜希望在圆 $O$ 的边界上找到点 $m$，使得 $d(x,m)+d(y,m)$尽可能地小。 Input输入第一行一个整数 $t(1 \\leq t \\leq 10^6)$ 表示数据组数。对于每组数据，输入一行 $7$ 个整数，分别是 $x$ 的横纵坐标，$y$ 的横纵坐标，$o$ 的横纵坐标和半径 $r(1 \\leq r \\leq 10^3)$，其中所有坐标的绝对值不超过 $10^3$。数据保证 $x$ 和 $y$ 都不在圆 $O$ 的内部，即 $x,y$ 和 $o$ 的欧几里得距离都大于等于 $r$。 Output对于每组数据，输出一行一个整数，表示最小的总距离，保留三位小数。输入保证每组数据答案的第四位小数都不是 $4$ 或者 $5$。 Sample Input30 1 2 0 1 0 10 0 2 0 3 0 10 0 2 0 1 3 1 Sample Output2.5712.0004.472 思路：和EC的一道题很像，就交线过不过圆两种情况，队友搞的，不过好像有一半时间在跨频道聊天导致弄了很久的假做法2333，不补了不补了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);const double eps = 1e-8;struct point &#123; double x, y; point()&#123;&#125; point( double x, double y ) : x(x), y(y) &#123;&#125; point operator - ( const point b ) const &#123; return point( x - b.x, y - b.y ); &#125; point operator + ( const point b ) const &#123; return point( x + b.x, y + b.y ); &#125; point operator * ( double d ) const &#123; return point( x * d, y * d ); &#125; point operator / ( double d ) const &#123; return point( x / d, y / d ); &#125; double len() &#123; return sqrt( x * x + y * y ); &#125; void input() &#123; scanf( \"%lf%lf\", &amp;x, &amp;y ); &#125;&#125;a, b, o;double r, ans;int dcmp(double x) &#123; return (x &gt; eps) - (x &lt; -eps);&#125;double cross( point a, point b ) &#123; return a.x * b.y - a.y * b.x;&#125;double dot( point a, point b ) &#123; return a.x * b.x + a.y * b.y;&#125;double dis(point a, point b) &#123; return sqrt(dot(a - b, a - b));&#125;double ptoseg( point p, point a, point b ) &#123; if( dcmp( dot(p - a, b - a) ) &lt;= 0 ) return dis(p, a); if( dcmp( dot(p - b, a - b) ) &lt;= 0 ) return dis(p, b); return fabs(cross(p - a, b - a)) / dis(a, b);&#125;point nei(point a, point b, point c) &#123; double A = dis(b, c), B = dis(a, c), C = dis(a, b); double P = A + B + C; return a * (A/P) + b * (B/P) + c * (C/P);&#125;#define sqr(x) ((x)*(x))int seg_cir(point c, double r, point a, point b, point &amp;res1, point &amp;res2) &#123; int k = 0; double aa = sqr(a.x - b.x) + sqr(a.y - b.y); double bb = 2 * ((b.x - a.x)*(a.x - c.x) + (b.y - a.y)*(a.y - c.y)); double cc = sqr(c.x) + sqr(c.y) + sqr(a.x) + sqr(a.y) - r * r - 2 * (c.x * a.x + c.y * a.y); if( dcmp( bb * bb - 4 * aa * cc ) &gt;= 0 ) &#123; double u1 = (-bb + sqrt(bb * bb - 4 * aa * cc)) / 2.0 / aa; double u2 = (-bb - sqrt(bb * bb - 4 * aa * cc)) / 2.0 / aa; if( u1 &gt; u2 &amp;&amp; dcmp(u2) &gt;= 0 ) swap(u1, u2); if( dcmp(u1) &gt;= 0 &amp;&amp; dcmp(u1-1) &lt;= 0 ) &#123; res1.x = a.x + u1 * (b.x - a.x); res1.y = a.y + u1 * (b.y - a.y); //if( dcmp(res1.y - c.y) &lt;= 0 ) res1.ok = true; 下半圆判定 ++k; &#125; if( dcmp(u1-u2) &amp;&amp; dcmp(u2) &gt;= 0 &amp;&amp; dcmp(u2-1) &lt;= 0 ) &#123; res2.x = a.x + u2 * (b.x - a.x); res2.y = a.y + u2 * (b.y - a.y); //if( dcmp(res2.y - c.y) &lt;= 0 ) res2.ok = true; 下半圆判定 ++k; &#125; &#125; return k;&#125;double angle( point a, point b ) &#123; double k = dot(a, b) / a.len() / b.len(); k = max(k, -1.0); k = min(k, 1.0); return acos( k );&#125;point rotate(point p, double radian) &#123; double c = cos(radian), s = sin(radian); point res; res.x = p.x * c - p.y * s; res.y = p.y * c + p.x * s; return res;&#125;double check(double ang) &#123; point tmp = rotate(b - o, ang); point tmp1, tmp2; seg_cir(o, r, o, o + tmp, tmp1, tmp2); //ans = min(dis(a, tmp1) + dis(b, tmp1), ans); return dis(a, tmp1) + dis(b, tmp1);&#125;int main() &#123; int cas; scanf(\"%d\", &amp;cas); while(cas--) &#123; scanf(\"%lf%lf\", &amp;a.x, &amp;a.y); scanf(\"%lf%lf\", &amp;b.x, &amp;b.y); scanf(\"%lf%lf\", &amp;o.x, &amp;o.y); scanf(\"%lf\", &amp;r); double di = ptoseg(o, a, b); ans = 0; if(dcmp(di - r) &lt; 0) &#123; double dis1 = sqrt(dis(o, a) * dis(o, a) - r * r); double dis2 = sqrt(dis(o, b) * dis(o, b) - r * r); double ang = atan2(sqrt(dis(o, a) * dis(o, a) - di * di), di) + atan2(sqrt(dis(o, b) * dis(o, b) - di * di), di) - atan2(dis1, r) - atan2(dis2, r); //double ang = acos((dis(o, a) * dis(o, a) + dis(o, b) * dis(o, b) - dis(a, b) * dis(a, b)) / (dis(o, a) * dis(o, b) * 2)); //ang -= acos((dis(o, a) * dis(o, a) + r * r - dis(o, a) * dis(o, a) + r * r) / (dis(o, a) * r * 2)); //ang -= acos((dis(o, b) * dis(o, b) + r * r - dis(o, b) * dis(o, b) + r * r) / (dis(o, b) * r * 2)); ans = dis1 + dis2 + ang * r; &#125; else if(dcmp(di - r) == 0) &#123; ans = dis(a, b); &#125; else &#123; ans = 1000000000000; if(cross(a - o, b - o) &gt; 0) swap(a.x, b.x), swap(a.y, b.y); double l = 0, r = angle(a - o, b - o); while(dcmp(r - l) &gt; 0) &#123; //cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; double midl = (l + r) / 2; double midr = (midl + r) / 2; if(dcmp(check(midl) - check(midr)) &gt; 0) l = midl; else r = midr; &#125; ans = check(r); //point p = nei(a, b, o); //p.x = (p.x - o.x) * 1000 + o.x; //p.y = (p.y - o.y) * 1000 + o.y; //point tmp, tmp1, tmp2; //seg_cir(o, r, o, p, tmp, tmp2); //double dis1 = dis(a, tmp); //double dis2 = dis(b, tmp); //ans = dis1 + dis2; &#125; printf(\"%.3f\\n\", ans); &#125;&#125;","categories":[{"name":"Camp day3","slug":"Camp-day3","permalink":"http://aoudad.cn/categories/Camp-day3/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://aoudad.cn/tags/计算几何/"}]},{"title":"Camp Day5 A Cactus Draw","slug":"Camp-Day5-A-Cactus-Draw","date":"2019-02-16T10:55:09.000Z","updated":"2019-02-16T10:59:31.117Z","comments":true,"path":"2019/02/16/Camp-Day5-A-Cactus-Draw/","link":"","permalink":"http://aoudad.cn/2019/02/16/Camp-Day5-A-Cactus-Draw/","excerpt":"","text":"题意描述你有一棵仙人掌，你想把它画在平面上，使得没有边相交。 如果一个无向连通图的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。 Input第一行两个整数 $n, m$ ($1\\leq n\\leq 1000, 1\\leq m \\leq 2000$)，表示点数和边数。接下来 $m$ 行，每行两个正整数 $u, v$ ($1\\leq u, v\\leq n, u\\neq v$)，保证不存在重边。 Output输出 $n$ 行，每行两个整数 $x_i, y_i$ ($1\\leq x_i, y_i\\leq n$)，表示将第 $i$ 个点画到 $(x_i, y_i)$ 的位置，要求图中的每对边如果有公共点，那么只能在端点相交，否则不能相交。如果有多组解，那么输出任意的解即可。 Sample Input3 31 22 33 1 Sample Output1 12 32 2 思路：自闭了，看代码吧。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e3+7;vector&lt;int&gt; E[maxn];int p[maxn];int y[maxn], x[maxn];int yy, vis[maxn];vector&lt;int&gt; C[maxn];void dfs(int u, int ff)&#123; vis[u]=1; for(int i=0;i&lt;E[u].size();++i) &#123; int v = E[u][i]; if(v==ff) continue; if(vis[v]==1)&#123;for(int tmp=u;tmp!=v;tmp=p[tmp])C[v].eb(tmp);&#125; else if(vis[v]==0) p[v]=u, dfs(v, u); &#125; vis[u]=2;&#125;void solve()&#123; yy=0; memset(vis, 0, sizeof vis); x[1]=1;y[1]=++yy; queue&lt;pair&lt;int, int&gt; &gt; q; q.push(mp(1,1));vis[1]=1; while(!q.empty()) &#123; int u = q.front().fi, xx=q.front().se;q.pop(); for(int i=0;i&lt;C[u].size();++i) &#123; int v = C[u][i]; if(vis[v]) continue; vis[v] = 1; x[v] = xx+1;y[v]=++yy; q.push(mp(v, xx+1)); &#125; for(auto v:E[u]) &#123; if(vis[v])continue; vis[v]=1; x[v] = xx+1;y[v]=++yy; q.push(mp(v, xx+1)); &#125; &#125;&#125;int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;++i)&#123;int u, v;scanf(\"%d%d\", &amp;u, &amp;v);E[u].eb(v);E[v].eb(u);&#125; dfs(1, 0); solve(); for(int i=1;i&lt;=n;++i) printf(\"%d %d\\n\", x[i], y[i]);&#125;","categories":[{"name":"Camp day5","slug":"Camp-day5","permalink":"http://aoudad.cn/categories/Camp-day5/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://aoudad.cn/tags/构造/"},{"name":"dfs","slug":"dfs","permalink":"http://aoudad.cn/tags/dfs/"}]},{"title":"Camp Day1 E 流流流动","slug":"Camp-Day1-E-流流流动","date":"2019-02-16T07:50:19.000Z","updated":"2019-02-16T07:59:24.217Z","comments":true,"path":"2019/02/16/Camp-Day1-E-流流流动/","link":"","permalink":"http://aoudad.cn/2019/02/16/Camp-Day1-E-流流流动/","excerpt":"","text":"题意描述喜欢数学的 $wls$ 最近被萎住了。现在他一共有 $1\\cdots n$ 这么多数字，取数字 $i$ 会得到 $f[i]$ 的收益。数字之间有些边，对于所有的 $i(i \\neq 1)$ ，若 $i$ 为奇数，则 $i$ 与 $3i+1$ 之间有边，否则 $i$ 与 $i/2$ 之间有边。如果一条边的两个顶点 $xy$ 都被取了，那么会失去 $d[min(x, y)]$ 的价值。请问 $wls$ 怎么取，才能使得收益最大？ Input第一行一个整数 $n$ 。接下来一行 $n$ 个整数表示 $f$ 。接下来一行 $n$ 个整数表示 $d$ 。$1 \\leq n \\leq 100$$1 \\leq f[i], d[i] \\leq 1000$ Output一行一个整数表示答案。 Sample Input210 101 2 Sample Output19 思路：根据角谷猜想，这个图是个树，简单树形dp，存图的时候注意一下就行。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const int maxn = 405;int w[maxn], d[maxn];vector&lt;int&gt; G[maxn];int f[maxn][2];int vis[maxn];void dfs(int u, int ff)&#123; vis[u] = 1;// error(u, ff); f[u][1] = w[u];f[u][0]=0; for(int i=0;i&lt;G[u].size();++i) &#123; int v = G[u][i]; if(v==ff) continue; dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); f[u][1] += max(f[v][0], f[v][1]-d[min(u, v)]); &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; w[i]; for(int i=1;i&lt;=n;++i) cin &gt;&gt; d[i]; for(int i=2;i&lt;=n;++i) &#123; if(i%2==0) G[i].push_back(i/2), G[i/2].push_back(i); else if(3*i+1&lt;=n)&#123;G[i].push_back(i*3+1), G[i*3+1].push_back(i);&#125; &#125; int ans = 0; for(int i=1;i&lt;=n;++i) &#123; if(vis[i])continue; dfs(i, 0); ans += max(f[i][0], f[i][1]); &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Camp day1","slug":"Camp-day1","permalink":"http://aoudad.cn/categories/Camp-day1/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://aoudad.cn/tags/树形DP/"}]},{"title":"Camp Day3 F 小清新数论","slug":"Camp-Day3-F-小清新数论","date":"2019-02-16T06:06:31.000Z","updated":"2019-02-16T07:29:10.039Z","comments":true,"path":"2019/02/16/Camp-Day3-F-小清新数论/","link":"","permalink":"http://aoudad.cn/2019/02/16/Camp-Day3-F-小清新数论/","excerpt":"","text":"题意描述这是一道比较基础的数论题。给出一个整数 $n$，计算 $\\sum_{i=1}^n \\sum_{j=1}^n \\mu(\\gcd(i,j))$。其中 $\\gcd(i,j)$ 表示 $i,j$ 的最大公约数，$\\mu(i)$ 表示莫比乌斯函数，它的一个等价定义是 $\\mu(1)=1$，$\\mu(n) = - \\sum_{d\\lt n,d|n} \\mu(d)$ 当 $n \\gt 1$ 时。 Input输入一行包含一个整数 $n(1 \\leq n \\leq 10^{10})$。 Output输出一行一个整数，表示答案。答案可能很大，请对 $998244353$ 取模后输出。 Sample Input5 100 Sample Output14 3631 思路：爽到，这道题补了一天才补完，学到了很多东西，虽然做出来的时候发现这东西好套路……要求\\Sigma_{i=1}^n\\Sigma_{j=1}^n\\ ​\\mu(gcd(i,j))枚举gcd得到 \\Sigma_{d=1}^n\\Sigma_{d|i}^n\\Sigma_{d|j}^n\\ ​\\mu(d)*[gcd(i,j)=d]\\Sigma_{d=1}^n\\ ​\\mu(d)\\ \\Sigma_i^{\\lfloor n/d\\rfloor}\\Sigma_j^{\\lfloor n/d\\rfloor}[gcd(i,j)=1]替换gcd=1得到 \\Sigma_{d=1}^n\\ ​\\mu(d)\\ \\Sigma_i^{\\lfloor n/d\\rfloor}\\Sigma_j^{\\lfloor n/d\\rfloor}\\Sigma_{D|gcd(i,j)}\\mu(D)枚举D得到 \\Sigma_{d=1}^n\\ ​\\mu(d)\\ \\Sigma_{D=1}^{\\lfloor n/d \\rfloor}\\ \\mu(D)\\lfloor \\frac{n}{Dd}\\rfloor^2令$T=Dd$，得到 \\Sigma_{T=1}^n\\Sigma_{d|T}\\ ​\\mu(d)\\ \\mu(D)\\lfloor \\frac{n}{Dd}\\rfloor^2也就是 S(n)=\\Sigma_{T=1}^{n}\\ \\ (\\mu * \\mu)(T)\\ \\lfloor \\frac{n}{T}\\rfloor^2设 $S_1(n)=\\Sigma_{T=1}^{n}(\\mu \\mu)(T)$ ，如果我们已知 $S_1$ 那么我们就可以 $O(\\sqrt n)$ 求出 $S(n)$ 了。而 $S_1$ 是两个莫比乌斯函数的迪利克雷卷积的前缀和，积性函数的迪利克雷卷积还是一个积性函数，所以我们可以用线性筛筛出来$1e7$范围内的$\\mu \\mu$的值，这样$DIV2$的版本就能过了，复杂度$O(n)$，$DIV1$显然要用杜教筛之类的，由 g(1)S(n)=\\Sigma_{i=1}^{n}(\\mu*\\mu*g)(i)-\\Sigma_{i=2}^n g(i)S(\\lfloor \\frac{n}{i} \\rfloor)如果$g=I$，$\\mu \\mu I$ = $\\mu$，所以有 S(n)=\\Sigma_{i=1}^{n}\\mu(i)-\\Sigma_{i=2}^nS(\\lfloor \\frac{n}{i} \\rfloor)，对这两个都做杜教筛就可以了。复杂度$O($能过$)$(因为不太会算，应该是$O(n^{2/3})$到$O(n^{3/4})$之间)。这里提一下怎么筛这个积性函数$\\mu*\\mu$，理论上所有的积性函数都是可以线性筛的，只要能快速地求出$f(1),f(p),f(p^k)$，那么对每个数$n=\\Pi_{j=0}^kp_j^{e_j}$存一个$low(n)$表示$low(n)=p_0^{e_0}$，然后根据线性筛的时候$i%p[j]==0$的情况下,$i$是否等于$low(i)$分别处理就行了。很有意思，以后学学$min_25$筛和洲阁筛。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define SZ(x) (int)(x.size())#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const ll mod = 998244353;const int maxn = 1e7+20;int isp[maxn+5], p[maxn+5], mu[maxn+5], tot;ll f[maxn+5], low[maxn+5];void init()&#123; mu[1]=1;f[1]=1;tot=0; for(int i=2;i&lt;=maxn;++i) &#123; if(!isp[i])p[tot++]=i, mu[i]=-1, f[i]=-2, low[i]=i; for(int j=0;j&lt;tot&amp;&amp;p[j]*1LL*i&lt;=maxn;++j) &#123; int tmp = i*p[j]; isp[tmp] = 1; if(i%p[j]==0) &#123; mu[tmp]=0;low[tmp] = low[i]*p[j]; if(i==low[i]) f[tmp] = (f[i]==-2?1:0); else f[tmp] = f[i/low[i]]*f[low[i]*p[j]]; break; &#125; mu[tmp] = -mu[i]; f[tmp] = f[i]*f[p[j]]; low[tmp] = p[j]; &#125; &#125; for(int i=2;i&lt;=maxn;++i) mu[i]+=mu[i-1], f[i]+=f[i-1], f[i]%=mod;&#125;map&lt;ll, ll&gt; mpmu;ll getmu(ll n)&#123; if(n&lt;=maxn)return mu[n]; if(mpmu[n])return mpmu[n]; ll res = 1; for(ll l=2, r;l&lt;=n;l=r+1) &#123; r = n/(n/l); res -= (r-l+1)*getmu(n/l); res %= mod; &#125; return mpmu[n]=res;&#125;map&lt;ll, ll&gt; S;ll solve(ll n)&#123; if(n&lt;=maxn)return f[n]; if(S[n])return S[n]; ll res = getmu(n); for(ll l=2, r;l&lt;=n;l=r+1) &#123; r = n/(n/l); res -= (r-l+1)*solve(n/l); res %= mod; &#125; return S[n]=res;&#125;int main()&#123; init(); ll n, res=0; cin &gt;&gt; n; for(ll L=1, R; L&lt;=n;L=R+1) &#123; R = n/(n/L); res += (solve(R)-solve(L-1))*(n/L)%mod*(n/L)%mod; res%=mod; &#125; cout &lt;&lt; (res+mod)%mod &lt;&lt; endl;&#125;","categories":[{"name":"Camp day3","slug":"Camp-day3","permalink":"http://aoudad.cn/categories/Camp-day3/"}],"tags":[{"name":"杜教筛","slug":"杜教筛","permalink":"http://aoudad.cn/tags/杜教筛/"},{"name":"积性函数前缀和","slug":"积性函数前缀和","permalink":"http://aoudad.cn/tags/积性函数前缀和/"}]},{"title":"Camp Day7 F 逆序对","slug":"Camp-Day7-F-逆序对","date":"2019-02-15T07:13:17.000Z","updated":"2019-02-15T07:41:32.856Z","comments":true,"path":"2019/02/15/Camp-Day7-F-逆序对/","link":"","permalink":"http://aoudad.cn/2019/02/15/Camp-Day7-F-逆序对/","excerpt":"","text":"题意描述给定长度为 $n$ 的两两不相同的整数数组 $b[1\\cdots n]$，定义 $f(y)$为：将 $b$ 每个位置异或上 $y$后，得到的新数组的逆序对个数。现在你需要求 $\\sum_{i=1}^{m}f(i)$由于答案可能很大，你只需要输出答案对 $998244353$ 取模后的值 Input第一行两个正整数 $n,m$ ($1\\leq n\\leq 10^5 , 1\\leq m\\leq 10^9$)第二行 $n$ 个整数表示 $b[1…n]\\ 0\\leq b[i]\\leq 10^9$，保证 $b[1…n]$ 互不相同 Output输出一个数，表示答案 Sample Input3 31 2 3 Sample Output6 思路：感觉非常有意思的一道题……挺简单的就是自己很傻逼……考虑$DIV2$的版本，实际上就是求两两之间，有多少个数$x$，使得前面那个数$b[i] \\bigotimes x$ 大于 $b[j]\\bigotimes x$ ($\\bigotimes$表示异或)，按位考虑的话，设$i$为 $a[i]\\bigotimes a[j]$ 的最高位，实际上就是求有多少个数的第 $i$ 位与 $a[j]$ 的第 $i$ 位相同（这样才能使 $a[i]\\bigotimes x \\gt a[j] \\bigotimes x$ ）。设 $a[j]$ 的第 $i$ 位为 $y$ ，$m$ 的第 $i$ 位是 $z$ ，求 $1, \\cdots, m$ 内有多少个数的第 $i$ 位为 $y$ ，这是一个类似数位 $dp$ 的东西，从高位往低位考虑，高于第 $i$ 位的加上他的一半，如果 $y$ 为 $0$ 且 $z$ 为 $0$ ，那么剩下的部分都是满足的，全都加起来，如果 $y$ 为 $0$ 且 $z$ 为 $1$ ，那么有 $(1&lt;&lt;i)-1$ 个数满足；如果 $y$ 为 $1$ 且 $z$ 为 $0$ ，那么剩下的数都是不满足的，如果都为 $1$ 就只能取 $(((1&lt;&lt;cnt)-1)\\And m)+1$ ，也就是第i位为1，剩下的取完。那么 $DIV2$ 的就做完了。复杂度 $O(n^2)$ 。对 $DIV1$ 的版本，考虑分治，假设目前考虑的是第 $i$ 位，在目前考虑的区间内大于第 $i+1$ 位的都是相同的，将当前区间划分为两半，前一半就是第 $i$ 位为 $0$ 的，后一半就是第 $i$ 位是 $1$ 的，那么只要统计前面有多少个第 $i$ 位和自己不同的数就可以了。复杂度$O(nlogn)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define SZ(x) (int)(x.size())#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const ll mod = 998244353;const int maxn = 3e5+7;ll b[maxn];ll tL[maxn], tR[maxn];ll res = 0;ll n, m;void solve(int L, int R, int now)&#123; if(L&gt;=R||now==-1) return; ll p0=0, p1=0; for(int i=L;i&lt;=R;++i) &#123; if((b[i]&gt;&gt;now)&amp;1) &#123; tR[p1++] = b[i]; res = (res + ((m&gt;&gt;(now+1))&lt;&lt;now)*p0)%mod; res += p0*(((m&gt;&gt;now)&amp;1LL)?(((1LL&lt;&lt;now)-1)&amp;m)+1:0); res %= mod; &#125; else &#123; tL[p0++] = b[i]; res = (res + ((m&gt;&gt;(now+1))&lt;&lt;now)*p1)%mod; res += p1*(((m&gt;&gt;now)&amp;1LL)?(1LL&lt;&lt;now)-1:(((1LL&lt;&lt;now)-1)&amp;m)); res %= mod; &#125; &#125; for(int i=0;i&lt;p0;++i) b[i+L] = tL[i]; for(int i=0;i&lt;p1;++i) b[i+p0+L] = tR[i]; solve(L, L+p0-1, now-1); solve(L+p0, R, now-1);&#125;int main()&#123; scanf(\"%lld%lld\", &amp;n, &amp;m); for(int i=1;i&lt;=n;++i) scanf(\"%d\", b+i); res = 0; solve(1, n, 31); cout &lt;&lt; res &lt;&lt; endl;/***************************************************************************** *for DIV2 * * for(int i=1;i&lt;=n;++i) * &#123; * for(int j=i+1;j&lt;=n;++j) * &#123; * int tmp = b[i]^b[j], cnt=0; * while(tmp)tmp&gt;&gt;=1, ++cnt;--cnt; * tmp = (b[j]&gt;&gt;cnt)&amp;1; * res += (m&gt;&gt;(cnt+1))&lt;&lt;cnt; * if(tmp==0) res += ((m&gt;&gt;cnt)&amp;1)?(1&lt;&lt;cnt)-1:(((1&lt;&lt;cnt)-1)&amp;m); * else res += ((m&gt;&gt;cnt)&amp;1)?(((1&lt;&lt;cnt)-1)&amp;m)+1:0; * res %= mod; * &#125; * &#125; * cout &lt;&lt; res &lt;&lt; endl; *****************************************************************************/&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"cdq分治","slug":"cdq分治","permalink":"http://aoudad.cn/tags/cdq分治/"},{"name":"异或","slug":"异或","permalink":"http://aoudad.cn/tags/异或/"},{"name":"计数","slug":"计数","permalink":"http://aoudad.cn/tags/计数/"}]},{"title":"Camp Day7 H 同构","slug":"Camp-Day7-H-同构","date":"2019-02-14T11:54:39.000Z","updated":"2019-02-15T07:53:06.719Z","comments":true,"path":"2019/02/14/Camp-Day7-H-同构/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day7-H-同构/","excerpt":"","text":"题意描述定义两张$n$个点的无向图 $E_1,E_2$​ 是同构的，当且仅当存在一个 $1…n$的排列 $p[1…n]$，满足对于所有$(u,v) \\in E_1$，有 $(p[u],p[v]) \\in E_2$现在给定 $n$，我们定义一张无向图是好的，当且仅当它无重边无自环，且每个点的度数都是$n-3$。你需要求出最多能找出多少张好的图，使得它们两两不同构由于答案可能很大，你只需要输出答案对$998244353$取模后的值 Input第一行一个正整数$n$($3\\leq n\\leq 10^5)$ Output输出答案对$998244353$取模后的值 Sample Input3 Sample Output1 思路：取补图，也就是$n$个点的分成多个环的方案数，等价于$n$的整数划分，且每个数都不小于$3$.现场用了一些公式和模板干掉了……也就是第一份代码第二份代码是$dp$，这个$oj$数组开太大居然报$runtime\\ error$ ……佛了。假设数据范围比较小，那么整数划分实际上就是一个完全背包，一共有$n-3$个物品，物品的体积和价值都是$3，\\cdots , n$也就是说$dp[i][j]$表示用前i个数字凑成j的方案数。这个做法是$O(n^2)$的，可以过$div2$的版本，这里我们注意到对于那些$x&gt;\\sqrt n$的x这样的数最多有$\\sqrt n$个，所以可以设$dp[i][j]$表示用$i$个大于$\\sqrt n$的数，和为$j$的方案数。为了保证不重不漏，可以考虑按照从大到小加进来，于是有以下的转移dp[i][j] += dp[i-1][j-\\sqrt n]表示往里面添加一个最小的$\\sqrt n$ dp[i][j]+=dp[i][j-i]表示把前i个数都加上$1$，这样就是不重不漏的了。所以可以做两次$dp$，分别处理出大于等于$\\sqrt n$和小于$\\sqrt n$的两个$dp$，这个部分都是$O(n\\sqrt n)$的，然后$O(n)$枚举一下那部分是由小于$\\sqrt n$得到的加起来就好了。总复杂度$O(n\\sqrt n)$感觉这个思想很有借鉴意义。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#include&lt;unordered_map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IO/////// Macro ////////////////const ll Mod = 998244353;#define R registerint n,f[200001],g[200001];int main()&#123; while(~scanf(\"%d\",&amp;n)) &#123; memset(f, 0, sizeof f); memset(g, 0, sizeof g); g[1]=0; f[0]=f[1]=g[2]=1; for (R int i=3; g[i-2]&lt;=n; i+=2) g[i]=(g[i-2]+3*(i&gt;&gt;1)-1)%Mod; for (R int i=4; g[i-2]&lt;=n; i+=2) g[i]=(g[i-2]+3*(i&gt;&gt;1)-2)%Mod; for (R int i=2; i&lt;=n; ++i) for (R int j=2; i-g[j]&gt;=0; ++j) f[i]=((j&gt;&gt;1)&amp;1)?(f[i]+f[i-g[j]])%Mod:(f[i]-f[i-g[j]]+Mod)%Mod; printf(\"%d\\n\", (f[n]-f[n-1]-f[n-2]+f[n-3]+Mod)%Mod); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const ll mod = 998244353;#define R registerconst int maxn = 1e5+7;ll dp[maxn];ll g[400][maxn];int main()&#123; int n;cin &gt;&gt; n; dp[0]=g[0][0]=1; int sn = (int)sqrt(n);sn=max(sn, 3); for(int i=3; i&lt;sn; ++i) for(int j=i; j&lt;=n; ++j) dp[j] = (dp[j] + dp[j-i])%mod; for(int i=1; i&lt;=n/sn; ++i) for(int j=1; j&lt;=n; ++j) &#123; if(j&gt;=sn) g[i][j] += g[i-1][j-sn]; if(j&gt;=i) g[i][j] += g[i][j-i]; g[i][j]%=mod; &#125; ll res = 0; for(int i=1; i&lt;=n/sn; ++i) for(int j=0; j&lt;=n; ++j) g[i][j]=(g[i][j]+g[i-1][j])%mod; for(int i=0; i&lt;=n; ++i) &#123; res += dp[i] * g[n/sn][n-i]; res%=mod; &#125; printf(\"%lld\\n\", res);&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"整数划分","slug":"整数划分","permalink":"http://aoudad.cn/tags/整数划分/"}]},{"title":"Camp Day8 C 御坂妹妹","slug":"Camp-Day8-C-御坂妹妹","date":"2019-02-14T11:24:08.000Z","updated":"2019-02-15T07:53:31.276Z","comments":true,"path":"2019/02/14/Camp-Day8-C-御坂妹妹/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day8-C-御坂妹妹/","excerpt":"","text":"题意描述有 $n$ 个御坂妹妹升级到了$Lv.5$，能发射超电磁炮了，所以她们想找一方通行（学园都市最强 $Lv.5$）复仇。每个御坂妹妹都在平面上发射了一个直线型超电磁炮，在此使用二维直角坐标系下的直线方程 $y = k_ix + b_i$ 描述其轨迹。一方通行作为玩矢量的大爷，自然可以轻易防御这些超电磁炮。所以他想在平面中制造一个矢量反射镜（可以看做是平面中的一条与 $x$ 轴垂直的线段），使得所有超电磁炮轨迹都与该反射镜有公共点。一方通行想知道他最少要做多长的矢量反射镜。也就是说：记 $f(x) = \\max\\{ k_ix + b_i | i = 1,2,\\cdots,n\\}$ - $\\min \\{ k_ix + b_i | i = 1,2,\\cdots,n\\}$，求 $\\min\\{f(x) | x \\in R\\}$。 Input第一行一个正整数 $n(1 \\le n \\le 5\\times10^5)$。接下来 $n$ 行，每行两个数 $k_i,b_i (0 \\le |k_i|, |b_i| \\le 10^6)$ 表示一条直线，其中 $k_i$ 是整数，$b_i$是小数，且最多到小数点后三位。 Output输出仅一行一个小数，表示答案。假设你的答案为 $a$，标准答案为 $b$你的答案会被视为正确。 Sample Input51 0-1 -10 00 -21 -2 Sample Output2.0000000000 思路：做两次半平面交，扫描线求上凸包和下凸包的最近距离。然后被队友三分艹过去了……什么都想卡……什么都没卡掉 代码：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const long double eps = 1e-12;const int maxn = 5e5 + 10;int n;long double k[maxn], b[maxn];long double check(long double x) &#123; long double tmp = x * k[1] + b[1]; long double mx = -1e18; long double mn = 1e18; //4cout &lt;&lt; endl; //cout &lt;&lt; mx &lt;&lt; \" \" &lt;&lt; mn &lt;&lt; endl; for(int i = 1; i &lt;= n; i++) &#123; tmp = x * k[i] + b[i]; mx = max(mx, tmp); mn = min(mn, tmp); //cout &lt;&lt; mx &lt;&lt; \" \" &lt;&lt; mn &lt;&lt; endl; &#125; long double re = mx - mn; return re;&#125;int main() &#123; scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%Lf%Lf\", &amp;k[i], &amp;b[i]); long double l = -2000005.0, r = 2000005.0, ans = 1e18; for(int i = 1; i &lt;= 100; i++) &#123; long double len = (r - l) / 3.0; long double midl = l + len; long double midr = r - len; long double re1 = check(midl); long double re2 = check(midr); ans = min(ans, re1); ans = min(ans, re2); if(fabs(re1 - re2) &lt; eps) l = midl, r = midr; else if(re1 &lt; re2) r = midr; else l = midl; &#125; printf(\"%.12Lf\\n\", ans);&#125;","categories":[{"name":"Camp day8","slug":"Camp-day8","permalink":"http://aoudad.cn/categories/Camp-day8/"}],"tags":[{"name":"三分","slug":"三分","permalink":"http://aoudad.cn/tags/三分/"},{"name":"半平面交","slug":"半平面交","permalink":"http://aoudad.cn/tags/半平面交/"}]},{"title":"Camp Day7 D 二次函数","slug":"Camp-Day7-D-二次函数","date":"2019-02-14T11:17:44.000Z","updated":"2019-02-15T07:52:49.905Z","comments":true,"path":"2019/02/14/Camp-Day7-D-二次函数/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day7-D-二次函数/","excerpt":"","text":"题意描述给定三个二次函数 $f(x)=x^2+a_1x+b_1$​，$g(x)=x^2+a_2x+b_2$，$h(x)=x^2+a_3x+b_3$​你需要找三个整数 $x_1,x_2,x_3$​，使得 $f(x_1),g(x_2),h(x_3)$ 这三个数中至少有两个数相同 Input第一行一个正整数 $T$ 表示数据组数 $(1\\leq T\\leq 10^4)$接下来 $T$ 行，每行三个六个整数 $a_1,b_1,a_2,b_2,a_3,b_3$​，保证每个数的绝对值都小于等于 $10^4$ Output输出$T$ 行，每行三个整数 $x_1,x_2,x_3$​，要求 $|x_1|,|x_2|,|x_3|\\leq 10^{18}$ Sample Input11 1 1 2 1 3 Sample Output-2 0 -1 思路：队友用不知道什么数学方法a掉的……算了算了不想补。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[5], b[5], c[5];ll ans[5];bool flag;void solve(int i, int j) &#123; int tmp = a[i] * a[i] - a[j] * a[j] + (b[j] - b[i]) * 4; if(tmp == 0) &#123; if(a[i] % 2 == 0 &amp;&amp; a[j] % 2 == 0) &#123; ans[i] = -a[i] / 2; ans[j] = -a[j] / 2; flag = 1; printf(\"%lld %lld %lld\\n\", ans[1], ans[2], ans[3]); return; &#125; &#125; else if(tmp &gt; 0) for(int y = 1; y * y &lt;= tmp; y++) if(tmp % y == 0) &#123; int x = tmp / y; if((x + y) % 2 == 0 &amp;&amp; (x - y) % 2 == 0) &#123; int z1 = (x + y) / 2; int z2 = (x - y) / 2; if((a[i] + z1) % 2 == 0 &amp;&amp; (a[j] + z2) % 2 == 0) &#123; ans[i] = -(a[i] + z1) / 2; ans[j] = -(a[j] + z2) / 2; flag = 1; printf(\"%lld %lld %lld\\n\", ans[1], ans[2], ans[3]); return; &#125; &#125; &#125;&#125;int main() &#123; int cas; scanf(\"%d\", &amp;cas); while(cas--) &#123; flag = 0; scanf(\"%d%d%d%d%d%d\", &amp;a[1], &amp;b[1], &amp;a[2], &amp;b[2], &amp;a[3], &amp;b[3]); for(int i = 1; i &lt;= 3; i++) for(int j = 1; j &lt;= 3; j++) if(i != j &amp;&amp; !flag) &#123; solve(i, j); &#125; &#125;&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Camp Day2 K Sticks","slug":"Camp-Day2-K-Sticks","date":"2019-02-14T10:58:31.000Z","updated":"2019-02-15T07:51:07.294Z","comments":true,"path":"2019/02/14/Camp-Day2-K-Sticks/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day2-K-Sticks/","excerpt":"","text":"题意描述小 Q 手上有$12$根木棒，它们的长度依次为 $l_1, l_2, \\cdots, l_{12}$​。他想用一些木棒来拼出三角形,这里每个三角形要用三根合适的木棒 $l_a, l_b, l_c$​ 组成，它们满足 $l_a + l_b \\gt l_c$ 和 $l_a + l_c \\gt l_b$ ，以及 $l_b + l_c \\gt l_a$​。此外，每根木棒只能用在至多一个三角形中。你能帮他尽可能多的拼出三角形吗？ Input输入包含多组测试数据。第一行包含一个整数 $T$，表示测试数据的组数。随后的内容是各组测试数据。对于每组测试数据：仅一行，包含十二个整数$l_1, l_2, \\cdots, l_{12}$。 $1 \\leq T \\leq 6000$ $1 \\leq l_i \\leq 10^9$ Output对于每组测试数据，首先输出一行$Case #x: m$，其中$x$是测试数据的编号（从 $1$ 开始编号），$m$是三角形数量的最大值。接下来输出$m$行，每行包含三个整数，表示三角形三条边的长度。如果有多种最优解，请输出任意一种。注意，每根木棒只能使用至多一次，而且对于输出中位于同一行的相邻整数，你需要输出一个空格将它们隔开。 Sample Input51 2 1 3 1 4 1 5 1 6 1 71 2 3 4 5 6 7 8 9 10 11 121 2 3 5 8 13 21 34 55 89 144 2332 3 6 15 27 59 72 83 121 159 201 2342 2 4 8 16 32 64 128 256 512 1024 1281 Sample OutputCase #1: 41 1 14 3 21 1 16 7 5Case #2: 36 5 410 12 119 8 7Case #3: 0Case #4: 283 121 72234 159 201Case #5: 11024 1281 512 思路：先预处理，二进制枚举每一个三木棍组合是不是能组成三角形，再枚举所有划分，将$12$根木棍分成$4$个$3$木棍集合，这里总方案数是$\\frac{12!}{3!3!3!3!4!}$我一开始写的递归是多了最后这个$4!$的常数，是过不了的，我写的递归是枚举染色方法，可以这样优化，小的颜色一定要在大的颜色之前使用，这样就可以优化掉那个常数了，不过直接递归好像还是不行，递推大法好。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define SZ(x) (int)(x.size())#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;int a[20], vis[(1&lt;&lt;12)+2], res, cnt[5], tag[30];int SIZ = 12;vector&lt;int&gt; out(6);vector&lt;int&gt; p(6);int region[maxn&lt;&lt;3][5], tot;void dfs(int now)&#123;// error(tot); if(now==SIZ) &#123; for(int i=1;i&lt;=4;++i) p[i]=0; for(int i=0;i&lt;SIZ;++i) p[tag[i]]|=1&lt;&lt;i; for(int i=1;i&lt;=4;++i) region[tot][i] = p[i]; ++tot; return ; &#125; for(int i=1;i&lt;=4;++i) if(cnt[i]&amp;&amp;cnt[i-1]&lt;3) &#123; --cnt[i]; tag[now] = i; dfs(now+1); ++cnt[i]; &#125;&#125;int chk[12];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int t;scanf(\"%d\", &amp;t); for(int i=1;i&lt;=4;++i) cnt[i]=3; vector&lt;int&gt; en; for(int i=1;i&lt;(1&lt;&lt;SIZ);++i) &#123; int cnt = 0; for(int j=0;j&lt;SIZ;++j)if((i&gt;&gt;j)&amp;1)++cnt;; if(cnt!=3)continue; en.eb(i); &#125; int len = SZ(en); tot = 0; dfs(0); for(int cas=1;cas&lt;=t;++cas) &#123; for(int i=0;i&lt;SIZ;++i) scanf(\"%d\", a+i); for(int i=0;i&lt;len;++i) vis[en[i]] = 0; for(int i=0;i&lt;len;++i) &#123; int cnt = 0, tmp=en[i]; for(int j=0;j&lt;SIZ;++j)if((tmp&gt;&gt;j)&amp;1)chk[cnt++]=a[j]; if(chk[0]+chk[1]&gt;chk[2]&amp;&amp;chk[2]+chk[1]&gt;chk[0]&amp;&amp;chk[0]+chk[2]&gt;chk[1]) vis[tmp]=1; &#125; res = 0; for(int i=0;i&lt;tot;++i) &#123; int tmp = 0; for(int j=1;j&lt;=4;++j) tmp += vis[region[i][j]]; if(tmp&gt;res) &#123;res=tmp;for(int j=1;j&lt;=4;++j)out[j]=region[i][j];&#125; &#125; printf(\"Case #%d: %d\\n\", cas, res); for(int i=1;i&lt;=4;++i) if(vis[out[i]]) &#123; int cnt = 0; for(int j=0;j&lt;12;++j) if((out[i]&gt;&gt;j)&amp;1) printf(\"%d%c\", a[j], \" \\n\"[++cnt==3]); &#125; &#125;&#125;","categories":[{"name":"Camp day2","slug":"Camp-day2","permalink":"http://aoudad.cn/categories/Camp-day2/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"http://aoudad.cn/tags/枚举/"}]},{"title":"Camp Day1 J 夺宝奇兵","slug":"Camp-Day1-J-夺宝奇兵","date":"2019-02-14T08:14:44.000Z","updated":"2019-02-15T07:50:49.763Z","comments":true,"path":"2019/02/14/Camp-Day1-J-夺宝奇兵/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day1-J-夺宝奇兵/","excerpt":"","text":"题意描述$wls$所在的王国有$n$个居民（不包括$wls$），他们共有$m$件神奇的宝物。对于第$i$件宝物，$wls$可以花费$a_i$的金币把它从原来的主人那里买过来。请问$wls$最少要准备多少金币，才能使他成为宝物最多的人（$wls$的宝物件数严格比其他所有人多）？ Input第一行两个整数$n$，$m$。接下来$m$行，每行两个整数$a_i$​, $c_i$​，表示第$i$件宝物属于居民$c_i$​，$wls$可以花费$a_i$​的代价得到它。$1 \\leq n, m \\leq 100000$$1 \\leq a_i \\leq 1000000000$$1 \\leq c_i \\leq n$ Output一行一个整数表示答案。 Sample Input4 1110 11 110 21 210 31 315 415 415 415 415 4 Sample Output28 思路：三分数量，贪心check。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const int maxn = 100009;ll a[maxn], c[maxn];int n, m;vector&lt;ll&gt; vec[maxn];ll chk(int x)&#123; ll cnt = 0, sum = 0; priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq; for(int i=1;i&lt;=n;++i) &#123; int L = vec[i].size(); for(int j=0;j&lt;L-x+1;++j) &#123; ++cnt; sum += vec[i][j]; &#125; for(int j=max(0, L-x+1);j&lt;L;++j)&#123; pq.push(vec[i][j]);// what_is(pq.top()); &#125; &#125; if(cnt&gt;x) return INFLL; while(cnt&lt;x&amp;&amp;!pq.empty())&#123;sum+=pq.top(); ++cnt; pq.pop();&#125;// error(x, cnt, sum); return sum;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1;i&lt;=m;++i) &#123; cin &gt;&gt; a[i] &gt;&gt; c[i]; vec[c[i]].eb(a[i]); &#125; for(int i=1;i&lt;=n;++i) sort(vec[i].begin(), vec[i].end()); int L = 1, R = m; while(L&lt;R-1) &#123; int mid = (L+R)/2, midd = (R+mid)/2; if(chk(mid)&gt;chk(midd)) L = mid; else R = midd;// error(L, R, chk(L), chk(R)); &#125; cout &lt;&lt; min(chk(L), chk(R)) &lt;&lt; endl;&#125;/*62 3 4 5 6 73 2 1 1 2 3*/","categories":[{"name":"Camp day1","slug":"Camp-day1","permalink":"http://aoudad.cn/categories/Camp-day1/"}],"tags":[{"name":"三分","slug":"三分","permalink":"http://aoudad.cn/tags/三分/"}]},{"title":"Camp Day4 D 欧拉回路","slug":"Camp-Day4-D-欧拉回路","date":"2019-02-14T07:47:43.000Z","updated":"2019-02-15T07:51:50.828Z","comments":true,"path":"2019/02/14/Camp-Day4-D-欧拉回路/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day4-D-欧拉回路/","excerpt":"","text":"题意描述给出一张$n$行$m$列的网格图（$n$条水平线，$m$条竖直线），要求你给图中的每一条边定向，并且规定每条边允许的通过次数（$\\geq 1$），使得最后得到的图存在一条欧拉回路（一条通过所有的边的回路，且每通过条边的次数=允许通过次数），我们要使每条边的通过次数之和最小。我们本来需要你给出具体的构造方案。如果存在多种方案，输出任意一组即可。但是现在我们只需要你输出最值即可。 Input一行$2$个数$n$,$m$($2 \\leq n,m \\leq 1000$)。 Output给出一个数$ans$，表示最小权值和。 Sample Input3 3 Sample Output16 思路：初始图是一个n*m的的网格，添加尽量少的重边，使得每个格点的度数都是偶数，所以只要考虑边边就可以了。然后分类讨论一下好像就完事了。不知道当时为啥想了那么久…… 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////int main()&#123; ll n, m; cin &gt;&gt; n &gt;&gt; m; ll ans = n*(m-1)+m*(n-1); if((n==3&amp;&amp;m==4)||(n==4&amp;&amp;m==3)) ans = 22; else if(n==2||m==2) &#123; ans += (m-2)/2*2;//n%=2; if(m%2) ans ++; ans += (n-2)/2*2;//n%=2; if(n%2) ans ++; &#125; else if(m%2&amp;&amp;n%2) &#123; ans += (n-2)/2*2;//n%=2; ans += (m-2)/2*2;//n%=2; ans+=4; &#125; else if(m%2==0&amp;&amp;n%2==0) &#123; ans += (n-1)/2*2;//n%=2; ans += (m-1)/2*2;//n%=2; &#125; else &#123; if(m%2==0) swap(n, m); ans += (n+m-4)+2; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://aoudad.cn/tags/欧拉回路/"},{"name":"分类讨论","slug":"分类讨论","permalink":"http://aoudad.cn/tags/分类讨论/"}]},{"title":"Camp Day3 I 石头剪刀布","slug":"Camp-Day3-I-石头剪刀布","date":"2019-02-14T07:33:05.000Z","updated":"2019-02-15T07:51:23.879Z","comments":true,"path":"2019/02/14/Camp-Day3-I-石头剪刀布/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day3-I-石头剪刀布/","excerpt":"","text":"题意描述可怜去观看了石头剪刀布的世界最高赛事 $WRSP$。今年的比赛一共有 $n$ 名选手参加，在比赛开始时，每名选手都会收到一张卡片，这张卡片上写着剪刀、石头、布中的一个。显然初始的卡牌分配情况有 $3^n$ 种。比赛场地一共有 $n$ 个座位，最开始第 $i$ 个选手坐在第 $i$ 个座位上。接下来发生了 $m$ 个事件，事件有两种： $1\\ x\\ y$，主办方撤去了第 $y$ 个座位，原来在第 $y$ 个座位上的选手 $b$ 需要和 $x$ 个座位上的选手 $a$ 利用他们的卡片进行一场石头剪刀布比赛，如果 $b$ 赢了 $a$，则选手 $a$ 被淘汰，选手 $b$ 坐到第 $x$ 个座位上；否则（打平或者 $b$ 输了），则选手 $b$ 被淘汰，选手 $a$ 的坐位不变。 $2\\ x$，可怜提出了一个问题，她想要知道在进行了之前的所有第 $1$ 类事件后，有多少种卡牌分配情况可以让第 $x$ 个选手到现在还没有被淘汰。 Input第一行输入两个整数 $n,m$($1 \\leq n,m \\leq 2 \\times 10^5)$，表示选手个数和事件个数。接下来 $m$ 行，每行描述了一个事件。如果是第一类事件，则输入三个整数 $1\\ x\\ y$($1 \\leq x,y \\leq n, x \\neq y$) 且这两个座位在之前没有被撤去；如果是第二类事件，则输入两个整数 $2\\ x(1 \\leq x \\leq n)$。 Output对于每个第二类事件，输出一行一个整数，表示这个选手还没有被淘汰的分配情况个数对 $998244353$ 取模后的值。 Sample Input3 52 11 2 12 11 2 32 1 Sample Output2796 思路：类似带权并查集。首先可以注意到比赛过程是一个树结构，而我们要维护的就是每个人一共参加了多少次比赛，以及一共有多少次主场作战，分别记为$cnt_x$和$w_i$，那么当我们询问$x$时，答案就是$3^{n-cnt_x}*2^{w_x}$，这个很容易得到的。问题就在于怎么维护$cnt$和$w$，可以使用并查集，每个节点打一个$cnt$和$w$，那么对于一个节点，他到根节点这条路径上所有的cnt和w加起来就是我们要的值了，每次给一个$x$和$y$，$y$向$x$连，然后$y$上维护的值就减去$x$上维护的值，类似差分。不会路径压缩，所以这里只有按秩合并的写法。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define SZ(x) (int)(x.size())#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;const ll mod = 998244353;ll qp(ll b, ll n)&#123;ll r=1;for(;n;n&gt;&gt;=1,b=b*b%mod)if(n&amp;1)r=r*b%mod;return r;&#125;int p[maxn], cnt[maxn], w[maxn], sz[maxn];int f(int x)&#123;return x==p[x]?x:f(p[x]);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1;i&lt;=n;++i) p[i]=i, sz[i]=1; while(m--) &#123; int opt, x, y; scanf(\"%d\", &amp;opt); if(opt==1) &#123; scanf(\"%d%d\", &amp;x, &amp;y); int fx = f(x), fy = f(y); cnt[fx]++;cnt[fy]++;w[fx]++; if(sz[fx]&lt;sz[fy]) swap(fx, fy); p[fy] = fx;sz[fx]+=sz[fy]; cnt[fy] -= cnt[fx]; w[fy] -= w[fx]; &#125; else &#123; scanf(\"%d\", &amp;x); int fx = f(x);// error(x, cnt[x], w[x]); int tmp = cnt[fx], t2=x;while(t2!=p[t2])tmp+=cnt[t2], t2=p[t2]; ll res = qp(3, n-tmp); tmp = w[fx], t2=x;while(t2!=p[t2])tmp+=w[t2], t2=p[t2]; res = res * qp(2, tmp)%mod; printf(\"%lld\\n\", res); &#125; &#125;&#125;","categories":[{"name":"Camp day3","slug":"Camp-day3","permalink":"http://aoudad.cn/categories/Camp-day3/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://aoudad.cn/tags/并查集/"}]},{"title":"Camp Day7 E 线性探查法","slug":"Camp-Day7-E-线性探查法","date":"2019-02-13T16:53:46.000Z","updated":"2019-02-15T07:52:55.583Z","comments":true,"path":"2019/02/14/Camp-Day7-E-线性探查法/","link":"","permalink":"http://aoudad.cn/2019/02/14/Camp-Day7-E-线性探查法/","excerpt":"","text":"题意描述在大学里选修过数据结构的同学大部分都知道 $hash$ 算法的线性探查法：假设有一个元素互不相同的正整数数组 $a[1\\dots n]$，我们用以下方法得到数组 $b[0\\dots n-1]$：初始时 $b[i]$ 都为 $-1$，我们对 $i=1\\dots n$依次插入$a[i]$，假设现在要插入的数是 $x$，首先我们找到 $x \\% n$ 这个位置，如果 $b[x\\%n]=-1$，则令 $b[x \\% n]=x$，之后结束这次插入；否则看 $b[(x+1) \\% n]$ 是否等于 $−1$，如果等于则令 $b[(x+1) \\% n]=x$，如果不等于，则继续看 $(x+2) \\% n\\dots$，直到找到一个位置。完成所有插入后，我们会得到一个数组 $b$，现在给定这个数组 $b$，你需要求一个字典序最小的 $a[1\\dots n]$ Input第一行一个正整数 $n (1\\leq n\\leq 10^5)$第二行 $n$ 个互不相同的正整数，表示 $b[0…n-1]$，$(1\\leq b[i]\\leq 2\\times 10^9)$输入数据保证一定有解 Output输出 $n$ 个正整数，表示字典序最小的 $a[1…n]$字典序的比较是先比较 $a[1]$，再比较 $a[2]\\dots$以此类推 Sample Input—-520 16 12 8 4 Sample Output4 8 12 16 20 思路：【是$2018$第四场牛客多校的$J$题弱化版】对于第$i$个位置上的值$a[i]$，设$x=a[i]%n$，如果$x!=i$，那么因为现在$a[i]$是在i位置，所以处于$x,\\dots, i-1$这些位置上的值都应该在$a[i]$之前插入，我们可以从这些位置往$a[i]$连一条有向边，用$堆/优先队列$做一次拓扑排序就好了，但是这样的话边数可能是$O(n^2)$的，这道题是没办法直接建图的，那么因为都是前面一个连续的区间往一个点连边，我们可以考虑将一段段区间抽象成一个个点，这样就有$2*n$个顶点，再来连边，这样边数可以证明是$O(n)$的，然后既然是区间，用个线段树来写就可以了。这里还用到了优先队列的自定义排序。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define SZ(x) (int)(x.size())#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;int a[maxn];int tot, val[maxn&lt;&lt;2], d[maxn&lt;&lt;2], v[maxn&lt;&lt;2];vector&lt;int&gt; G[maxn&lt;&lt;2];void build(int l, int r, int rt)&#123; val[rt]=-1; if(l==r)&#123;val[rt]=a[l];v[l]=rt;return ;&#125; int mid = (l+r)&gt;&gt;1; build(lson);build(rson); G[rt&lt;&lt;1].eb(rt);G[rt&lt;&lt;1|1].eb(rt); d[rt]+=2;&#125;void update(int L, int R, int x, int l, int r, int rt)&#123; if(R&lt;0)return; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;G[rt].eb(x);++d[x];return;&#125; int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(L, R, x, lson); if(mid &lt; R) update(L, R, x, rson);&#125;struct cmp&#123;bool operator()(int x, int y)&#123;return val[x]&gt;val[y];&#125;&#125;;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=0;i&lt;n;++i) scanf(\"%d\", a+i); build(0, n-1, 1); priority_queue&lt;int , vector&lt;int&gt;, cmp &gt; q; for(int i=0;i&lt;n;++i) &#123; if(a[i]%n==i)&#123;q.push(v[i]);continue;&#125; int x = a[i]%n; if(x&lt;i) update(x, i-1, v[i], 0, n-1, 1); else update(0, i-1, v[i], 0, n-1, 1), update(x, n-1, v[i], 0, n-1, 1); &#125; vector&lt;int&gt; res; while(!q.empty()) &#123; int x = q.top();q.pop(); if(val[x]!=-1)res.eb(val[x]); for(int i=0;i&lt;G[x].size();++i) &#123; int v = G[x][i]; if(--d[v]==0)q.push(v); &#125; &#125; for(int i=0;i&lt;SZ(res);++i) printf(\"%d%c\", res[i], \" \\n\"[i+1==SZ(res)]);&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://aoudad.cn/tags/拓扑排序/"}]},{"title":"Camp Day4 I 咆咆咆哮","slug":"Camp-Day4-I-咆咆咆哮","date":"2019-02-13T12:16:15.000Z","updated":"2019-02-15T07:52:15.891Z","comments":true,"path":"2019/02/13/Camp-Day4-I-咆咆咆哮/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day4-I-咆咆咆哮/","excerpt":"","text":"题意描述$wls$手上有$n$张牌，每张牌他都可以选择召唤一个攻击力为$a_i$的生物，或者使得场上所有生物的攻击力加$b_i$。请问如何抉择，使得场攻（场上生物攻击力的总和）最高。$wls$可以任意选择出这$n$张牌的顺序。 Input第一行一个整数$n$。接下来$n$行，每行两个整数$a_i$和$b_i$​。$1 \\leq n \\leq 100000$$0 \\leq a_i, b_i \\leq 1000000$ Output一行一个整数表示答案。 Sample Input320 115 1020 2 Sample Output60 思路：乍一看像是01分数规划……假设用x张来攻击，设所有卡片总攻击为sum，那么对于每张卡片，我选它来咆哮的贡献是$b_ix-a_i$，总攻击就是sum+\\Sigma_{最大的n-x个值}随着x的上升，单个的值单调上升，$n-x$单调下降，所以这个函数大概应该可能猜测是个凸函数。三分x。每次chk的复杂度是$O(logn)$，因为这个值可能很大，所以不能用基数排序。总复杂度是$O(nlog^2n)$。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;int a[maxn],b[maxn], n;ll chk(int x)&#123; ll res = 0; vector&lt;ll&gt; tmp(n+1);tmp[0]=INFLL; for(int i=1;i&lt;=n;++i) tmp[i] = b[i]*1LL*x-a[i]; sort(all(tmp), greater&lt;ll&gt;()); for(int i=1;i&lt;=n-x;++i) res+=tmp[i]; return res;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao cin &gt;&gt; n;ll res = 0; for(int i=1;i&lt;=n;++i) &#123;cin &gt;&gt; a[i] &gt;&gt; b[i];res+=a[i];&#125; int L = 0, R = n, mid, midd; while(L+1&lt;R) &#123; mid = (L+R)/2;midd=(mid+R)/2; if(chk(mid)&gt;chk(midd)) R = midd - 1; else L = mid; &#125; cout &lt;&lt; res + max(chk(L), chk(R)) &lt;&lt; endl;&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"三分","slug":"三分","permalink":"http://aoudad.cn/tags/三分/"}]},{"title":"Camp Day5 J spesialJudge","slug":"Camp-Day5-J-specialJudge","date":"2019-02-13T11:36:39.000Z","updated":"2019-02-15T07:52:23.993Z","comments":true,"path":"2019/02/13/Camp-Day5-J-specialJudge/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day5-J-specialJudge/","excerpt":"","text":"题意描述有一个$n$个点$m$条边的图画在了平面上，你想知道有多少对边之间对应的线段相交。特别地，对于图中的一对边，如果有公共点且只在对应的端点相交，那么我们不认为这对边相交。 Input第一行两个整数$n, m(1\\leq n\\leq 1000, 1\\leq m\\leq 2000)$，表示点数和边数。接下来$m$行，每行两个整数$(u,v)$表示一条$u$与$v$之间的无向边，保证图中没有重边和自环。接下来$n$行，每行两个整数$x_i, y_i$ ($0\\leq x_i, y_i\\leq 10^9$)表示图中第$i$个顶点的坐标，保证所有的坐标两两不同。 Output输出一个整数，表示答案。 Sample Input4 61 21 31 42 32 43 40 00 11 11 0 Sample Output1 思路：注意除了共顶点一样都算相交。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e3+7;int sgn(double x)&#123;if(x&gt;eps)return 1;if(x&lt;-eps)return -1;return 0;&#125;struct Point&#123; ll x, y; Point(ll _x=0, ll _y=0):x(_x),y(_y)&#123;&#125; friend Point operator-(const Point&amp;a, const Point&amp;b)&#123;return Point(a.x-b.x, a.y-b.y);&#125; friend Point operator+(const Point&amp;a, const Point&amp;b)&#123;return Point(a.x+b.x, a.y+b.y);&#125; friend ll dot(const Point&amp;a, const Point&amp;b)&#123;return a.x*b.x+a.y*b.y;&#125; friend ll cross(const Point &amp;a, const Point&amp;b)&#123;return a.x*b.y-a.y*b.x;&#125; ll sqr()&#123;return dot(*this, *this);&#125; double len()&#123;return sqrt(len());&#125; friend bool operator==(const Point &amp;a, const Point &amp;b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125; friend bool operator!=(const Point &amp;a, const Point &amp;b)&#123;return !(a==b);&#125;&#125;p[maxn];struct Line&#123;Point s, e;&#125;;int cmp(db a, db b)&#123;return sgn(a-b);&#125;int intersect(db l1,db r1,db l2,db r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return cmp(r1,l2)!=-1&amp;&amp;cmp(r2,l1)!=-1;&#125;int checkSS(Point k1,Point k2,Point k3,Point k4)&#123; if(k1==k3) &#123;return cross(k2-k1, k4-k1)==0&amp;&amp;dot(k2-k1, k4-k1)&gt;0;&#125; if(k1==k4) &#123;return cross(k2-k1, k3-k1)==0&amp;&amp;dot(k2-k1, k3-k1)&gt;0;&#125; if(k2==k3) &#123;return cross(k1-k2, k4-k2)==0&amp;&amp;dot(k1-k2, k4-k2)&gt;0;&#125; if(k2==k4) &#123;return cross(k1-k2, k3-k2)==0&amp;&amp;dot(k1-k2, k3-k2)&gt;0;&#125; return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp; sgn(cross(k3-k1,k4-k1))*sgn(cross(k3-k2,k4-k2))&lt;=0&amp;&amp; sgn(cross(k1-k3,k2-k3))*sgn(cross(k1-k4,k2-k4))&lt;=0;&#125;int u[maxn], v[maxn];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i=1;i&lt;=m;++i)&#123;cin &gt;&gt; u[i] &gt;&gt; v[i];&#125; for(int i=1;i&lt;=n;++i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; int cnt = 0; for(int i=1;i&lt;=m;++i) for(int j=i+1;j&lt;=m;++j) cnt += checkSS(p[u[i]], p[v[i]], p[u[j]], p[v[j]]); cout &lt;&lt; cnt &lt;&lt; endl;&#125;","categories":[{"name":"Camp day5","slug":"Camp-day5","permalink":"http://aoudad.cn/categories/Camp-day5/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://aoudad.cn/tags/计算几何/"}]},{"title":"Camp Day1 F 爬爬爬山","slug":"Camp-Day1-F-爬爬爬山","date":"2019-02-13T11:25:11.000Z","updated":"2019-02-15T07:50:38.778Z","comments":true,"path":"2019/02/13/Camp-Day1-F-爬爬爬山/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day1-F-爬爬爬山/","excerpt":"","text":"题意描述爬山是$wls$最喜欢的活动之一。在一个神奇的世界里，一共有$n$座山，$m$条路。$wls$初始有$k$点体力，在爬山的过程中，他所处的海拔每上升$1m$，体力会减$1$点，海拔每下降$1m$，体力会加一点。现在$wls$想从$1$号山走到$n$号山，在这个过程中，他的体力不能低于$0$，所以他可以事先花费一些费用请$dls$把某些山降低，将一座山降低$l$米需要花费$l*l$的代价，且每座山的高度只能降低一次。因为$wls$现在就在$1$号山上，所以这座山的高度不可降低。$wls$从$1$号山到$n$号山的总代价为降低山的高度的总代价加上他走过的路的总长度。$wls$想知道最小的代价是多少。 Input第一行三个整数$n$，$m$，$k$。接下来一行$n$个整数，第$i$个整数$h_i​$表示第i座山的高度。接下来$m$行，每行三个整数$x$，$y$，$z$表示$xy$之间有一条长度为$z$的双向道路。经过每条路时海拔是一个逐步上升或下降的过程。数据保证$1$号山和$n$号山联通。$1 \\leq n, k, h_i, z \\leq 100000$$1 \\leq m \\leq 200000$$1 \\leq x, y \\leq n$$x \\neq y$ Output一行一个整数表示答案。 Sample Input4 5 11 2 3 41 2 11 3 11 4 1002 4 13 4 1 Sample Output6 思路：将每个点拆成两个点，那么入点向出点连一条$max(0, H_i-H_0-k)^2$的边，跑一个最短路就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 10;const int maxm = 4e5 + 10;const ll inf = 1e18;int n, m, k;int h[maxn];vector&lt;pair&lt;int, ll&gt; &gt; g[maxn];struct qnode &#123; int v; ll dis; qnode(int v = 0, ll dis = 0) : v(v), dis(dis) &#123;&#125; bool operator &lt; (const qnode &amp;r) const &#123; return dis &gt; r.dis; &#125;&#125;;bool vis[maxn];ll dis[maxn];priority_queue&lt;qnode&gt; q;void dijk(int x) &#123; memset(vis, 0, sizeof(vis)); for(int i = 1; i &lt;= n * 2; i++) dis[i] = inf; dis[x] = 0; q.push(qnode(x, 0)); //vis[x] = 1; while(!q.empty()) &#123; qnode tmp = q.top(); q.pop(); int u = tmp.v; if(vis[u]) continue; vis[u] = 1; for(int i = 0; i &lt; g[u].size(); i++) &#123; int v = g[u][i].first; ll w = g[u][i].second; if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(qnode(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123; int a = __gcd(2, 3); scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]); for(int i = 1; i &lt;= n; i++) &#123; g[i].push_back(make_pair(i + n, (ll)max(0, h[i] - h[1] - k) * (ll)max(0, h[i] - h[1] - k))); &#125; for(int i = 1; i &lt;= m; i++) &#123; int x, y; ll z; scanf(\"%d%d%lld\", &amp;x, &amp;y, &amp;z); g[x + n].push_back(make_pair(y, z)); g[y + n].push_back(make_pair(x, z)); &#125; dijk(1); printf(\"%lld\\n\", dis[n * 2]);&#125;","categories":[{"name":"Camp day1","slug":"Camp-day1","permalink":"http://aoudad.cn/categories/Camp-day1/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://aoudad.cn/tags/最短路/"}]},{"title":"Camp Day7 C 斐波那契数列","slug":"Camp-Day7-C-斐波那契数列","date":"2019-02-13T09:47:40.000Z","updated":"2019-02-15T07:52:44.551Z","comments":true,"path":"2019/02/13/Camp-Day7-C-斐波那契数列/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day7-C-斐波那契数列/","excerpt":"","text":"题意描述定义 $Fib_n$​ 为斐波那契数列，$Fib_1=Fib_2=1$，$Fib_n=Fib_{n-1}+Fib_{n-2}~(n\\geq 3)$现在给定 $R$，你需要求 $\\sum_{n=1}^{R}(Fib_n\\&amp; (Fib_{n}-1))$由于答案可能很大，你只需要输出答案对 $998244353$ 取模后的值 Input第一行一个正整数 $T$ 表示数据组数 $(1\\leq T\\leq 10^4)$接下来 $T$ 行，每行一个正整数 $R$ ($1\\leq R\\leq 10^{18}$) Output输出 $T$ 行，每行一个整数表示答案 Sample Input435610000 Sample Output066634256642 思路：题目要求的那个东西，实际上就是\\Sigma_{i=1}^{n}(\\ Fib_i-lowbit(Fib_i)\\ )斐波那契的前n项和就是斐波那契数列的第n+2项，后面那个通过打表可以找到一些规律。只有 $n$ 是 $3$ 的倍数时，$F[n]$ 才是偶数当 $n=3k$，时，若 $k$ 是奇数，则 lowbit(F[n])=2否则lowbit(F[n])=lowbit(4k) 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IO/////// Macro ////////////////const ll mod = 998244353;struct M&#123; ll a[3][3]; M()&#123;for(int i=0;i&lt;3;++i)for(int j=0;j&lt;3;++j)a[i][j]=0;&#125; friend M operator*(const M&amp;x, const M&amp;y) &#123; M res; for(int i=0; i&lt;2; ++i) for(int j=0; j&lt;2; ++j) for(int k=0; k&lt;2; ++k) &#123; res.a[i][j] += x.a[i][k] * y.a[k][j]; res.a[i][j] %= mod; &#125; return res; &#125;&#125;;ll q_p(ll base, ll n)&#123; ll res = 1; while(n) &#123; if(n&amp;1) res = base * res % mod; base= base * base % mod; n &gt;&gt;= 1; &#125; return res;&#125;ll Mqp(ll n)&#123; M res; M base;base.a[0][0]=base.a[0][1]=base.a[1][0]=res.a[0][0]=1; while(n) &#123; if(n&amp;1) res = base * res; base = base * base; n &gt;&gt;= 1; &#125; return res.a[0][0];&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; ll R; cin&gt;&gt; R; ll ans = 0; ans = Mqp(R+1)-1; ll tmp = R; ll cnt = tmp/3*2+tmp%3; tmp -= cnt; ans -= cnt; int now = 1; while(tmp) &#123; if(now==2)++now; ll cnt = (tmp+1)/2; tmp -= cnt; ans -= q_p(2, now) * cnt; ans %= mod; ++now; &#125; cout &lt;&lt; (ans%mod+mod)%mod &lt;&lt; endl; &#125;&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://aoudad.cn/tags/矩阵快速幂/"},{"name":"数学","slug":"数学","permalink":"http://aoudad.cn/tags/数学/"}]},{"title":"Camp Day7 A 迷宫","slug":"Camp-Day7-A-迷宫","date":"2019-02-13T09:31:51.000Z","updated":"2019-02-15T07:52:30.008Z","comments":true,"path":"2019/02/13/Camp-Day7-A-迷宫/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day7-A-迷宫/","excerpt":"","text":"题意描述有一个 $n$ 个点 $n-1$ 条边的无向连通图迷宫，其中有些点上面有人现在所有人的目标都是逃离这个迷宫，而迷宫的出口是 $1$ 号点，每一时刻，会依次发生以下的事情： 在点 $x$ 上的人选择一个点 $f(x)$ 作为目标，要求 $f(x)$ 必须是 $x$，或者与 $x$ 有边相连的点，且对于 $x\\neq y$，有 $f(x)\\neq f(y)$ 在点 $x$ 上的人移动到 $f(x)$ 在点 $1$ 号点上的人成功逃脱，从这个游戏里消失现在你需要求的是：让所有人都成功逃脱至少需要多少时间 Input第一行一个正整数 $n$ ($1\\leq n\\leq 10^5$)第二行 $n$ 个整数 $a_1\\dots a_n$​，$a_i=1$ 表示一开始第 $i$ 个点上有人，$a_i=0$ 则表示没有，保证 $a_1=0$接下来 $n-1$ 行，每行两个正整数 $(u,v)$ 描述图中的一条无向边 Output输出让所有人成功逃脱至少需要多少时间 Sample Input40 0 1 11 22 33 4 Sample Output3 思路：如果我们按照时间列一个表，每个时刻对应一个值，这个值是$0$就表明没有人出来，$1$就表示有人出来。那么我们就是要求最远的值是$1$的时刻。考虑最后一段连续的$1$，这个段的开头那个$1$一定是从头到尾都是一路上来没有阻挡的，所以他对应的时刻就是这个$1$的深度(记为$x$)，而后面的这段$1$的长度就是深度小于等于$x$的节点的数量，所以只要预处理出深度，然后枚举每个有人节点的深度就行了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;vector&lt;int&gt; G[maxn];int sum[maxn], a[maxn];int dfs(int u, int f, int h)&#123; if(a[u])++sum[h]; for(int i=0;i&lt;G[u].size();++i) if(G[u][i]!=f) dfs(G[u][i], u, h+1);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; a[i]; for(int i=1;i&lt;n;++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].eb(v); G[v].eb(u); &#125; dfs(1, 0, 0); int x;for(int i=n;i&gt;=0;--i) if(sum[i])&#123;x=i;break;&#125; for(int i=2;i&lt;=x;++i) sum[i] += sum[i-1]; int res = 0; for(int i=1;i&lt;=x;++i)//为什么不是n？考虑这个数据 4 0 1 0 0 1 2 2 3 3 4 res = max(res, i-1+sum[x]-sum[i-1]); cout &lt;&lt; res &lt;&lt; endl;&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Camp Day4 A 夺宝奇兵","slug":"Camp-Day4-A-夺宝奇兵","date":"2019-02-13T06:13:57.000Z","updated":"2019-02-15T07:51:32.084Z","comments":true,"path":"2019/02/13/Camp-Day4-A-夺宝奇兵/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day4-A-夺宝奇兵/","excerpt":"","text":"题意描述$wls$正在玩一个寻宝游戏。宝藏一共有$n$种，都藏在一个$m$行$m$列的网格中。每种宝藏都恰好有两个。$wls$只能沿着网格走（上下左右四个方向）。他想依次获得$1\\dots n$类宝藏，然后再以$n\\dots 1$的顺序获得剩下的宝藏。$wls$可以从任意点出发。当$wls$到达某个宝藏的位置时，他可以选择取或不取这个宝藏。请问他最少要移动多少距离？ Input第一行两个整数$n$，$m$。接下来$n$组，每组两行表示一类宝藏，每行两个整数$x$，$y$表示一个宝藏的坐标。$1 \\leq n, m \\leq 100000$$1 \\leq x, y \\leq m$ Output一行一个整数表示答案。 Sample Input4 101 12 23 34 4 Sample Output10 思路：可以看成是两个人分别从1走到n的最近距离。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 1e5+7;const ll mod = 1e9+7;ll p[maxn], fac[maxn];ll q_p(ll b, ll n)&#123;ll r=1;for(;n;n&gt;&gt;=1,b=b*b%mod)if(n&amp;1)r=r*b%mod;return r;&#125;int d(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123;return abs(a.fi-b.fi)+abs(a.se-b.se);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, int&gt; &gt; a(n+1), b(n+1); for(int i=1;i&lt;=n;++i) cin &gt;&gt; a[i].fi &gt;&gt; a[i].se &gt;&gt; b[i].fi &gt;&gt; b[i].se; ll res = 0; for(int i=2;i&lt;=n;++i) res += min(d(a[i],a[i-1])+d(b[i],b[i-1]), d(a[i],b[i-1])+d(b[i], a[i-1])); cout &lt;&lt; res + d(a[n], b[n]) &lt;&lt; endl;&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://aoudad.cn/tags/思维/"}]},{"title":"Camp Day4 G 置置置换","slug":"Camp-Day4-G-置置置换","date":"2019-02-13T05:24:35.000Z","updated":"2019-02-15T07:52:07.935Z","comments":true,"path":"2019/02/13/Camp-Day4-G-置置置换/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day4-G-置置置换/","excerpt":"","text":"题意描述$wls$有一个整数$n$，他想请你算一下有多少$1\\dots n$的排列（$permutation$）满足:对于所有的$i$($2 \\le i \\le n$)，若$i$为奇数，则$a[i - 1] \\lt a[i]$，否则$a[i - 1] \\gt a[i]$。请输出答案$mod \\ 1e9 + 7$。 Input一行一个整数$n$。$1 \\le n \\le 1000$ Output一行一个整数表示答案。 Sample Input3 Sample Output2 思路：转而考虑随机一个长度为$n$的排列，这个排列满足题意的概率。设$f_i$表示长度为i，随机出来是这样的排列的概率。那么可以得到这样的一个转移f_i=\\frac{1}{i}\\Sigma_{j是奇数且j \\leq i}\\ \\ f_{j-1}*f_{i-j}表示第i个位置是i（最大值）且左半部分右半部分都是满足题意的排列的概率，那么方案数就是概率乘以阶乘了。做法是$O(n^2)$的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 1e5+7;const ll mod = 1e9+7;ll p[maxn], fac[maxn];ll q_p(ll b, ll n)&#123;ll r=1;for(;n;n&gt;&gt;=1,b=b*b%mod)if(n&amp;1)r=r*b%mod;return r;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n; cin &gt;&gt; n; p[0]=fac[0]=1; for(int i=1;i&lt;=1000;++i) fac[i] = fac[i-1] * i % mod; for(int i=1;i&lt;=n;++i) &#123; ll tmp = 0, inv = q_p(i, mod-2); for(int j=1;j&lt;=i;j+=2) &#123; tmp += inv * p[j-1] % mod * p[i-j] % mod; tmp %= mod; &#125; p[i] = tmp; &#125; for(int i=1;i&lt;=n;++i) p[i] = p[i] * fac[i] % mod; cout &lt;&lt; p[n] &lt;&lt; endl;&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"排列","slug":"排列","permalink":"http://aoudad.cn/tags/排列/"}]},{"title":"Camp Day4 C 最小边覆盖","slug":"Camp-Day4-C-最小边覆盖","date":"2019-02-13T04:47:04.000Z","updated":"2019-02-15T07:51:41.491Z","comments":true,"path":"2019/02/13/Camp-Day4-C-最小边覆盖/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day4-C-最小边覆盖/","excerpt":"","text":"题意描述给定一个无向连通简单图$G$（简单图的意思是无自环无重边），它的一个边覆盖是$G$的边集$E$的子集$S$，使得$G$的点集$V$中的任意一个点都出现在$S$中的至少一条边中。这个边覆盖的大小定义为$S$包含的边数。如果$S$是所有$G$的边覆盖中最小的，则称$S$是图$G$的最小边覆盖。$Gallai$证明了对任意无向连通简单图，它的最大匹配的大小加上最小边覆盖的大小一定等于它的点数。于是，为了求出一个无向简单图的最小边覆盖，我们可以首先使用带花树算法求出它的最大匹配，然后仿照$Gallai$定理的证明构造出一个最小边覆盖。这道题给定了无向连通简单图$G$的点集，和图$G$的边的一个子集$S$，但没有给出边集$E$。试判断SS有没有可能是图$G$的最小边覆盖。 Input第一行两个正整数$n$和$m$表示图$G$的点数和$S$的大小（$1\\le n\\le 200000,1\\le m\\le 300000$）。接下来$m$行每行两个正整数$a,b$表示$S$中的一条边${a,b}$（点从$1$到$n$编号，保证$S$中没有自环和重边）。 Output如果存在一个无向连通图$G$，使得$G$的点集是${1,\\ldots,n}$，且$G$的边集包含$S$，且$S$是$G$的一个最小边覆盖，则输出”$Yes$”。否则输出”$No$”。 Sample Input4 21 23 4 Sample OutputYes Sample Input4 31 22 33 4 Sample OutputNo 思路：分为两步，判断是不是一个边覆盖，是不是最小的边覆盖。如果所有的点的度都不为0，那就是一个边覆盖。如果对于某条边，删除它剩下的边集也是一个边覆盖，那它就不是最小的。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define all(x) x.begin(),x.end()#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//void print(__int128 x)&#123;if(x&gt;9)print(x/10);putchar('0'+x%10);&#125;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;int d[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, int&gt; &gt; E; for(int i=0;i&lt;m;++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; E.eb(mp(u, v)); ++d[u], ++d[v]; &#125; int ok = 1; for(int i=1;i&lt;=n;++i) if(d[i]==0)ok=0; for(int i=0;i&lt;m;++i) &#123; int u = E[i].fi, v=E[i].se; if(d[u]&gt;1&amp;&amp;d[v]&gt;1)ok=0; &#125; puts(ok?\"Yes\":\"No\");&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://aoudad.cn/tags/思维/"},{"name":"图论","slug":"图论","permalink":"http://aoudad.cn/tags/图论/"}]},{"title":"Camp Day3 G 排列","slug":"Camp-Day3-G-排列","date":"2019-02-12T16:48:50.000Z","updated":"2019-02-15T07:51:15.215Z","comments":true,"path":"2019/02/13/Camp-Day3-G-排列/","link":"","permalink":"http://aoudad.cn/2019/02/13/Camp-Day3-G-排列/","excerpt":"","text":"题意描述说出来你可能不信，这场比赛居然有签到题。定义长度为 $n$ 的排列 $p$ 的前缀最小值数组为一个长度为 $n$ 的数组 $A(p)$，其中 $A(p)[i] = \\min \\ p[j] (1 \\leq j \\leq i)$。可怜定义排列 $p$ 的长度为 $i$ 的前缀小于长度为 $j$ 的前缀当且仅当 $A(p)_i \\lt A(p)_j$ 或者 $A(p)_i = A(p)_j$​ 且 $i \\lt j$。利用这个小于关系，可怜求得了另一个长度为 $n$ 的排列 $q$，其中 $q_i$ 表示排列 $p$ 第 $i$ 小的前缀的长度。可怜是个粗心的女孩子，因为一些机缘巧合，可怜丢失了排列 $p$。于是可怜希望能够通过排列 $q$ 来还原出排列 $p$。满足条件的排列 $p$ 可能有很多，可怜希望你能求出它们中字典序最小的那个。长度为 $n$ 的排列 $x$ 在字典序上小于长度为 $n$ 的排列 $y$ 当且仅当存在下标 $i \\in [1,n]$ 满足 $x_i \\lt y_i$​ 且对更小的下标 $j \\in [1,i)$，都有 $x_i=y_i$。 Input第一行输入一个整数 $n(1 \\leq n \\leq 10^5)$，表示排列的长度。第二行输入一个长度为 $n$ 的排列 $q$。输入保证存在至少一个满足条件的排列 $p$。 Output输出一行一个长度为 $n$ 的排列，表示字典序最小的满足条件的排列 $p$。 Sample InputSample Output题意：对于一个排列$p$，定义$A[]$是这个排列的前缀最小值数组，对这样的$A$，可以得到一个排列$q$，排列$q$的第$i$个位置上的值表示A数组第$i$小的前缀长度，其中定义一个前缀比另一个前缀小当且仅当这个位置上的值更小或者相等且更短。给定排列$q$，构造原来的q. 思路：$q$排列应该是一段一段的形式的，每一段都是单调上升形式的。所以实际上只要把$1$到$n$依次填进去就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const int maxn = 605000;int p[maxn], a[maxn], ans[maxn];int main()&#123; int n; cin &gt;&gt; n; int len = 1; for(int i=1;i&lt;=n;++i) cin &gt;&gt; p[i]; for(int i=1;i&lt;=n;++i) &#123; if(p[i]&lt;p[i-1]) a[p[i]] = ++len; else a[p[i]] = a[p[i-1]]; &#125; set&lt;int&gt; s; for(int i=1;i&lt;=n;++i) s.insert(i);// for(int i=1;i&lt;=n;++i) cout &lt;&lt; a[i] &lt;&lt; ' ';cout&lt;&lt; endl; for(int i=1;i&lt;=n;++i) &#123; int x = *s.lower_bound(a[i]); s.erase(x); ans[i] = x; &#125; for(int i=1;i&lt;=n;++i) printf(\"%d%c\", ans[i], \" \\n\"[i==n]);&#125;","categories":[{"name":"Camp day3","slug":"Camp-day3","permalink":"http://aoudad.cn/categories/Camp-day3/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://aoudad.cn/tags/构造/"}]},{"title":"Camp Day4 F 小小马","slug":"Camp-Day4-F-小小马","date":"2019-02-12T15:55:41.000Z","updated":"2019-02-15T07:52:00.077Z","comments":true,"path":"2019/02/12/Camp-Day4-F-小小马/","link":"","permalink":"http://aoudad.cn/2019/02/12/Camp-Day4-F-小小马/","excerpt":"","text":"题意描述$wls$有一张$n$行$m$列的国际象棋棋盘，上面有一匹马。现在$wls$想知道存不存在一条从起点到终点的路径，使得经过的白点和黑点一样多（起点和终点也会计算在内）？马只能走马步，假设马现在在$(x,y)$上，它只能跳到$(x-2,y-1)$, $(x-2,y+1)$, $(x-1,y-2)$, $(x-1,y+2)$, $(x+1,y-2)$, $(x+1,y+2)$, $(x+2,y-1)$, $(x+2,y+1)$八个格子。无论什么时候，马都不能跳出棋盘。对于点$(x,y)$，如果$xy$的奇偶性相同，则为黑格，否则为白格。 Input第一行两个整数$n$，$m$。第两行两个整数$Sx$，$Sy$表示起点。第三行两个整数$Ex$，$Ey$表示终点。$2 \\leq n, m \\leq 1000000$$1 \\leq Sx, Ex \\leq n$$1 \\leq Sy, Ey \\leq m$起点 != 终点 Output如果存在这样的路径，输出$Yes$，否则输出$No$。 Sample Input10 101 110 10 Sample OutputNo 题意：$n*m$的棋盘，问是否能从起点跳到终点，且经过的黑白点数相同。 思路：显然必要条件是起点终点颜色不同，然后特殊考虑一下$3*3$以及小于$3$的好像就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, ex, ey;int main() &#123; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%d%d%d%d\", &amp;sx, &amp;sy, &amp;ex, &amp;ey); int tmp = abs(ex - sx) + abs(ey - sy); if(tmp % 2 == 0) &#123; printf(\"No\\n\"); &#125; else &#123; if(n == 2 &amp;&amp; m == 2) printf(\"No\\n\"); else if(n == 2) &#123; if(abs(sx - ex) != 0 &amp;&amp; abs(sy - ey) % 2 == 0) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; else if(m == 2) &#123; if(abs(sx - ex) % 2 == 0 &amp;&amp; abs(sy - ey) != 0) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; else if(n == 3 &amp;&amp; m == 3) &#123; if(sx == 2 &amp;&amp; sy == 2) printf(\"No\\n\"); else if(ex == 2 &amp;&amp; ey == 2) printf(\"No\\n\"); else printf(\"Yes\\n\"); &#125; else printf(\"Yes\\n\"); &#125;&#125;","categories":[{"name":"Camp day4","slug":"Camp-day4","permalink":"http://aoudad.cn/categories/Camp-day4/"}],"tags":[{"name":"分类讨论","slug":"分类讨论","permalink":"http://aoudad.cn/tags/分类讨论/"}]},{"title":"Camp Day7 G 抢红包机器人","slug":"Camp-Day7-G-抢红包机器人","date":"2019-02-12T15:48:25.000Z","updated":"2019-02-15T07:53:01.296Z","comments":true,"path":"2019/02/12/Camp-Day7-G-抢红包机器人/","link":"","permalink":"http://aoudad.cn/2019/02/12/Camp-Day7-G-抢红包机器人/","excerpt":"","text":"题意描述众所周知，camp群里有很多抢红包的机器人，wls对这种号感到很愤怒，他决定把这些机器人全部找出来后踢掉。wls 研究后发现，由于人的手速是拼不过脚本的，所以如果某个号在某个红包里抢得比某个机器人快，那么这个号肯定也是机器人。现在 wls 想知道，在群里一定有机器人的情况下，camp 群里至少有几个机器人。注：机器人并不是每次都会抢红包，而且由于网速问题机器人抢红包的速度也不是固定的，所以有可能有时机器人 a 比 b 快，有时 b 比 a 快。 Input第一行两个正整数 $n,m$，分别表示群员数量和 wls 发的红包数量接下来 $m$ 行，描述这 $m$ 个红包，每行一开始一个正整数 $k$，表示抢了这个红包的人的数量，之后 $k$ 个互不相同的 $[1,n]$ 内的正整数，表示按照先后顺序给出了抢这个红包的群员的编号。$1\\leq n,m\\leq 100$，$1\\leq k\\leq n$ Output输出一个整数，表示群里至少有几个机器人 Sample Input4 23 1 2 32 3 1 Sample Output1 题意：思路：建图，作强连通分量，找到最小的入度为0的强连通分量，它的大小就是答案。这个应该是正解，但是好像数据有点弱，不考虑入度为0这个限制好像也可以ac……不管了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 20010;//点数const int MAXM = 50010;//边数struct Edge&#123; int to,next;&#125;edge[MAXM];int head[MAXN],tot;int Low[MAXN],DFN[MAXN],Stack[MAXN],Belong[MAXN];//Belong 数组的值是int Index,top;int scc;//强连通分量的个数bool Instack[MAXN];int num[MAXN];//各个强连通分量包含点的个数，数组编号 1 ∼ scc//num 数组不一定需要，结合实际情况void addedge(int u,int v)&#123; edge[tot].to = v;edge[tot].next = head[u];head[u] = tot++;&#125;void Tarjan(int u)&#123; int v; Low[u] = DFN[u] = ++Index; Stack[top++] = u; Instack[u] = true; for(int i = head[u];i != -1;i = edge[i].next)&#123; v = edge[i].to; if( !DFN[v] )&#123; Tarjan(v); if( Low[u] &gt; Low[v] )Low[u] = Low[v]; &#125; else if(Instack[v] &amp;&amp; Low[u] &gt; DFN[v]) Low[u] = DFN[v]; &#125; if(Low[u] == DFN[u])&#123; scc++; do&#123; v = Stack[--top]; Instack[v] = false; Belong[v] = scc; num[scc]++; &#125; while( v != u); &#125;&#125;void solve(int N)&#123; memset(DFN,0,sizeof(DFN)); memset(Instack,false,sizeof(Instack)); memset(num,0,sizeof(num)); Index = scc = top = 0; for(int i = 1;i &lt;= N;i++) if(!DFN[i]) Tarjan(i);&#125;void init()&#123; tot = 0; memset(head,-1,sizeof(head));&#125;int main() &#123; init(); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; int k; cin &gt;&gt; k; int x, y; for(int j = 1; j &lt;= k; j++) &#123; if(j != 1) y = x; cin &gt;&gt; x; if(j != 1) addedge(y, x); &#125; &#125; solve(n); int ans = 0x3f3f3f3f; for(int i = 1; i &lt;= scc; i++) ans = min(ans, num[i]); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[{"name":"Camp day7","slug":"Camp-day7","permalink":"http://aoudad.cn/categories/Camp-day7/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://aoudad.cn/tags/dfs/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://aoudad.cn/tags/强连通分量/"}]},{"title":"CodeforceDiv2 D Flood Fill","slug":"CodeforceDiv2-D-Flood-Fill","date":"2019-02-11T06:41:45.000Z","updated":"2019-02-11T14:11:00.132Z","comments":true,"path":"2019/02/11/CodeforceDiv2-D-Flood-Fill/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-D-Flood-Fill/","excerpt":"","text":"题意描述You are given a line of $n$ colored squares in a row, numbered from $1$ to $n$ from left to right. The $i$-th square initially has the color $c_i$.Let’s say, that two squares $i$ and $j$ belong to the same connected component if $c_i = c_j$, and $c_i = c_k$ for all $k$ satisfying $i &lt; k &lt; j$. In other words, all squares on the segment from $i$ to $j$ should have the same color.For example, the line $[3, 3, 3]$ has $1$ connected component, while the line $[5, 2, 4, 4]$ has $3$ connected components.The game “flood fill” is played on the given line as follows: At the start of the game you pick any starting square (this is not counted as a turn). Then, in each game turn, change the color of the connected component containing the starting square to any other color. Find the minimum number of turns needed for the entire line to be changed into a single color. InputThe first line contains a single integer $n$ ($1\\leq n\\leq 5000$) — the number of squares.The second line contains integers $c_1,c_2,\\dots,c_n$ ($1\\leq c_i\\leq 5000$) — the initial colors of the squares. OutputPrint a single integer — the minimum number of the turns needed. Sample Input84 5 2 2 1 3 5 5 Sample Output4 题意：有一个n单位长度的带子，每个位置上有一种颜色，定义同种颜色的块为联通快。选取一个位置作为开始，每个回合可以将包含开始位置的联通块修改成另一种颜色，问将带子变成同一种颜色至少需要多少个回合。 思路：一开始看错题目了。将数组压缩一下，考虑$dp$,$dp[i][j]$为将$i$到j这一段修改成同一种颜色的答案，那么根据$a[i]$是否等于$a[j]$可以得到三种决策: 修改成和$i,j$一样颜色的，修改成和$i$一样颜色的，修改成和$j$一样颜色的。然后就做完了…… 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 5007;int dp[maxn][maxn];int a[maxn];int dfs(int L, int R)&#123; if(L&gt;=R) return 0; if(dp[L][R]!=-1) return dp[L][R]; int res = INFI; if(a[L]==a[R]) res = dfs(L+1, R-1) + 1; else res = min(dfs(L+1, R), dfs(L, R-1))+1; return dp[L][R] = res;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n;cin &gt;&gt;n; const int S = 5000; for(int i=1;i&lt;=n;++i)cin &gt;&gt; a[i]; int tot=0; for(int i=1;i&lt;=n;++i) if(a[i]!=a[i-1])a[++tot] = a[i]; memset(dp, -1, sizeof dp); cout &lt;&lt; dfs(1, tot) &lt;&lt;endl;&#125;// 7 1 3 2 4 1 2 3// 7 5 3 5 2 4 3 4","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"CodeforceDiv2 E Arithmetic Progression","slug":"CodeforceDiv2-E-Arithmetic-Progression","date":"2019-02-11T06:41:24.000Z","updated":"2019-02-11T14:16:50.783Z","comments":true,"path":"2019/02/11/CodeforceDiv2-E-Arithmetic-Progression/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-E-Arithmetic-Progression/","excerpt":"","text":"题意：有一个长度为n的数列，如果将这个数列排序，那么它是一个等差数列，可以进行60次询问，每次询问可以给一个下标，会返回这个位置的值，可以给一个x，会返回数组中是否有大于这个数的值。求问这个等差数列的第一项和公差。 思路：二分最大值，随机出任意30个位置的值，取GCD。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////int chk(int x)&#123; cout &lt;&lt; \"&gt; \" &lt;&lt; x &lt;&lt; '\\n'; cout.flush(); int p; cin &gt;&gt; p; return p;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n; cin &gt;&gt; n; int L = 0, R = 1e9+1, mid, ans; int cnt = 0; while(L&lt;=R) &#123; ++cnt; mid = (L+R)&gt;&gt;1; if(chk(mid)) L = mid + 1, ans = mid + 1; else R = mid - 1; &#125; int res = 0; auto seed = chrono::high_resolution_clock::now().time_since_epoch().count(); mt19937 Ran(seed); for(int i=0;i&lt;60-cnt;++i) &#123; int p = Ran()%n+1; cout &lt;&lt; \"? \" &lt;&lt; p &lt;&lt; '\\n';cout.flush(); int x; cin &gt;&gt; x; if(x==ans)continue; res = (res==0)?abs(x-ans):__gcd(abs(x-ans), res); &#125; cout &lt;&lt; \"! \" &lt;&lt; ans-(n-1)*res &lt;&lt; ' ' &lt;&lt; res &lt;&lt; '\\n';cout.flush();&#125;","categories":[],"tags":[{"name":"交互题","slug":"交互题","permalink":"http://aoudad.cn/tags/交互题/"}]},{"title":"CodeforceDiv2 F Please, another Queries on Array?","slug":"CodeforceDiv2-F-Please-another-Queries-on-Array","date":"2019-02-11T06:39:59.000Z","updated":"2019-02-11T14:16:59.426Z","comments":true,"path":"2019/02/11/CodeforceDiv2-F-Please-another-Queries-on-Array/","link":"","permalink":"http://aoudad.cn/2019/02/11/CodeforceDiv2-F-Please-another-Queries-on-Array/","excerpt":"","text":"题意描述You are given an array $a_1,a_2,\\dots,a_n$.You need to perform $q$ queries of the following two types: “MULTIPLY l r x” — for every $i$ ($l\\leq i\\leq r$) multiply $a_i$ by $x$. “TOTIENT l r” — print $\\phi(\\Pi_{i=l}^{r}a_i)$ taken modulo $10^9+7$, where $\\phi$ denotes $Euler’s totient function$.The $Euler’s totient function$ of a positive integer $n$ (denoted as $\\phi(n)$) is the number of integers $x$ ($1\\leq x\\leq n$) such that $gcd(n,x)=1$. InputThe first line contains two integers $n$ and $q$ ($1\\leq n\\leq 4⋅10^5$, $1\\leq q\\leq 2⋅10^5$) — the number of elements in array $a$ and the number of queries.The second line contains $n$ integers $a_1,a_2,\\dots,a_n$ ($1\\leq a_i\\leq 300$) — the elements of array $a$.Then $q$ lines follow, describing queries in the format given in the statement. “MULTIPLY l r x” ($1\\leq l\\leq r\\leq n$, $1\\leq x\\leq 300$) — denotes a multiplication query. “TOTIENT l r” ($1\\leq l\\leq r\\leq n$) — denotes a query on the value of Euler’s totient function.It is guaranteed that there is at least one “TOTIENT” query. OutputFor each “TOTIENT” query, print the answer to it. Sample Input4 45 9 1 2TOTIENT 3 3TOTIENT 3 4MULTIPLY 4 4 3TOTIENT 4 4 Sample Output112 题意：数据结构题，两种操作，第一种操作是对一个区间内的每个数乘以一个小于$300$的数，第二种操作是查询一个区间内所有数的乘积的欧拉函数值。 思路：设该区间内所有数的乘积是M，那么其实\\phi(M) = \\Sigma_{M\\%p==0 \\&\\& p 素数}\\frac{p-1}{p}，所以只需要预处理出300以内的素数有哪些（62个），每次维护区间内包含哪些素因子就可以了。这里有一个or-tree，也就是用long long的每个bit表示一个素因子，构建一颗线段树维护就可以了，写起来很简单。不过好像有点小卡常。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;const ll mod = 1e9+7;ll pro[maxn&lt;&lt;2], lazy[maxn&lt;&lt;2], a[maxn];ll q_p(ll base, ll n)&#123;ll res=1;for(;n;n&gt;&gt;=1, base=base*base%mod)if(n&amp;1)res= res*base%mod;return res;&#125;void pushup(int rt)&#123;pro[rt]=pro[rt&lt;&lt;1]*pro[rt&lt;&lt;1|1]%mod;&#125;void pushdown(int rt, int len)&#123; if(lazy[rt]&gt;1) &#123; lazy[rt&lt;&lt;1]=lazy[rt&lt;&lt;1]*lazy[rt]%mod; lazy[rt&lt;&lt;1|1]=lazy[rt&lt;&lt;1|1]*lazy[rt]%mod; pro[rt&lt;&lt;1]=pro[rt&lt;&lt;1]*q_p(lazy[rt], (len+1)/2)%mod; pro[rt&lt;&lt;1|1]=pro[rt&lt;&lt;1|1]*q_p(lazy[rt], len&gt;&gt;1)%mod; lazy[rt]=1; &#125;&#125;void build(int l, int r, int rt)&#123; lazy[rt] = 1; if(l==r) &#123;pro[rt]=a[l];return ;&#125; int mid = l+r&gt;&gt;1; build(lson);build(rson); pushup(rt);&#125;void update(int L, int R, int x, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;lazy[rt]=lazy[rt]*x%mod;pro[rt]=pro[rt]*q_p(x, r-l+1)%mod;return;&#125; pushdown(rt, r-l+1); int mid = l+r&gt;&gt;1; if(L&lt;=mid) update(L, R, x, lson); if(mid&lt;R) update(L, R, x, rson); pushup(rt);&#125;ll query(int L, int R, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;return pro[rt];&#125; int mid = l+r&gt;&gt;1;pushdown(rt, r-l+1); ll res = 1; if(L&lt;=mid) res = query(L, R, lson); if(mid&lt;R) res = res * query(L, R, rson) % mod; return res;&#125;char Q[30];vector&lt;int&gt; p&#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293&#125;;ll mark[maxn&lt;&lt;2], st[maxn&lt;&lt;2];int pos[403];void ppmark(int rt)&#123;mark[rt]=mark[rt&lt;&lt;1]|mark[rt&lt;&lt;1|1];&#125;void pdmark(int rt)&#123; if(st[rt]==0) return; st[rt&lt;&lt;1] |= st[rt]; st[rt&lt;&lt;1|1]|=st[rt]; mark[rt&lt;&lt;1] |= st[rt]; mark[rt&lt;&lt;1|1] |= st[rt];&#125;void updatem(int L, int R, ll M, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;st[rt]|=M;mark[rt]|=M;return;&#125; int mid = l+r&gt;&gt;1;pdmark(rt); if(L&lt;=mid) updatem(L, R, M, lson); if(mid&lt;R) updatem(L, R, M, rson); ppmark(rt);&#125;ll queryor(int L, int R, int l, int r, int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;return mark[rt];&#125; int mid = l+r&gt;&gt;1;pdmark(rt); ll res = 0; if(L&lt;=mid) res = queryor(L, R, lson); if(mid&lt;R) res |= queryor(L, R, rson); return res;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m; int len = 62; for(int i=0;i&lt;len;++i) pos[p[i]] = i; scanf(\"%d%d\", &amp;n, &amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lld\", a+i); ll M = 0, x = a[i]; for(int j=2;j*j&lt;=x;++j) &#123; if(x%j==0) &#123; M |= 1LL&lt;&lt;pos[j]; while(x%j==0) x/=j; &#125; &#125; if(x&gt;1)M |= 1LL&lt;&lt;pos[x]; updatem(i, i, M, 1, n, 1);// error(i, M, a[i]); &#125; build(1, n, 1); for(int i=0;i&lt;m;++i) &#123; scanf(\"%s\", Q); if(Q[0]=='T') &#123; int L, R; scanf(\"%d%d\", &amp;L, &amp;R); ll tmp = query(L, R, 1, n, 1); ll M = queryor(L, R, 1, n, 1);// error(tmp, M); for(int j=0;j&lt;62;++j) if((M&gt;&gt;j)&amp;1) tmp = tmp*(p[j]-1)%mod*q_p(p[j], mod-2)%mod; printf(\"%lld\\n\", tmp); &#125; else if(Q[0]=='M') &#123; int L, R, x; scanf(\"%d%d%d\", &amp;L, &amp;R, &amp;x); update(L, R, x, 1, n, 1); ll M = 0; for(int j=2;j*j&lt;=x;++j) &#123; if(x%j==0) &#123; M |= 1LL&lt;&lt;pos[j]; while(x%j==0) x/=j; &#125; &#125; if(x&gt;1)M |= 1LL&lt;&lt;pos[x]; updatem(L, R, M, 1, n, 1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"},{"name":"数论","slug":"数论","permalink":"http://aoudad.cn/tags/数论/"}]},{"title":"Camp Day2 H Cosmic Cleaner","slug":"Camp-Day2-H-Cosmic-Cleaner","date":"2019-02-10T13:16:11.000Z","updated":"2019-02-15T07:50:59.445Z","comments":true,"path":"2019/02/10/Camp-Day2-H-Cosmic-Cleaner/","link":"","permalink":"http://aoudad.cn/2019/02/10/Camp-Day2-H-Cosmic-Cleaner/","excerpt":"","text":"题意描述在一片小行星带里有 $n$ 颗小行星，它们在万有引力的作用下绕着一颗行星旋转。在这一刻时，它们之间不存在碰撞的情况。一位清洁工奉命前来清理这颗行星，Ta 会动用某种先进技术使这颗行星顷刻间从宇宙中消失，任何距离这颗行星的中心在一定范围内的事物都会在一瞬间被清除。假设这些天体都是完整的球体，你能计算出清除的区域里有多少体积的事物原本属于这些小行星吗？ 注意，这些天体在此刻满足两两不存在交集的条件。 Input输入包含多组测试数据。第一行包含一个整数 $T$，表示测试数据的组数。随后的内容是各组测试数据。对于每组测试数据：第一行包含一个整数 $n$。接下来的 $n$ 行里，每行包含四个整数 $x, y, z$ 和 $r$，表示有一颗中心位于 $(x, y, z)$、半径为 $r$ 的小行星。最后一行包含四个整数 $x’,y’,z’$ 和 $r’$，表示行星的中心位于 $(x’,y’,z’)$，而清洁工的清理半径为 $r’$（一个大于该行星半径的值）。 $1 \\leq T \\leq 6000$ $1 \\leq n \\leq 100$ $−10^3≤x,y,z,x’,y’,z’≤10^3$ $1 \\leq r’ \\leq 10^3$ Output 对于每组测试数据，输出一行Case #x: y，其中x是测试数据的编号（从 11 开始编号），y是这组数据的答案，要求相对误差或绝对误差不超过 $10^{-6}$。严格来讲，如果你的答案是 $a$，而标准答案是 $b$，那么当 $\\frac{|a - b|}{\\max{1, |b|}} \\leq 10^{-6}$ 时你的答案会被认为是正确的。 Sample Input135 5 5 2-6 -7 6 16 -5 0 31 -1 0 10 Sample OutputCase #1: 142.76246874761383764962 题意：有$n$个小球，求这些小球被一个大球截去的总体积 思路：样例很良心，由于小球两两之间不相交，所以直接单独考虑每个小球就可以了。分三种情况，第一种相离，截取的体积为0；第二种情况，内含，截取的体积为小球的总面积；第三种情况，相交，截去的面积实际上就是两个球缺，直接套一下球缺公式就可以了。球体积公式V=\\frac{4}{3}\\pi r^3球缺公式:V=\\pi H^2(R-\\frac{H}{3})其中$H$表示球缺的高。不过这个题目我之前的写法不知道为啥一直过不了，换种写法才过。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, mid, rt&lt;&lt;1#define rson mid+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e3+7;struct Point&#123; double x, y, z; Point(double _x=0, db _y=0, db _z=0):x(_x), y(_y), z(_z)&#123;&#125; friend Point operator-(const Point &amp;a, const Point &amp;b)&#123;return Point(a.x-b.x, a.y-b.y,a.z-b.z);&#125; friend double dot(const Point&amp;a, const Point &amp;b) &#123; return a.x*b.x+a.y*b.y+a.z*b.z; &#125;&#125;p[maxn];double r[maxn];double gettheta(double a, db b, db c)&#123;// error((a*a+b*b-c*c)/(2*a*b)); return acos((a*a+b*b-c*c)/(2*a*b));&#125;int sgn(double x)&#123;if(x&gt;eps)return 1;if(x&lt;-eps)return -1;return 0;&#125;int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int t; scanf(\"%d\", &amp;t); for(int cas=1;cas&lt;=t;++cas) &#123; int n; scanf(\"%d\", &amp;n); for(int i=1;i&lt;=n;++i) &#123; scanf(\"%lf%lf%lf%lf\", &amp;p[i].x, &amp;p[i].y, &amp;p[i].z, &amp;r[i]); &#125; Point O;double R; scanf(\"%lf%lf%lf%lf\", &amp;O.x, &amp;O.y, &amp;O.z, &amp;R); double res = 0; for(int i=1;i&lt;=n;++i) &#123; double L = sqrt(dot(O-p[i],O-p[i])); double a = r[i], b = R; if(sgn(L-a-b)&gt;=0)continue; if(sgn(b-a-L)&gt;=0) &#123;res+=PI*4/3*a*a*a;continue;&#125; double L1 = (a*a+L*L-b*b)/(2*L); double H1 = a-L1, H2 = b-(L-L1); res += PI*H1*H1*(a-H1/3); res += PI*H2*H2*(b-H2/3); &#125; printf(\"Case #%d: %.12f\\n\", cas, res); &#125;&#125;","categories":[{"name":"Camp day2","slug":"Camp-day2","permalink":"http://aoudad.cn/categories/Camp-day2/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Codeforces 1110 E Magic Stones","slug":"Codeforces-1110-E","date":"2019-02-07T17:02:28.000Z","updated":"2019-02-11T14:17:41.334Z","comments":true,"path":"2019/02/08/Codeforces-1110-E/","link":"","permalink":"http://aoudad.cn/2019/02/08/Codeforces-1110-E/","excerpt":"","text":"题意描述Grigory has $n$ magic stones, conveniently numbered from $1$ to $n$. The charge of the $i$-th stone is equal to $c_i$.Sometimes Grigory gets bored and selects some inner stone (that is, some stone with index $i$, where $2 \\le i \\le n - 1$), and after that synchronizes it with neighboring stones. After that, the chosen stone loses its own charge, but acquires the charges from neighboring stones. In other words, its charge $c_i$ changes to $c_i’ = c_{i + 1} + c_{i - 1} - c_i$.Andrew, Grigory’s friend, also has $n$ stones with charges $t_i$. Grigory is curious, whether there exists a sequence of zero or more synchronization operations, which transforms charges of Grigory’s stones into charges of corresponding Andrew’s stones, that is, changes $c_i$ into $t_i$ for all $i$? InputThe first line contains one integer $n$ ($2\\leq n\\leq 10^5$) — the number of magic stones.The second line contains integers $c_1,c_2,\\dots,c_n$ ($0\\leq c_i\\leq 2⋅10^9$) — the charges of Grigory’s stones.The second line contains integers $t_1,t_2,\\dots,t_n$ ($0\\leq t_i\\leq 2⋅10^9$) — the charges of Andrew’s stones. OutputIf there exists a (possibly empty) sequence of synchronization operations, which changes all charges to the required ones, print “Yes”.Otherwise, print “No”. Sample Input47 2 4 127 15 10 12 Sample OutputYes Sample Input34 4 41 2 3 Sample OutputNo 题意：对于一个长度为$n$的数组$c$，对每个$2\\leq i \\leq n-1$，可以把$c[i]$替换成$c[i+1]+c[i-1]-c[i]$，可以对某个位置多次替换，问是否存在某种操作顺序可以把$c$换成数组$t$ 思路：考虑连续的三个数字$a,b,c$, 对$b$进行操作，得到$a, a+c-b, c$差分数组变为$c-b$, $b-a$，也就是说每次操作就是在交换差分数组里的相邻元素，所以只需要判断一下头尾和差分数组是否一致就可以了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;ll c[maxn], t[maxn];int vis[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; c[i]; for(int i=1;i&lt;=n;++i) cin &gt;&gt; t[i]; if(c[1]!=t[1]||c[n]!=t[n])&#123;puts(\"No\");return 0;&#125; int cnt = 2; for(int i=n;i&gt;1;--i) c[i]-=c[i-1], t[i]-=t[i-1]; sort(c+1, c+1+n); sort(t+1, t+1+n); int ok=1; for(int i=1;i&lt;=n;++i) ok &amp;= (c[i]==t[i]); puts(ok?\"Yes\":\"No\");&#125;","categories":[],"tags":[{"name":"差分","slug":"差分","permalink":"http://aoudad.cn/tags/差分/"}]},{"title":"Codeforces 1110 D","slug":"Codeforces-1110-D","date":"2019-02-07T16:37:40.000Z","updated":"2019-02-11T14:17:32.164Z","comments":true,"path":"2019/02/08/Codeforces-1110-D/","link":"","permalink":"http://aoudad.cn/2019/02/08/Codeforces-1110-D/","excerpt":"","text":"题意描述You are playing a game of Jongmah. You don’t need to know the rules to solve this problem. You have $n$ tiles in your hand. Each tile has an integer between $1$ and $m$ written on it.To win the game, you will need to form some number of triples. Each triple consists of three tiles, such that the numbers written on the tiles are either all the same or consecutive. For example, $7, 7, 7$ is a valid triple, and so is $12, 13, 14$, but $2,2,3$ or $2,4,6$ are not. You can only use the tiles in your hand to form triples. Each tile can be used in at most one triple.To determine how close you are to the win, you want to know the maximum number of triples you can form from the tiles in your hand. InputThe first line contains two integers integer $n$ and $m$($1\\leq n,m\\leq 10^6$) — the number of tiles in your hand and the number of tiles types.The second line contains integers $a_1,a_2,\\dots,a_n$ ($1\\leq a_i\\leq m$), where $a_i$ denotes the number written on the $i$-th tile. OutputPrint one integer: the maximum number of triples you can form. Sample Input10 62 3 3 3 4 4 4 5 5 6 Sample Output3 Sample Input12 61 5 3 3 3 4 3 5 3 2 3 3 Sample Output3 Sample Input13 51 1 5 1 2 3 3 2 4 2 3 4 5 Sample Output4 题意：给一个$cnt$数组，数组大小为$m$，每次可以选择连续的三个位置且这些位置上的数字都大于$0$，分别对他们的值$-1$，或者选择一个位置$-3$，求最多可以做多少次这样的操作。 思路：定义$dp[i][j][k]$表示考虑前i个位置，第$i-2$个位置往后取j次连续$3$个的，$i-1$个位置往后取$k$次连续$3$个的答案。则对于第$i$个位置，枚举这个位置往后取$x$次$3$个的，显然，对于$x\\geq3$的情况，可以把$x$模$3$，当当前位置上的值足够大（$\\geq j+k+x$）的时候，这个枚举是合法的，那么这时候状态转移方程就是dp[i][k][x] = max(dp[i-1][j][k] + x + (cnt[i]-j-k-x)/3)答案就是$dp[m][0][0]$，因为只需要用到$i-1$的信息，所以可以滚动数组优化一下空间 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e6+7;ll dp[2][4][4], cnt[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // ll n, m; cin &gt;&gt; n &gt;&gt; m; ll res = 0; for(int i=1;i&lt;=n;++i) &#123; int x; cin &gt;&gt; x; cnt[x]++; &#125; int t = 0; for(int i=1;i&lt;=m;++i) &#123; t = t^1; memset(dp[t], 0, sizeof dp[t]); for(int j=0;j&lt;3;++j) for(int k=0;k&lt;3;++k) for(int x=0;x&lt;3;++x) &#123; if(j+k+x&gt;cnt[i])continue; dp[t][k][x] = max(dp[t][k][x], dp[t^1][j][k] + x + (cnt[i]-j-k-x)/3); &#125; &#125; cout &lt;&lt; dp[t][0][0]&lt;&lt; endl;&#125;/*12 61 1 1 2 3 3 4 4 4 5 5 6*/","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"Codeforces1111D2 E","slug":"Codeforces1111D2-E","date":"2019-02-06T08:00:49.000Z","updated":"2019-02-11T14:17:53.968Z","comments":true,"path":"2019/02/06/Codeforces1111D2-E/","link":"","permalink":"http://aoudad.cn/2019/02/06/Codeforces1111D2-E/","excerpt":"","text":"题意描述You are given a tree with $n$ nodes and $q$ queries.Every query starts with three integers $k$, $m$ and $r$, followed by $k$ nodes of the tree $a_1, a_2, \\ldots, a_k$. To answer a query, assume that the tree is rooted at $r$. We want to divide the $k$ given nodes into at most $m$ groups such that the following conditions are met: Each node should be in exactly one group and each group should have at least one node. In any group, there should be no two distinct nodes such that one node is an ancestor (direct or indirect) of the other. You need to output the number of ways modulo $10^{9}+7$ for every query. InputThe first line contains two integers $n$ and $q$ ($1\\leq n,q\\leq 10^5$) — the number of vertices in the tree and the number of queries, respectively.Each of the next $n−1$ lines contains two integers $u$ and $v$($1\\leq u,v\\leq n,u\\not=v$), denoting an edge connecting vertex $u$ and vertex $v$. It is guaranteed that the given graph is a tree.Each of the next $q$ lines starts with three integers $k$, $m$ and $r$ ($1\\leq k,r\\leq n$, $1\\leq m\\leq \\min(300,k)$) — the number of nodes, the maximum number of groups and the root of the tree for the current query, respectively. They are followed by $k$ distinct integers $a_1,a_2,\\dots,a_k$ ($1\\leq ai\\leq n$), denoting the nodes of the current query.It is guaranteed that the sum of $k$ over all queries does not exceed $10^5$. OutputPrint $q$ lines, where the $i$-th line contains the answer to the $i$-th query. Sample Input7 25 42 65 31 27 54 63 3 2 7 4 33 1 4 6 2 1 Sample Output20 Sample Input7 24 72 54 15 15 64 33 3 2 7 1 42 1 6 3 2 Sample Output11 Sample Input5 23 54 54 21 42 2 3 1 22 2 4 5 4 Sample Output21 题意：给一棵无根树，节点数小于$10^5$，q次询问，每次询问给k个点和一个根r，将这k个节点分为不多于m组，使得每个节点不与他们的祖先节点在同一组，求方案数。 思路：这道题感觉好多trick，可能是太久没训练的原因，有点迟钝。一直wa6，因为数组开小了2333。以后再出现数组开小了这种问题就打自己一耳光。先是考虑比较简单的情况，固定根节点，设$h_i$表示节点集中i节点的祖先节点数量，按$h[i]$从小到大将节点进行排序，考虑dp，设$dp[i][j]$表示前i个节点组成j组的方案数，那么这就没有后效性了，可以推出状态转移方程为dp[i][j] = dp[i-1][j-1] + dp[i-1][j]*(j-h[i])所以ans=\\Sigma_{j=1}^mdp[k][j]问题的关键就变成了怎么求$h[i]$，实际上$h[i]$就是从节点i到根节点这条简单路径上的在节点集中出现的数量。那我们就能用打标记的方法，给节点集打上标记，那$h[i]$就是一个前缀和。那么怎么维护这个东西呢，显然我们要用树状数组，另外还用到了一个很强大的东西，括号序列，这东西就像dfs序一样强大。括号序列就是dfs树的时候给每个节点记录一个进栈和出栈的值，获得的序列。给每个节点的(进栈序号)打上+1，(出栈序号+1)打上-1，那么每次查询树状数组的时候就是$h[i]+1$了。现在考虑不同根的情况，实际上这里上面的dp还是对的，而$h[i]$表示的是i到r这两个节点间的关键节点的数量。那么就是一个树上差分就解决了h[i] = Sum(inq[i])+Sum(inq[r])-2*Sum(inq[LCA(i, r)])+[LCA是关键节点]-1总复杂度是$O(n*logn)$。需要注意的有： 数组要开双倍大小，因为括号序列是双倍长的QwQ。 这里dp的时候只会用到上一层的信息，所以可以滚动数组优化一下。 求完数组h之后可以反着打一下标记，这样就能抵消了。 注意取模QwQ。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;const int mod = 1e9+7;vector&lt;int&gt; G[maxn];int st[maxn], en[maxn], tot;const int DEG = 20;int p[maxn][DEG], dep[maxn];void dfs(int u, int ff)&#123; p[u][0] = ff; dep[u] = dep[ff] + 1; if(ff) &#123; for(int i=1;i&lt;DEG;++i) p[u][i] = p[p[u][i-1]][i-1]; &#125; st[u] = ++tot; for(int i=0;i&lt;G[u].size();++i) if(G[u][i]!=ff) dfs(G[u][i], u); en[u] = ++tot;&#125;int h[maxn];bool cmp(int x, int y)&#123;return h[x]&lt;h[y];&#125;int Q[maxn];int bit[maxn];int n;void add(int p, int x)&#123;for(int i=p;i&lt;=2*n;i+=(i&amp;-i)) bit[i]+=x;&#125;ll Sum(int p)&#123;if(p==0)return 0;ll res = 0;for(int i=p;i&gt;0;i-=(i&amp;-i))res+=bit[i];return res;&#125;ll dp[maxn];int LCA(int u, int v)&#123; if(dep[u]&gt;dep[v])swap(u, v); int tmp = dep[v] - dep[u]; for(int i=0;tmp;i++,tmp&gt;&gt;=1)if(tmp&amp;1)v = p[v][i]; if(u==v)return u; for(int i=DEG-1;i&gt;=0;--i) if(p[u][i]!=p[v][i]) u = p[u][i], v=p[v][i]; return p[u][0];&#125;int vis[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int q;tot=0; scanf(\"%d%d\", &amp;n, &amp;q); for(int i=1;i&lt;n;++i) &#123; int u, v; scanf(\"%d%d\", &amp;u, &amp;v); G[u].eb(v);G[v].eb(u); &#125; dfs(1, 0); for(int i=1;i&lt;=q;++i) &#123; int k, m, r; scanf(\"%d%d%d\", &amp;k, &amp;m, &amp;r); for(int j=1;j&lt;=k;++j) &#123; scanf(\"%d\", Q+j); add(st[Q[j]], 1); add(en[Q[j]]+1, -1); vis[Q[j]] = 1; &#125; for(int j=1;j&lt;=k;++j) &#123; int lca = LCA(Q[j], r); h[j] = Sum(st[Q[j]]) + Sum(st[r]) - 2 * Sum(st[lca]) + vis[lca] - 1; &#125; for(int i=0;i&lt;=m;++i) dp[i]=0;dp[0]=1; for(int j=1;j&lt;=k;++j) add(st[Q[j]], -1), add(en[Q[j]], 1), vis[Q[j]] = 0; sort(h+1, h+1+k); for(int i=1;i&lt;=k;++i) for(int j=m;j&gt;=0;--j)&#123; if(j&gt;=h[i]) dp[j] = (dp[j-1] + 1LL*dp[j] * (j-h[i])%mod+mod)%mod; else dp[j] = 0; &#125; ll res = 0; for(int i=1;i&lt;=m;++i) &#123;res += dp[i]; res%=mod;&#125; cout &lt;&lt; (res+mod)%mod &lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"括号序列","slug":"括号序列","permalink":"http://aoudad.cn/tags/括号序列/"},{"name":"LCA","slug":"LCA","permalink":"http://aoudad.cn/tags/LCA/"}]},{"title":"Codeforces1111D2 D","slug":"Codeforces1111D2-D","date":"2019-02-06T08:00:35.000Z","updated":"2019-02-11T14:17:47.320Z","comments":true,"path":"2019/02/06/Codeforces1111D2-D/","link":"","permalink":"http://aoudad.cn/2019/02/06/Codeforces1111D2-D/","excerpt":"","text":"题意描述There is a colony of villains with several holes aligned in a row, where each hole contains exactly one villain.Each colony arrangement can be expressed as a string of even length, where the i-th character of the string represents the type of villain in the i-th hole.Iron Man can destroy a colony only if the colony arrangement is such that all villains of a certain type either live in the first half of the colony or in the second half of the colony.His assistant Jarvis has a special power. It can swap villains of any two holes, i.e. swap any two characters in the string; he can do this operation any number of times.Now Iron Man asks Jarvis q questions. In each question, he gives Jarvis two numbers x and y. Jarvis has to tell Iron Man the number of distinct colony arrangements he can create from the original one using his powers such that all villains having the same type as those originally living in x-th hole or y-th hole live in the same half and the Iron Man can destroy that colony arrangement.Two colony arrangements are considered to be different if there exists a hole such that different types of villains are present in that hole in the arrangements. InputThe first line contains a string $s$ ($2 \\leq |s|\\leq 10^5$), representing the initial colony arrangement. String $s$ can have both lowercase and uppercase English letters and its length is even.The second line contains a single integer qq ($1\\leq q \\leq 10^5$) — the number of questions.The $i$-th of the next $q$ lines contains two integers $xi$ and $yi$($1\\leq xi,yi\\leq |s|$, $xi\\not=yi$) — the two numbers given to the Jarvis for the $i$-th question. OutputFor each question output the number of arrangements possible modulo $10^9+7$. Sample Inputabba21 41 2 Sample Output20 Sample InputAAaa21 21 3 Sample Output20 Sample Inputabcd11 3 Sample Output8 题意：给一个只由大写字母和小写字母52种字符组成的字符串，字符串长度一定为偶数，q次询问，定义一个串是合法的，当且仅当同样字母的在同一半。q次询问，每次询问给两个位置，求两个位置上的字符在同一半的方案数。 思路：不考虑询问的话，答案就是从52个数中选出一个子集使得子集和为n/2的方案数。这是个经典的01背包问题。考虑原题，实际上就是从剩下的那些字母中选出一个子集使得子集和为n/2的方案数2，如果直接枚举两个字母预处理做01背包是$O(n52^3)$，GG，这里可以用可逆背包，就是$O(n*52^2)$，当然其实常数不会那么大。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 57;const ll mod = 1e9+7;int id(char ch)&#123; if(ch&lt;='z'&amp;&amp;ch&gt;='a') return ch-'a'+1; if(ch&lt;='Z'&amp;&amp;ch&gt;='A') return ch-'A'+27;&#125;const int maxL = 1e5+8;ll ans[maxn][maxn], f[maxL], cnt[maxn];ll fac[maxL], finv[maxL], tmp[maxn];ll q_p(ll base, ll n)&#123; ll ans = 1; for(;n;n&gt;&gt;=1, base=base*base%mod)if(n&amp;1)ans=ans*base%mod; return ans;&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao string s; cin &gt;&gt;s;int n = (int)s.size(); for(int i=0;i&lt;n;++i) ++cnt[id(s[i])]; fac[0]=1; ll res = 1; for(int i=1;i&lt;=n;++i) &#123;fac[i] = fac[i-1] * i % mod; if(i&lt;=n/2) res = res * i % mod;&#125; finv[n] = q_p(fac[n], mod-2); for(int i=n-1;i&gt;=1;--i) finv[i] = finv[i+1] * (i+1) % mod;finv[0]=1; res = res * res % mod; for(int i=1;i&lt;=52;++i) res = res * finv[cnt[i]] % mod; f[0] = 1; for(int i=1;i&lt;=52;++i) if(cnt[i]) for(int j=n;j&gt;=cnt[i];--j) f[j] = (f[j] + f[j-cnt[i]])%mod; for(int i=1;i&lt;=52;++i) ans[i][i] = f[n/2] * res % mod; for(int i=1;i&lt;=52;++i) &#123; if(cnt[i]==0)continue; for(int i=0;i&lt;=n;++i) tmp[i] = f[i]; for(int j=cnt[i];j&lt;=n;++j) tmp[j] = (mod+tmp[j] - tmp[j-cnt[i]])%mod; for(int j=i+1;j&lt;=52;++j) &#123; if(cnt[j]==0)continue; for(int t=cnt[j];t&lt;=n;++t)tmp[t] = (tmp[t] - tmp[t-cnt[j]]+mod)%mod; ans[i][j] = tmp[n/2]*2*res%mod; for(int t=n;t&gt;=cnt[j];--t) tmp[t] = (tmp[t] + tmp[t-cnt[j]] + mod ) % mod; &#125; &#125; int q, x, y; cin &gt;&gt; q; for(int i=1;i&lt;=q;++i) &#123; scanf(\"%d%d\", &amp;x, &amp;y); x = id(s[x-1]), y=id(s[y-1]); if(x&gt;y)swap(x, y); printf(\"%lld\\n\", ans[x][y]); &#125;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"},{"name":"背包","slug":"背包","permalink":"http://aoudad.cn/tags/背包/"}]},{"title":"NTT模板","slug":"NTT模板","date":"2019-02-02T17:03:34.000Z","updated":"2019-02-11T14:18:44.221Z","comments":true,"path":"2019/02/03/NTT模板/","link":"","permalink":"http://aoudad.cn/2019/02/03/NTT模板/","excerpt":"","text":"描述NTT和分治NTT模板，修改一下FFT模板就可以得到了。一些素数r⋅2k+1 r k g3 1 1 25 1 2 217 1 4 397 3 5 5193 3 6 5257 1 8 37681 15 9 1712289 3 12 1140961 5 13 365537 1 16 3786433 3 18 105767169 11 19 37340033 7 20 323068673 11 21 3104857601 25 22 3167772161 5 25 3469762049 7 26 3998244353 119 23 31004535809 479 21 32013265921 15 27 312281701377 17 27 33221225473 3 30 575161927681 35 31 377309411329 9 33 7206158430209 3 36 222061584302081 15 37 72748779069441 5 39 36597069766657 3 41 539582418599937 9 42 579164837199873 9 43 5263882790666241 15 44 71231453023109121 35 45 31337006139375617 19 46 33799912185593857 27 47 54222124650659841 15 48 197881299347898369 7 50 631525197391593473 7 52 3180143985094819841 5 55 61945555039024054273 27 56 54179340454199820289 29 57 3 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;const int g = 3;const int mod = 998244353;ll q_p(ll base, int n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;void calc(ll *a,ll *b,int n)&#123; NTT(a,n,1);NTT(b,n,1); for(int i=0;i&lt;=n;i++)a[i]=(a[i]*b[i])%mod; NTT(a,n,-1);&#125;ll x[maxn];ll cnt[maxn], d[maxn];char st[maxn];#define LL long longLL A[maxn],B[maxn];int n;int main()&#123; scanf(\"%s\",st); int len=strlen(st); n=len; for(int i=0;i&lt;=len-1;i++) A[len-1-i]=st[i]-'0'; scanf(\"%s\",st); len=strlen(st); n=max(n,len); for(int i=0;i&lt;=len-1;i++) B[len-1-i]=st[i]-'0'; int _n=1; while(_n&lt;n) _n&lt;&lt;=1; n=_n; n&lt;&lt;=1; calc(A, B, n); for(int i=0;i&lt;=n-1;i++) A[i+1]+=A[i]/10, A[i]%=10; n--; while(A[n]/10) A[n+1]+=A[n]/10, A[n++]%=10; while(!A[n]&amp;&amp;n&gt;0) n--; for(int i=n;i&gt;=0;i--) putchar('0'+A[i]); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 分治NTT#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;ll f[maxn], g[maxn], A[maxn], B[maxn];void cdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; cdqNTT(l, mid); int SZ = r-l+1, len=1; while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;mid-l+1;++i) A[i] = f[i+l];for(int i=mid-l+1;i&lt;len;++i) A[i] = 0; for(int i=0;i&lt;SZ-1;++i) B[i] = g[i+1]; for(int i=SZ-1;i&lt;len;++i) B[i] = 0; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) f[i] = (f[i] + A[i-l-1])%mod; cdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; for(int i=1;i&lt;n;++i) cin &gt;&gt; g[i]; int len = 1;while(len&lt;n)len&lt;&lt;=1; f[0]=1; cdqNTT(0, len); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/******* *真·NTT *$Calc f(i) = \\Sigma_&#123;j=0&#125;^&#123;i-1&#125; f(j)*f(i-j-1)$ *******/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; f[0]=1; /// 对拍 for(int i=1;i&lt;n;++i) &#123; for(int j=0;j&lt;i;++j) f[i] += f[j]*f[i-j-1]; f[i]%=mod; &#125; for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout &lt;&lt; endl; for(int i=1;i&lt;len;++i) f[i]=0; /// int len = 1;while(len&lt;n)len&lt;&lt;=1; RcdqNTT(0, len-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"NTT","slug":"NTT","permalink":"http://aoudad.cn/tags/NTT/"},{"name":"分治NTT","slug":"分治NTT","permalink":"http://aoudad.cn/tags/分治NTT/"}]},{"title":"HDU 4609 3-idiots","slug":"HDU-4609-3-idiots","date":"2019-02-02T15:31:38.000Z","updated":"2019-02-11T14:18:27.089Z","comments":true,"path":"2019/02/02/HDU-4609-3-idiots/","link":"","permalink":"http://aoudad.cn/2019/02/02/HDU-4609-3-idiots/","excerpt":"","text":"题意描述King OMeGa catched three men who had been streaking in the street. Looking as idiots though, the three men insisted that it was a kind of performance art, and begged the king to free them. Out of hatred to the real idiots, the king wanted to check if they were lying. The three men were sent to the king’s forest, and each of them was asked to pick a branch one after another. If the three branches they bring back can form a triangle, their math ability would save them. Otherwise, they would be sent into jail.However, the three men were exactly idiots, and what they would do is only to pick the branches randomly. Certainly, they couldn’t pick the same branch - but the one with the same length as another is available. Given the lengths of all branches in the forest, determine the probability that they would be saved. InputAn integer T(T≤100) will exist in the first line of input, indicating the number of test cases.Each test case begins with the number of branches N(3≤N≤10 5).The following line contains N integers a_i (1≤a_i≤10 5), which denotes the length of each branch, respectively. OutputOutput the probability that their branches can form a triangle, in accuracy of 7 decimal places. Sample Input241 3 3 442 3 3 4 Sample Output0.50000001.0000000 题意：有n根长度小于$10^5$的木棍，从中任选三根，能组成三角形的概率。 思路：FFT经典题目。设$ans$为从中选出三根能组成三角形的方案数，tot为总方案数，显然tot为$\\binom n 3$。关键是求$ans$。设cnt[j]表示丛中任选两个木棍，长度之和为j的方案数，枚举木棍i，假设目前枚举到的是i，把d[i]当成选到的木棍中最长的，这样就不会重了，那么要算的就是选取两根长度小于d[i]的木棍，且他们的长度之和大于d[i]的方案数，也就是$\\Sigma_{j=i+1}^{len}cnt[j]-$选两根大于d[i]的方案数，一根大一根小的方案数，一根自己一根其他的方案数。cnt可以通过把长度当作指数(下标)，数量当作系数，作一次FFT得到。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e5+7;struct Complex&#123; double x, y; Complex(double _x=0, double _y=0):x(_x), y(_y)&#123;&#125; Complex operator-(const Complex&amp;b)&#123;return Complex(x-b.x,y-b.y);&#125; Complex operator+(const Complex&amp;b)&#123;return Complex(x+b.x,y+b.y);&#125; Complex operator*(const Complex&amp;b)&#123;return Complex(x*b.x-y*b.y, x*b.y+y*b.x);&#125;&#125;;int rev[maxn];void fft(Complex y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; Complex wn(cos(-on*2*PI/h), sin(-on*2*PI/h)); for(int j=0;j&lt;len;j+=h) &#123; Complex w(1, 0); for(int k=j;k&lt;j+h/2;++k) &#123; Complex u = y[k], t = w*y[k+h/2]; y[k] = u+t; y[k+h/2] = u-t; w = w*wn; &#125; &#125; &#125; if(on==-1)for(int i=0;i&lt;len;++i) y[i].x/=len;&#125;Complex x[maxn];ll cnt[maxn], d[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int t; cin &gt;&gt; t; while(t--) &#123; int n;scanf(\"%d\", &amp;n); memset(cnt, 0, sizeof cnt); for(int i=0;i&lt;n;++i) scanf(\"%lld\", d+i), cnt[d[i]]++; sort(d, d+n); int len = 1, len1 = d[n-1]+1; while(len&lt;len1*2)len&lt;&lt;=1; for(int i=0;i&lt;len1;++i) x[i] = Complex(cnt[i], 0); for(int i=len1;i&lt;len;++i) x[i] = Complex(0, 0); fft(x, len, 1); for(int i=0;i&lt;len;++i) x[i] = x[i]*x[i]; fft(x, len, -1); for(int i=0;i&lt;len;++i) cnt[i] = (ll)(x[i].x+0.5); for(int i=0;i&lt;n;++i) cnt[d[i]+d[i]]--; for(int i=0;i&lt;len;++i) cnt[i]/=2; for(int i=1;i&lt;len;++i) cnt[i]+=cnt[i-1]; ll ans = 0, tot = 1LL*(n-2)*(n-1)*n/6; for(int i=0;i&lt;n;++i) &#123; ans += cnt[len-1] - cnt[d[i]]; ans -= 1LL*(n-i-1)*(n-i-2)/2; ans -= 1LL*i*(n-i-1); ans -= n-1; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; (double)ans/tot &lt;&lt; endl;; &#125;&#125;","categories":[],"tags":[{"name":"计数","slug":"计数","permalink":"http://aoudad.cn/tags/计数/"},{"name":"FFT","slug":"FFT","permalink":"http://aoudad.cn/tags/FFT/"}]},{"title":"Camp Day1 C 拆拆拆数","slug":"Camp-Day1-C-拆拆拆数","date":"2019-02-02T13:56:20.000Z","updated":"2019-02-15T07:50:25.907Z","comments":true,"path":"2019/02/02/Camp-Day1-C-拆拆拆数/","link":"","permalink":"http://aoudad.cn/2019/02/02/Camp-Day1-C-拆拆拆数/","excerpt":"","text":"题意描述读入$A$和$B$，$wls$想请你把$A$拆成$a_1, a_2, …, a_n$​，把$B$拆成$b_1, b_2, …, b_n$​，满足 对于所有的$i(1 \\leq i \\leq n)$，$a_i, b_i \\geq 2i(1≤i≤n)$，$ai​,bi​ \\geq 2$ 且 $gcd(a_i, b_i) = 1$ $\\sum_{i=1}^{n}{a_i} = A$，$\\sum_{i=1}^{n}{b_i} = B$如果有多组满足条件的$a$和$b$，请输出$n$最小的任意一组即可。如果无解，请输出$-1$。 Input第一行一个整数$test$表示数据组数。接下来$test$行，每行两个整数$A$，$B$。$1 \\leq test \\leq 100000$$5 \\leq A, B \\leq 10^{18}$ Output对于每组数据，第一行输出一个整数$n$；接下来$n$行每行输出两个整数$a_i​$，$b_i​$表示答案。 Sample Input26 5100000 100000 Sample Output16 5249999 5000150001 49999 题意：给两个数，分别拆成x组，使得两两之间互质。 思路：分类讨论，如果原本给的两个数就是互质的，显然他们本身就是最优的。如果不是，两个数都是偶数，根据哥德巴赫猜想，都分成两个素数之和是可行的，如果两个都是奇数，那么拆成2，n-2和m-2，2是满足题意的，如果是一奇一偶且奇数（假设为n）大于偶数（假设为m），那么分成2，n-2和3， m-3或者4， n-4和3，m-3是可行的，因为m-3≥3，所以n-2和n-4不可能同时能整除m-3.如果n小于m，那么2，n-2和3， m-3或者2， n-2和5，m-5是可行的，原因类似上一点。当然知道分成两组一定可以的话，直接随机也是可以的【我们队比赛中的做法】。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;///////// Macro ////////////////const ll mod = 1e18;ll get(ll m)&#123; ll x = (ll)rand()*rand()%m*rand()%m; while(x&lt;2||x+2&gt;m) x = (ll)rand()*rand()%m*rand()%m; return x;&#125;int main()&#123; int t; scanf(\"%d\", &amp;t); while(t--) &#123; ll a, b; scanf(\"%lld%lld\", &amp;a, &amp;b); if(__gcd(a, b)==1) printf(\"1\\n%lld %lld\\n\", a, b); else &#123; printf(\"2\\n\"); ll x, y; srand(time(0)); for(;;) &#123; ll x = get(a), y = get(b); if(__gcd(x, y)==1&amp;&amp;__gcd(a-x,b-y)==1) &#123;printf(\"%lld %lld\\n%lld %lld\\n\", x, y, a-x, b-y);break;&#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Camp day1","slug":"Camp-day1","permalink":"http://aoudad.cn/categories/Camp-day1/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"HDU1402 A*B problem plus","slug":"HDU1402-A-B-problem-plus","date":"2019-02-02T13:26:25.000Z","updated":"2019-02-11T14:18:20.648Z","comments":true,"path":"2019/02/02/HDU1402-A-B-problem-plus/","link":"","permalink":"http://aoudad.cn/2019/02/02/HDU1402-A-B-problem-plus/","excerpt":"","text":"题意描述Calculate A * B. InputEach line will contain two integers A and B. Process to end of file. Note: the length of each integer will not exceed 50000. OutputFor each case, output A * B in one line. Sample Input1 21000 2 Sample Output22000 题意：求A*B，A，B的长度小于50000。 思路：FFT模板题。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 2e5+7;struct Complex&#123; double x, y; Complex(double _x=0, double _y=0):x(_x), y(_y)&#123;&#125; Complex operator-(const Complex&amp; b)const&#123;return Complex(x-b.x, y-b.y);&#125; Complex operator+(const Complex&amp; b)const&#123;return Complex(x+b.x, y+b.y);&#125; Complex operator*(const Complex&amp; b)const&#123;return Complex(x*b.x-y*b.y, x*b.y+y*b.x);&#125;&#125;;int rev[maxn];void fft(Complex y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; Complex wn(cos(-on*2*PI/h), sin(-on*2*PI/h)); for(int j=0;j&lt;len;j+=h) &#123; Complex w(1, 0); for(int k=j;k&lt;j+h/2;k++) &#123; Complex u = y[k]; Complex t = w*y[k+h/2]; y[k] = u+t; y[k+h/2] = u-t; w = w*wn; &#125; &#125; &#125; if(on==-1) for(int i=0;i&lt;len;++i) y[i].x /= len;&#125;Complex x1[maxn], x2[maxn];char str1[maxn/2], str2[maxn/2];int sum[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao while(~scanf(\"%s%s\", str1, str2)) &#123; int len1 = strlen(str1); int len2 = strlen(str2); int len = 1; while(len&lt;len1*2||len&lt;len2*2) len&lt;&lt;=1; for(int i=0;i&lt;len1;++i) x1[i] = Complex(str1[len1-1-i]-'0', 0); for(int i=len1;i&lt;len;++i) x1[i] = Complex(0, 0); for(int i=0;i&lt;len2;++i) x2[i] = Complex(str2[len2-1-i]-'0', 0); for(int i=len2;i&lt;len;++i) x2[i] = Complex(0, 0); fft(x1, len, 1); fft(x2, len, 1); for(int i=0;i&lt;len;++i) x1[i]=x1[i]*x2[i];//, printf(\"%lf \", x1[i].x);; fft(x1, len, -1); for(int i=0;i&lt;len;++i) sum[i]=(int)(x1[i].x+0.5); for(int i=0;i&lt;len;++i) &#123; sum[i+1] += sum[i] / 10; sum[i] %= 10; &#125; len = len1+len2-1; while(sum[len]&lt;=0&amp;&amp;len&gt;0)--len; for(int i=len;i&gt;=0;--i) printf(\"%c\", sum[i]+'0'); puts(\"\"); &#125;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://aoudad.cn/tags/FFT/"}]},{"title":"Camp Day8 D 吉良吉影的奇妙计划","slug":"Camp-Day8-D-吉良吉影的奇妙计划","date":"2019-02-02T12:35:19.000Z","updated":"2019-02-15T07:53:38.775Z","comments":true,"path":"2019/02/02/Camp-Day8-D-吉良吉影的奇妙计划/","link":"","permalink":"http://aoudad.cn/2019/02/02/Camp-Day8-D-吉良吉影的奇妙计划/","excerpt":"","text":"题意描述吉良吉影是一个平凡的上班族，他决定在休假的闲暇时光里制定接下来2n2n天的指甲修剪计划。 首先，吉良吉影会在纸上写下2n个字（左、右各n个），表示他每天是修剪左手的指甲还是右手的指甲。但是吉良吉影是一个称职的上班族，不会浪费这么多时间在修剪指甲上，于是他决定将一些位置改成空（即那天不剪指甲）。吉良吉影从头扫视整个计划，如果出现连续两天，剪的是不同的手，那么他就会将这两天改成空，并从头开始重复这个过程。直到不存在连续两天剪不同手的指甲为止。比如初始的计划为左左右左左右右右，那么在第一次修改后变成左空空左左右右右，在第二次修改后变成左空空左空空右右。由于吉良吉影的指甲生长的非常快，所以他不能容忍出现连续4天或以上的空，如果在最终的计划中出现了连续4个的空，那么他认为这样的计划不合法并炸掉计划。 现在吉良吉影想知道，他可能造出多少种合法的计划？两个计划被认为不同，当且仅当存在任意一天的选择不同。 Input第一行包含一个整数 $n(1 \\le n \\le 10^5)$ Output输出仅一行，表示合法计划的数量，对998244353取模。 Sample Input3 Sample Output6 题意：问题可以看成是找到有多少长度为2n的−1, 0, +1组成的序列，满足：0总是成对出现不包含4个连续0+1, −1不能相邻所有数的和为0 思路：这道题实在是太神仙了，搞了两天还是没办法写出来，虽然感觉离正解越来越近了。这是n=6时的方案种类，打表出来的。-1 -1 -1 -1 -1 0 0 1 1 1 1 1-1 -1 -1 -1 0 0 1 0 0 1 1 1-1 -1 -1 -1 0 0 1 1 0 0 1 1-1 -1 -1 -1 0 0 1 1 1 0 0 1-1 -1 -1 -1 0 0 1 1 1 1 0 0-1 -1 -1 0 0 -1 0 0 1 1 1 1-1 -1 -1 0 0 1 0 0 1 0 0 1-1 -1 -1 0 0 1 0 0 1 1 0 0-1 -1 -1 0 0 1 1 0 0 1 0 0-1 -1 -1 0 0 1 1 1 1 0 0 -1-1 -1 0 0 -1 -1 0 0 1 1 1 1-1 -1 0 0 -1 0 0 1 0 0 1 1-1 -1 0 0 -1 0 0 1 1 0 0 1-1 -1 0 0 -1 0 0 1 1 1 0 0-1 -1 0 0 1 0 0 -1 0 0 1 1-1 -1 0 0 1 0 0 1 1 0 0 -1-1 -1 0 0 1 1 0 0 -1 0 0 1-1 -1 0 0 1 1 0 0 1 0 0 -1-1 -1 0 0 1 1 1 0 0 -1 0 0-1 -1 0 0 1 1 1 1 0 0 -1 -1-1 0 0 -1 -1 -1 0 0 1 1 1 1-1 0 0 -1 -1 0 0 1 0 0 1 1-1 0 0 -1 -1 0 0 1 1 0 0 1-1 0 0 -1 -1 0 0 1 1 1 0 0-1 0 0 -1 0 0 -1 0 0 1 1 1-1 0 0 -1 0 0 1 0 0 1 0 0-1 0 0 -1 0 0 1 1 1 0 0 -1-1 0 0 1 0 0 -1 -1 0 0 1 1-1 0 0 1 0 0 -1 0 0 1 0 0-1 0 0 1 0 0 1 0 0 -1 0 0-1 0 0 1 0 0 1 1 0 0 -1 -1-1 0 0 1 1 0 0 -1 -1 0 0 1-1 0 0 1 1 0 0 1 0 0 -1 -1-1 0 0 1 1 1 0 0 -1 -1 0 0-1 0 0 1 1 1 0 0 -1 0 0 -1-1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 1 0 0 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 1 0 0 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 1 0 0 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 1 0 0 -1 0 0 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 1 0 0 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 1 0 0 -1 -1 0 0 0 0 1 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 0 0 -1 0 0 0 0 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 1 0 0 -1 -1 -1 0 0 0 0 1 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 -1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 1 0 0 -1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 0 0 -1 0 0 1 1 0 0 -1 -1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 0 0 -1 0 0 1 0 0 1 0 0 1 0 0 -1 -1 -1 1 0 0 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 0 0 -1 1 0 0 1 1 0 0 -1 0 0 -1 -1 1 0 0 1 1 1 0 0 -1 -1 -1 -1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 1 0 0 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 -1 0 0 1 0 0 -1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 1 0 0 -1 -1 1 1 0 0 1 0 0 -1 -1 -1 0 0 1 1 0 0 1 0 0 -1 -1 0 0 -1 1 1 0 0 1 0 0 -1 0 0 -1 -1 1 1 0 0 1 1 0 0 -1 -1 -1 -1 1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 0 0 -1 0 0 1 1 1 0 0 -1 0 0 -1 -1 0 0 1 1 1 0 0 -1 0 0 -1 0 0 -1 1 1 1 0 0 1 0 0 -1 -1 -1 -1 1 1 1 1 0 0 -1 -1 -1 -1 0 0 1 1 1 1 0 0 -1 -1 -1 0 0 -1 1 1 1 1 0 0 -1 -1 0 0 -1 -1 1 1 1 1 0 0 -1 0 0 -1 -1 -1 1 1 1 1 1 0 0 -1 -1 -1 -1 -1 通过上面的表，可以做以下思考 补充几个在求答案中需要用到的条件： 1.序列的前缀和总是非负2.序列的前缀和总是为正（除了整个序列的和为0）3.序列的结尾是04.序列的结尾非0 现在用$f_{ab···i}$来表示满足额外条件a, b, · · · 的长度为2i的序列数，用$S_i$表示序列前i位（序列位置从1开始标号）的和。目标即求$f_n$。那么有 $f_i = f_{3i} + f_{4i}$ $f_{1i} = f_{13i} + f_{14i}$ $f_{13i} = f_{14i}−1$（因为不能包含4个连续0，对于所有满足条件3的序列去掉末尾的两个0，就会变成满足条件4的序列） $f_{14i} =\\Sigma_{j=0}^{i-1} f_{13j}f_{2i−j}$ （对于每个满足条件14的序列，总可以找到最大的一个$x &lt; 2n$满足$S_x = 0$，容易证明$x$必然为偶数，对于任意的$y(x &lt; y &lt; 2n)$有$Sy = Sy − Sx &gt; 0$，即可以将原序列看成满足条件$13$的长为$x$的序列（这里其实应该是满足条件$1$且末尾不为$−1$的，而由于满足条件$1$末尾不可能为$+1$，所以等价于满足条件$13$）与满足条件$2$的长为$2n − x$的序列（开头必为$+1$，所以前半段末尾不能为$−1$）拼接而成） $f_{2i} = f_{1i−1}$ （满足条件2的序列的开头必然是$+1$，结尾必然是$−1$，将开头与结尾去掉后，满足条件1） $f_{3i} = f_{4i}−1$ $f_{4i} = \\Sigma_{j=0}^{i-1}2f_{3j}f_{2i−j} + f_{4j}f_{2i−j}$ （类似求$f_{14i}$,枚举最大的x&lt;2n满足前缀和为0，分这个位置是0和不为0两种情况统计，显然无论哪种情况，后半段的任意前缀和都不能为0。对于这个位置是0的情况，后半段任意前缀和恒正、恒负都可以，所以有一个常数2；对于这个位置不是0的情况，后半段的前缀和的正负性必须和这个位置相同，因为1和-1不能连续出现。因为序列中只有1,0,-1三种元素，所以前缀和的变化实际上是“连续”的，所以“任意前缀和都不能为0”等价于“前缀和恒正或恒负”）接下来只需要将式子化简使用两次分治NTT即可求出$f_n$。 以上出自出题人的题解，将式子化简之后应该可以推出$f_{14i}$或者$f_{13i}$关于自己的卷积函数，然后这里应该是可以用分治NTT推出来的，然后可以简单的推出$f_{2i}$，然后可以进一步采用正常的分治NTT解出$f_{4i}$，然后使用第一个式子就能得到答案。理论上应该是这样，但是我第一部就卡住了。以下附了一份解决求f(0)=1$$$$f(i)=\\Sigma_{j=0}^{i-1} f(j)*f(i-j-1)的代码，还有一份写了一个下午的假代码，暂时应该是没有能力做出来这道题的了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// https://www.cnblogs.com/yinwuxiao/p/9570533.html/******* *真·NTT *$Calc f(i) = \\Sigma_&#123;j=0&#125;^&#123;i-1&#125; f(j)*f(i-j-1)$ *******/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; cin &gt;&gt; n; f[0]=1; /// 对拍 for(int i=1;i&lt;n;++i) &#123; for(int j=0;j&lt;i;++j) f[i] += f[j]*f[i-j-1]; f[i]%=mod; &#125; for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout &lt;&lt; endl; for(int i=1;i&lt;len;++i) f[i]=0; /// int len = 1;while(len&lt;n)len&lt;&lt;=1; RcdqNTT(0, len-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f[i] &lt;&lt; ' ' ;cout&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209//假代码#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 8e5+7;const int _g = 3;const int mod = 998244353;ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base* base %mod; n&gt;&gt;=1; &#125; return ans;&#125;int rev[maxn];void NTT(ll y[], int len, int on)&#123; int bit = suf_zero(len)-1; for(int i=1;i&lt;len;++i) rev[i] = (rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=1;i&lt;len;++i) if(i&lt;rev[i]) swap(y[i], y[rev[i]]); for(int h=2;h&lt;=len;h&lt;&lt;=1) &#123; ll wn = q_p(_g, (mod-1)/h); if(on==-1) wn = q_p(wn, mod-2); for(int j=0;j&lt;len;j+=h) &#123; ll w = 1; for(int k=j;k&lt;j+h/2;++k) &#123; ll u = y[k], t = w*y[k+h/2]%mod; y[k] = (u+t)%mod; y[k+h/2] = (u-t+mod+mod)%mod; w = w*wn%mod; &#125; &#125; &#125; if(on==-1)&#123;ll t=q_p(len, mod-2);for(int i=0;i&lt;len;++i) y[i]=y[i]*t%mod;&#125;&#125;ll Calc(ll *A, ll *B, int len)&#123; NTT(A, len, 1);NTT(B, len, 1); for(int i=0;i&lt;len;++i) A[i] = A[i] * B[i] % mod; NTT(A, len, -1);&#125;ll A[maxn], B[maxn];/*void RcdqNTT(int l, int r)&#123; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; RcdqNTT(l, mid); if(r-l&lt;l) &#123; int SZ = mid-l+1+r-l+1, len = 1; while(len&lt;SZ) len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=mid-l;++i) A[i] = f[i+l]; for(int i=0;i&lt;=r-l;++i) B[i] = f[i]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; f[i] = (f[i]+2*A[i-l-1])%mod; &#125; &#125; int SZ = mid-l+1, len=1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;SZ;++i) A[i]=B[i]=f[i+l]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) if(i&gt;=l+l) f[i] = (f[i]+A[i-l-l-1])%mod; RcdqNTT(mid+1, r);&#125;*/ll f13[maxn], f2[maxn], f4[maxn];//, f[maxn];void solve13(int l, int r)&#123;// if(r&lt;=4)return ; if(l&gt;=r) return ; int mid = (l+r)&gt;&gt;1; solve13(l, mid); error(l, mid, r); if(r-l&lt;l) &#123; int SZ = r-l+1+mid-l+1, len = 1;while(len&lt;SZ)len&lt;&lt;=1; for(int i=0;i&lt;len;++i) A[i]=B[i]=0; for(int i=0;i&lt;=r-l;++i) A[i] = f13[i]; for(int i=0;i&lt;mid-l+1;++i) B[i] = f13[i+l]; ll tmp = f13[mid]; Calc(A, B, len); for(int i=mid+1;i&lt;=r;++i) &#123; if(i&gt;=l+2) f13[i] = (f13[i]+2*A[i-l-2])%mod; f13[i] = (f13[i]+2*A[i-l-1])%mod; &#125; f13[mid+1] = (f13[mid+1]-tmp%mod+mod)%mod;// if(mid+1&gt;=l+2) f13[mid+1] = (f13[mid+1]-B[SZ-1]*B[mid+0-l-l-SZ]%mod+mod)%mod; &#125; int SZ = mid-l+1, len = 1;while(len&lt;SZ*2)len&lt;&lt;=1; for(int i=0;i&lt;len;++i)A[i] = B[i] = 0; for(int i=0;i&lt;SZ;++i) A[i] = B[i] = f13[i+l]; Calc(A, B, len); for(int i=0;i&lt;len;++i) B[i] = 0; for(int i=0;i&lt;SZ;++i) B[i] = f13[i+l];// for(int i=0;i&lt;len;++i) cout &lt;&lt; A[i] &lt;&lt; ' ';cout&lt;&lt;endl; for(int i=mid+1;i&lt;=r;++i) &#123;// error(i, l+l+1, f13[i]); if(i&gt;=l+l+2) f13[i] = (f13[i]+A[i-l-l-2])%mod;// error(i, l+l+1, f13[i]);++ if(i&gt;=l+l+1) f13[i] = (f13[i]+A[i-l-l-1])%mod; error(i, l+l+1, f13[i]); &#125; if(mid+1&gt;=l*2+1) f13[mid+1] = (f13[mid+1]-2*B[SZ-1]*B[mid+1-l-l-SZ]%mod+mod)%mod; if(mid==0) f13[1] = 1; for(int i=0;i&lt;len;++i) cout &lt;&lt; f13[i] &lt;&lt; ' ';cout&lt;&lt;endl;solve13(mid+1, r);&#125;int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin);// freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n = 8;// cin &gt;&gt; n; memset(f13, 0, sizeof f13); f13[0]=(mod+1)/2, f13[1]=1;//, f13[4] = 2, f13[2] = 0, f13[3] = 1; solve13(1, n-1); for(int i=0;i&lt;n;++i) cout &lt;&lt; f13[i] &lt;&lt; ' ';cout&lt;&lt;endl;&#125;","categories":[{"name":"Camp day8","slug":"Camp-day8","permalink":"http://aoudad.cn/categories/Camp-day8/"}],"tags":[{"name":"分治NTT","slug":"分治NTT","permalink":"http://aoudad.cn/tags/分治NTT/"}]},{"title":"CodeforcesD21106-E Lunar New Year and Red Envelopes","slug":"CodeforcesD21106-E","date":"2019-02-02T06:34:22.000Z","updated":"2019-02-11T14:17:59.884Z","comments":true,"path":"2019/02/02/CodeforcesD21106-E/","link":"","permalink":"http://aoudad.cn/2019/02/02/CodeforcesD21106-E/","excerpt":"","text":"题意描述Lunar New Year is approaching, and Bob is going to receive some red envelopes with countless money! But collecting money from red envelopes is a time-consuming process itself.Let’s describe this problem in a mathematical way. Consider a timeline from time $1$ to $n$. The $i$-th red envelope will be available from time $s_i$ to $t_i$, inclusive, and contain $w_i$ coins. If Bob chooses to collect the coins in the $i$-th red envelope, he can do it only in an integer point of time between $s_i$ and $t_i$, inclusive, and he can’t collect any more envelopes until time $d_i$ (inclusive) after that. Here $s_i \\leq t_i \\leq d_i$ holds.Bob is a greedy man, he collects coins greedily — whenever he can collect coins at some integer time $x$, he collects the available red envelope with the maximum number of coins. If there are multiple envelopes with the same maximum number of coins, Bob would choose the one whose parameter $d$ is the largest. If there are still multiple choices, Bob will choose one from them randomly.However, Alice — his daughter — doesn’t want her father to get too many coins. She could disturb Bob at no more than $m$ integer time moments. If Alice decides to disturb Bob at time $x$, he could not do anything at time $x$ and resumes his usual strategy at the time $x + 1$ (inclusive), which may lead to missing some red envelopes.Calculate the minimum number of coins Bob would get if Alice disturbs him optimally. InputThe first line contains three non-negative integers n, m and k $(1≤n≤10^5, 0≤m≤200, 1≤k≤10^5)$, denoting the length of the timeline, the number of times Alice can disturb Bob and the total number of red envelopes, respectively. The following $k$ lines describe those $k$ red envelopes. The i-th line contains four positive integers si, ti, di and wi ($1 \\leq s_i \\leq t_i≤d_i \\leq n$, $1 \\leq wi \\leq 10^9$ ) — the time segment when the i-th envelope is available, the time moment Bob can continue collecting after collecting the i-th envelope, and the number of coins in this envelope, respectively. OutputOutput one integer — the minimum number of coins Bob would get if Alice disturbs him optimally. Sample Input12 2 61 5 5 44 6 6 23 8 8 32 9 9 56 10 10 78 12 12 9 10 1 61 1 2 42 2 6 23 3 3 34 4 4 55 5 5 76 6 6 9 5 0 21 3 4 52 5 5 8 Sample Output11 2 13 题意：时间长度为n，每一秒SB Bob会拿一次红包，每个红包有三种属性，$s, t, d, w$分别表示这个红包出现的开始时间，结束时间，领这个红包之后d时刻之前都不能再领红包，以及这个红包里面有的钱。每个时刻Bob会贪心的选择(w, d)最大的红包。Alice有m次干扰操作，每次他可以选择一个时刻进行干扰，这个时刻被干扰的话，Bob就不能拿红包。求Bob会拿到的最少金额的红包是多少。 思路：先预处理初每个时刻Bob的决策，再从后往前DP。预处理就是拿个扫描线从左往右扫，用一个multiset维护一下，遇到s就加入multiset，遇到t+1就从multiset中去掉。DP的话，定义$dp[i][j]$ 表示 $i \\dots n$干扰j次的最小硬币数量。状态转移是很显然的，就i时刻干不干扰两种决策。除了dp[n+1][0]为0以外，全都初始化为INF。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 1e5+7;ll dp[maxn][305];struct Node&#123; int w, d, id; friend bool operator&lt;(const Node&amp; a, const Node&amp; b) &#123; if(a.w!=b.w) return a.w&gt;b.w; return a.d &gt; b.d; &#125;&#125;d[maxn];multiset&lt;Node&gt; s;vector&lt;Node&gt; vec[maxn];int main()&#123; #ifdef aoaoao// freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i=0;i&lt;k;++i) &#123; int s, t, w, d; cin &gt;&gt; s &gt;&gt; t &gt;&gt; d &gt;&gt; w; vec[s].eb((Node)&#123;w, d, 1&#125;); vec[t+1].eb((Node)&#123;w, d,-1&#125;); &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j=0;j&lt;vec[i].size();++j) &#123; if(vec[i][j].id==1) s.insert(vec[i][j]); else &#123;vec[i][j].id=1;s.erase(s.find(vec[i][j]));&#125; &#125; if(s.empty()) &#123; d[i].d = i;d[i].w=d[i].id=0; &#125; else d[i] = *s.begin(); &#125; memset(dp, 0x37, sizeof dp); dp[n+1][0] = 0; for(int i=n;i&gt;=1;--i) &#123; dp[i][0] = min(dp[i][0], d[i].w + dp[d[i].d+1][0]); for(int j=1;j&lt;=m;++j) &#123; dp[i][j] = min(dp[i][j], dp[i+1][j-1]); dp[i][j] = min(dp[i][j], d[i].w + dp[d[i].d+1][j]); &#125; &#125; ll ans = INFLL; for(int i=0;i&lt;=m;++i) ans = min(ans, dp[1][i]); cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"CodeforcesD21106 F Lunar New Year and a Recursive Sequence","slug":"CodeforcesD21106-F","date":"2019-02-01T03:56:00.000Z","updated":"2019-02-11T14:18:06.882Z","comments":true,"path":"2019/02/01/CodeforcesD21106-F/","link":"","permalink":"http://aoudad.cn/2019/02/01/CodeforcesD21106-F/","excerpt":"","text":"题意描述Lunar New Year is approaching, and Bob received a gift from his friend recently — a recursive sequence! He loves this sequence very much and wants to play with it.Let $f_1, f_2, \\ldots, f_i, \\ldots$ be an infinite sequence of positive integers. Bob knows that for $i&gt;k$ , $f_i$ can be obtained by the following recursive equation:f_i = \\left(f_{i - 1} ^ {b_1} \\cdot f_{i - 2} ^ {b_2} \\cdot \\cdots \\cdot f_{i - k} ^ {b_k}\\right) \\bmod p,which in short isf_i = \\left(\\prod_{j = 1}^{k} f_{i - j}^{b_j}\\right) \\bmod p,where p=998244353 (a widely-used prime), $b_1, b_2, \\ldots, b_k$ are known integer constants, and $x \\bmod y$ denotes the remainder of x divided by y.Bob lost the values of $f_1, f_2, \\ldots, f_k$, which is extremely troublesome – these are the basis of the sequence! Luckily, Bob remembers the first k−1 elements of the sequence: $f_1 = f_2 = \\ldots = f_{k - 1} = 1$ and the n-th element: $f_n = m$. Please find any possible value of $f_k$. If no solution exists, just tell Bob that it is impossible to recover his favorite sequence, regardless of Bob’s sadness. InputThe first line contains a positive integer k$(1 \\leq k \\leq 100)$, denoting the length of the sequence $b_1, b_2, \\ldots, b_k$ .The second line contains k positive integers $b_1, b_2, \\ldots, b_k$ $(1 \\leq b_i &lt; p)$.The third line contains two positive integers n and m ($k &lt; n \\leq 10^9$, $1 \\leq m &lt; p$), which implies $f_n = m$. OutputOutput a possible value of $f_k$, where $f_k$ is a positive integer satisfying $1 \\leq f_k &lt; p$. If there are multiple answers, print any of them. If no such $f_k$ makes $f_n=m$, output −1 instead. It is easy to show that if there are some possible values of fk, there must be at least one satisfying $1 \\leq f_k &lt; p$. Sample Input10283 463 213 777 346 201 463 283 102 9992333333 6263423 3998244352 998244352 9982443524 2 1288888 66666 82 3 5 6 1 7 9 1023333 1 54 7 1 5 67 14187219 32 3 54 16 Sample Output382480067 -1 -1 1 6 4 题意：一个序列的第n项可以通过前k项推出来，现在告诉你前k-1项都是1，已知第n项是m，求$f_x$。 思路：设 $f_k$ 为X则，可以利用矩阵快速幂和欧拉降幂求出 $f_n$ ，则原题意化为解方程 $x^a=b(mod p)$，这是个套路了，虽然我不会，但是直接扔个板子上去就行了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 3e6+8;;const ll mod = 998244353;int SZ;struct M&#123; ll a[110][110]; M()&#123;memset(a, 0, sizeof a);&#125; friend M operator*(const M&amp;a, const M&amp;b) &#123; M ans; for(int i=1;i&lt;=SZ;++i) for(int j=1;j&lt;=SZ;++j) for(int k=1;k&lt;=SZ;++k) ans.a[i][j] += a.a[i][k] * b.a[k][j], ans.a[i][j]%=(mod-1); return ans; &#125;&#125;;ll b[maxn];ll q_pm(ll n)&#123; M res, base; res.a[1][1] = 1; for(int i=1;i&lt;=SZ;++i) base.a[1][i] = b[i]; for(int i=2;i&lt;=SZ;++i) base.a[i][i-1] = 1; while(n) &#123; if(n&amp;1) res = base * res; base = base * base; n &gt;&gt;= 1; &#125; return res.a[1][1];&#125;#define met(a,b) memset(a, b, sizeof(a));ll q_p(ll base, ll n)&#123; ll ans = 1; while(n) &#123; if(n&amp;1) ans = ans * base % mod; base = base * base % mod; n &gt;&gt;= 1; &#125; return ans;&#125;const ll INF = 0x7fffffff;const int dir[5][2] = &#123;0,0,-1,0,1,0,0,-1,0,1&#125;;const ll MOD = 1e9+7;bool is[maxn]; ll prm[maxn], id;ll getprm(ll n) &#123; n-=10; if(n == 1) return 0; ll k = 0; met(is, 1); is[0] = is[1] = 0; for(ll i = 2; i &lt; n; ++i) &#123; if(is[i]) prm[k++] = i; for(ll j = 0; j &lt; k &amp;&amp; (i*prm[j] &lt; n); ++j) &#123; is[i*prm[j]] = 0; if(i % prm[j] == 0) break; &#125; &#125; return k;&#125;ll Euler(ll x) &#123; //素数的欧拉函数 return x-1;&#125;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a%b) : a;&#125;ll extgcd(ll a, ll b, ll&amp; x, ll&amp; y) &#123; if (b == 0) &#123; x=1; y=0; return a; &#125; ll d = extgcd(b, a % b, x, y); ll t = x; x = y; y = t - a / b * y; return d;&#125;//快速乘 -- a*b % modll pow_mul(ll a, ll b, ll p) &#123; ll r = 0; a %= p; while(b) &#123; if(b&amp;1) r = (r+a) % p; a = (a+a) % p; b &gt;&gt;= 1; &#125; return r;&#125;ll pow_mod(ll a, ll b, ll p) &#123; ll r = 1; a %= p; while(b) &#123; if(b&amp;1) r = pow_mul(r, a, p); a = pow_mul(a, a, p); b &gt;&gt;= 1; &#125; return r;&#125;//求原根ll fac[maxn], num[maxn], tot;ll Factor(ll n)&#123; ll ans = 1, temp = n; tot = 0; for (ll i = 0; i &lt; id &amp;&amp; prm[i] * prm[i] &lt;= temp; i++)&#123; if (n % prm[i] == 0)&#123; fac[tot] = prm[i], num[tot] = 0; while (n%prm[i] == 0) n /= prm[i], ++num[tot]; ans *= (num[tot] + 1); ++tot; &#125; &#125; if (n != 1)&#123; fac[tot] = n, num[tot] = 1; ans *=(num[tot]+1); ++tot; &#125; return ans;&#125;ll root(ll p) &#123; ll phi = Euler(p); Factor(phi); for(ll g = 2; ; g++) &#123; bool f = 1; for(int i = 0; i &lt; tot; ++i) &#123; ll t = phi / fac[i]; if(pow_mod(g, t, p) == 1) &#123; f = 0; break; &#125; &#125; if(f) return g; &#125;&#125;//BSGSll BSGS(ll a, ll b, ll p) &#123; a %= p; b %= p; map&lt;ll, ll&gt; h; ll m = ceil(sqrt(p)), x, y, d, t = 1, v = 1; for(ll i = 0; i &lt; m; ++i) &#123; if(h.count(t)) h[t] = min(h[t], i); else h[t] = i; t = pow_mul(t, a, p); &#125; for(ll i = 0; i &lt; m; ++i) &#123; d = extgcd(v, p, x, y); x = (x* b/d % p + p) % (p); if(h.count(x)) return i*m + h[x]; v = pow_mul(v, t, p); &#125; return -1;&#125;//求模线性方程ll modeq(ll a, ll b, ll p, ll r[]) &#123; ll e, i, d, x, y; d = extgcd(a, p, x, y); if (b % d) &#123; return -1; &#125; e = (x * (b / d) + p) % p; r[0] = (e + p) % p; return d;&#125;//开始解决问题ll solve(ll a, ll b, ll p, ll r[], ll ans[]) &#123; ll g = root(p); ll t1 = BSGS(g, b, p); ll phi = Euler(p); ll cnt = modeq(a, t1, phi, r); if(cnt == -1) return -1; ans[0] = pow_mod(g, r[0], p); return cnt;&#125;ll ans[maxn], res[maxn];int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); #endif // aoaoao int k; cin &gt;&gt; k; for(int i=1;i&lt;=k;++i) cin &gt;&gt; b[i]; SZ = k; ll n, m; cin &gt;&gt; n &gt;&gt; m; ll tmp = q_pm(n-k);tmp=(tmp%(mod-1)+mod-1)%(mod-1)+mod-1; id = getprm(maxn-1); ll cnt = solve(tmp, m, mod, res, ans); if(cnt==-1) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans[0] &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://aoudad.cn/tags/矩阵快速幂/"},{"name":"欧拉降幂","slug":"欧拉降幂","permalink":"http://aoudad.cn/tags/欧拉降幂/"},{"name":"BSGS","slug":"BSGS","permalink":"http://aoudad.cn/tags/BSGS/"},{"name":"原根","slug":"原根","permalink":"http://aoudad.cn/tags/原根/"}]},{"title":"Camp Day8 B 玖凛两开花","slug":"Camp-Day8-B-玖凛两开花","date":"2019-01-30T03:48:10.000Z","updated":"2019-02-15T07:53:23.073Z","comments":true,"path":"2019/01/30/Camp-Day8-B-玖凛两开花/","link":"","permalink":"http://aoudad.cn/2019/01/30/Camp-Day8-B-玖凛两开花/","excerpt":"","text":"题意描述为了拯救重要之人，御原玖音和Rinne Ohara都努力地进行时间机器的研究，为此她们正在学习一些必要的算法。在学习的过程中，她们发现了一个叫做开花（Blossom algorithm，也被称作带花树）的有趣算法。开花算法可以用来解决一般图最大匹配问题，经过一些修改还可以用来解决一般图最大权匹配问题。原始的开花算法的时间复杂度为 $O(|V|^2|E|)$ ，其中 $|V|,|E|$ 分别为图的点数与边数。有很多人对开花算法进行了优化，如Gabow在《 Data structures for weighted matching and nearest common ancestors with linking》一文中将一般图最大权匹配的时间复杂度优化到了 $O(|V|(|E|+|V| \\log |V|))$ 。本着不重复造轮子的心态，Rinne尝试在线搜索开花算法的代码，但是找到的却都是时间复杂度为 $O(V^3)$ 的实现方式。玖音只好自己写出一份代码，对一道例题跑出结果，然后请你检验她的答案对不对。玖音的题目是这样的：给出一张点集为 $V$，边集为 $E$ 的无向图 $G$ ，点的编号为0至 $|V|-1$ ，边 $(u,v)$ 的权值为 $\\min(u,v)$ 。一个边集 $S$ 是图的一个匹配当且仅当 $S \\subseteq E$ ，且 $\\forall e_1,e_2 \\in S \\bigwedge e_1 \\neq e_2$ ，满足 $e_1,e_2$ 无公共端点。对于一个边集 $S$ ，定义 $W_S$为 $S$ 中所有边的权值的集合。对于一个自然数集 $W$ ，定义 $Mex(W)$ 为最小的不属于 $W$ 的自然数。求对于图 $G$ 的匹配 $S$ ， $Mex(W_S)$ 的最大值是多少。好心的Rinne为了减少你的负担，将题目的做法告诉了你，你只需要实现一个高效的开花算法即可。当然，如果你已经会做这道题了，就可以不用继续看下去了。Rinne给出的做法是这样的：对于所有的边 $e \\in E$ ，若其原本的边权为 $w$ ，将其改为 $2^{|V|-w}$ 。求出新图的最大权匹配后，设其权值之和为 $X$ ，将其二进制表示中的最低 $|V|+1$ 位由高位到低位依次写出来，第一个为0的位的出现位置（从0开始编号）就是答案。要想证明正确性又要花费一些时间，不过Rinne是不会骗你的。 Input第一行两个整数 $n,m(1 \\le n \\le 10 ^4, 1 \\le m \\le 2 \\times 10^4)$ ，分别代表图的点数与边数。接下来m行，每行两个整数 $u_i,v_i(0 \\le u_i,v_i &lt; n)$ ，代表有一条连接 $u_i, v_i$ 的边。保证没有重边和自环。 Output输出共一行一个整数，代表 $Mex(W_S)$ 的最大值。 Sample Input5 103 14 01 40 31 22 30 14 24 30 2 Sample Output2 题意：给一个无向带权图，权值是两个节点的编号中的较小值。设S是该图的某个匹配的边权集合，那么 $Mer(S)$就是S中没有的最小自然数。 思路：显然这不是传统的一般图最大权匹配，注意到答案具有单调性，二分答案，则原图相当于二分图，将小于ans放在左边，其他放在右边：左图显然不能和左边匹配，否则矛盾，右边可以和右边匹配，但是不影响答案，所以只剩下左边匹配右边了。每次跑个HK就行了。时间复杂度 $O(\\log n nm)$ ，其实还可以nm的，因为不用二分，每次将点从右边移到左边就行，这里就不深入了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int MAXN = 2e4+7;const int INF = 0x3f3f3f3f;vector&lt;int&gt;G[MAXN];vector&lt;int&gt; Real[MAXN];int uN;int Mx[MAXN],My[MAXN];int dx[MAXN],dy[MAXN];int dis;bool used[MAXN];bool SearchP()&#123; queue&lt;int&gt;Q; dis = INF; memset(dx,-1,sizeof(dx)); memset(dy,-1,sizeof(dy)); for(int i = 0 ; i &lt; uN; i++) if(Mx[i] == -1) &#123; Q.push(i); dx[i] = 0; &#125; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); if(dx[u] &gt; dis) break; int sz = G[u].size(); for(int i = 0; i &lt; sz; i++) &#123; int v = G[u][i]; if(dy[v] == -1) &#123; dy[v] = dx[u] + 1; if(My[v] == -1) dis = dy[v]; else &#123; dx[My[v]] = dy[v] + 1; Q.push(My[v]); &#125; &#125; &#125; &#125; return dis != INF;&#125;bool DFS(int u)&#123; int sz = G[u].size(); for(int i = 0; i &lt; sz; i++) &#123; int v = G[u][i]; if(!used[v] &amp;&amp; dy[v] == dx[u] + 1) &#123; used[v] = true; if(My[v] != -1 &amp;&amp; dy[v] == dis) continue; if(My[v] == -1 || DFS(My[v])) &#123; My[v] = u; Mx[u] = v; return true; &#125; &#125; &#125; return false;&#125;int MaxMatch()&#123; int res = 0; memset(Mx,-1,sizeof(Mx)); memset(My,-1,sizeof(My)); while(SearchP()) &#123; memset(used,false,sizeof(used)); for(int i = 0; i &lt; uN; i++) if(Mx[i] == -1 &amp;&amp; DFS(i)) res++; &#125; return res;&#125;//const int maxn = 2e4+7;//vector&lt;int&gt; G[maxn];void addedge(int u, int v)&#123;Real[u].push_back(v);&#125;int n;int chk(int x)&#123; uN = x; for(int i=0;i&lt;n;++i) G[i].clear(); for(int i=0;i&lt;x;++i) &#123; for(auto tmp:Real[i]) if(tmp&gt;=x) G[i].push_back(tmp-x); &#125; int ans = MaxMatch(); return ans == x;&#125;int main()&#123; int m; cin &gt;&gt; n &gt;&gt;m; for(int i=0;i&lt;n;++i) G[i].clear(); for(int i=0;i&lt;m;++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; addedge(u, v);addedge(v, u); &#125; int L = 0, R = n-1, mid, ans; while(L&lt;R) &#123; mid = (L+R)/2; if(chk(mid)) L = mid + 1, ans = mid; else R = mid; &#125; cout &lt;&lt; ans &lt;&lt;endl;&#125;","categories":[{"name":"Camp day8","slug":"Camp-day8","permalink":"http://aoudad.cn/categories/Camp-day8/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://aoudad.cn/tags/二分/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"http://aoudad.cn/tags/二分图匹配/"}]},{"title":"Camp Day8 A Aqous","slug":"Camp-Day8-A-Aqous","date":"2019-01-30T03:03:58.000Z","updated":"2019-02-15T07:53:17.801Z","comments":true,"path":"2019/01/30/Camp-Day8-A-Aqous/","link":"","permalink":"http://aoudad.cn/2019/01/30/Camp-Day8-A-Aqous/","excerpt":"","text":"题意描述Aqours 正在 LoveLive! 决赛中表演，舞台可以看作是一棵 $n$ 个点的有根树，其中根节点是 1 号点，$i$ 号点的父亲节点为 $p_i$ ，保证 $1 \\le p_i &lt; i$ ，而且对于 $2 \\le i &lt; j $\\le n^2$ 有 $p_i \\le p_j$ 。其中的叶子节点（定义为没有孩子节点的点）是与粉丝进行互动的节点，Aqours 会在这些叶子节点之间走动来与更多的粉丝互动，但是她们又要唱歌又要跳舞，要尽快节省走动时间，然后也要做到雨露均沾，所以每次要往编号更小的叶子节点走。所以 Aqours 想知道对于每一个叶子节点 $u$ ，离它最近的编号 $&lt;u$ 的叶子节点到它的距离是多少，若不存在则视距离为 -1。 Input第一行一个正整数 n ( $1 \\le n \\le 3 \\times 10^6$ )，表示树的大小。第二行 $n-1$ 个正整数，其中第 $i$ 个数表示 $p_{i+1}(1 \\le p_{i+1} \\le i)$ 。对于 $2 \\le i &lt; j \\le n^2$ ，保证 $p_i \\le p_j$ 。 Output每个叶子对应的答案输出一行。每行第一个数是叶子节点的编号 $u$，第二个数是离他最近的编号 $&lt;u$ 的叶子节点到它的距离，若不存在则输出 -1。要求按叶子节点编号从小到大输出。 Sample Input101 1 1 1 2 4 5 6 7 Sample Output3 -18 39 410 4 题意：按BFS序给出一个树，求出每个叶子节点到所有标号比他小的叶子节点的最小距离，其中距离就是常规的树的路径的距离。如果不存在就输出-1. 思路：显然是按BFS序给出这个树的，所以可以知道编号小的叶子节点的深度绝对不会大于标号比它大的节点。对每个节点 $u$ 维护一个值 $dis(u)$ 表示离u最近的叶子节点到他的距离。初始时每个dis初始化为0， $dis(0)$ 初始化为INF。按照从小到大的顺序枚举每个叶子节点，然后从每个叶子节点一直往上更新dis(f(u))，同时将访问到的节点塞进栈里，直到某个节点的dis曾经被更新过。然后该节点的答案就是往上跳的步数加上这个节点的dis值。由于所有比目前的叶子节点标号都小的叶子节点都已经访问过了，所以目前跳到的答案一定是最优的。而往下更新的原因是因为可能比较浅的节点到该节点的距离更小。需要注意的是这里最好用数组模拟栈，用自带的栈我一直TLE。感觉效率差了一个数量级。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ull unsigned long long#define db double#define what_is(x) cerr &lt;&lt; \"Line \" &lt;&lt; __LINE__ &lt;&lt; \": \" &lt;&lt; #x &lt;&lt; \" is \" &lt;&lt; (x) &lt;&lt; endl;#define suf_zero(x) __builtin_ffs(x)#define pre_zero(x) __builtin_clz(x)#define num_one(x) __builtin_popcount(x)#define error(args...) &#123; string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); &#125;#define mt make_tuple#define mp make_pair#define eb emplace_back#define INFI 2000000009#define INFLL (ll)1e18+7#define ig ignore#define fi first#define TP tuple&lt;int, int, int&gt;#define se second#define lson l, m, rt&lt;&lt;1#define rson m+1, r, rt&lt;&lt;1|1#define PII pair&lt;int, int&gt;//#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)&gt;(end));i!=(end)-((begin)&gt;(end));i+=1-2*((begin)&gt;(end)))void err(istream_iterator&lt;string&gt; it) &#123;cerr&lt;&lt;endl;&#125;template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) &#123; cerr &lt;&lt; *it &lt;&lt; \" = \" &lt;&lt; a &lt;&lt; \" , \"; err(++it, args...);&#125;// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000// fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin); if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO;const double PI = acos(-1.0);const double eps = 1e-8;///////// Macro ////////////////const int maxn = 4e6+7;int p[maxn], tag[maxn], ans[maxn], isp[maxn];int st[maxn], tot=0;int main()&#123; #ifdef aoaoao freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif // aoaoao int n; scanf(\"%d\", &amp;n); for(int i=2;i&lt;=n;++i) &#123;scanf(\"%d\", &amp;p[i]); isp[p[i]] = 1;&#125; if(n==1) &#123; puts(\"1 -1\"); return 0; &#125; tag[0]=INFI; for(int i=2;i&lt;=n;++i) &#123; int t = p[i], cnt = 0; if(isp[i])continue; st[tot++] = t; while(tag[t]==0) &#123; cnt++; tag[t] = cnt; t = p[t]; st[tot++] = t; &#125; ans[i] = cnt + tag[t] + 1; tag[t] = min(tag[t], cnt+1); cnt = 0; while(tot) &#123; tag[st[tot-1]] = min(tag[st[tot-1]], tag[t] + cnt); ++cnt; --tot; &#125; &#125; for(int i=1;i&lt;=n;++i) &#123; if(isp[i]) continue;; if(ans[i]&gt;=INFI) &#123;printf(\"%d -1\\n\", i);continue;&#125; printf(\"%d %d\\n\", i, ans[i]); &#125;&#125;","categories":[{"name":"Camp day8","slug":"Camp-day8","permalink":"http://aoudad.cn/categories/Camp-day8/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://aoudad.cn/tags/思维/"}]},{"title":"JRY's_Geo","slug":"JRY-s-Geo","date":"2019-01-25T07:54:30.000Z","updated":"2019-02-11T14:18:32.929Z","comments":true,"path":"2019/01/25/JRY-s-Geo/","link":"","permalink":"http://aoudad.cn/2019/01/25/JRY-s-Geo/","excerpt":"","text":"题意描述InputOutputSample InputSample Output题意：吉老师的计算几何板子 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552#define mp make_pair#define fi first#define se second#define pb push_backtypedef double db;const db eps=1e-6;const db pi=acos(-1);int sign(db k)&#123; if (k&gt;eps) return 1; else if (k&lt;-eps) return -1; return 0;&#125;int cmp(db k1,db k2)&#123;return sign(k1-k2);&#125;int inmid(db k1,db k2,db k3)&#123;return sign(k1-k3)*sign(k2-k3)&lt;=0;&#125;// k3 在 [k1,k2] 内 struct point&#123; db x,y; point operator + (const point &amp;k1) const&#123;return (point)&#123;k1.x+x,k1.y+y&#125;;&#125; point operator - (const point &amp;k1) const&#123;return (point)&#123;x-k1.x,y-k1.y&#125;;&#125; point operator * (db k1) const&#123;return (point)&#123;x*k1,y*k1&#125;;&#125; point operator / (db k1) const&#123;return (point)&#123;x/k1,y/k1&#125;;&#125; int operator == (const point &amp;k1) const&#123;return cmp(x,k1.x)==0&amp;&amp;cmp(y,k1.y)==0;&#125; // 逆时针旋转 point turn(db k1)&#123;return (point)&#123;x*cos(k1)-y*sin(k1),x*sin(k1)+y*cos(k1)&#125;;&#125; point turn90()&#123;return (point)&#123;-y,x&#125;;&#125; bool operator &lt; (const point k1) const&#123; int a=cmp(x,k1.x); if (a==-1) return 1; else if (a==1) return 0; else return cmp(y,k1.y)==-1; &#125; db abs()&#123;return sqrt(x*x+y*y);&#125; db abs2()&#123;return x*x+y*y;&#125; db dis(point k1)&#123;return ((*this)-k1).abs();&#125; point unit()&#123;db w=abs(); return (point)&#123;x/w,y/w&#125;;&#125; void scan()&#123;double k1,k2; scanf(\"%lf%lf\",&amp;k1,&amp;k2); x=k1; y=k2;&#125; void print()&#123;printf(\"%.11lf %.11lf\\n\",x,y);&#125; db getw()&#123;return atan2(y,x);&#125; point getdel()&#123;if (sign(x)==-1||(sign(x)==0&amp;&amp;sign(y)==-1)) return (*this)*(-1); else return (*this);&#125; int getP() const&#123;return sign(y)==1||(sign(y)==0&amp;&amp;sign(x)==-1);&#125;&#125;;int inmid(point k1,point k2,point k3)&#123;return inmid(k1.x,k2.x,k3.x)&amp;&amp;inmid(k1.y,k2.y,k3.y);&#125;db cross(point k1,point k2)&#123;return k1.x*k2.y-k1.y*k2.x;&#125;db dot(point k1,point k2)&#123;return k1.x*k2.x+k1.y*k2.y;&#125;db rad(point k1,point k2)&#123;return atan2(cross(k1,k2),dot(k1,k2));&#125;// -pi -&gt; piint compareangle (point k1,point k2)&#123; return k1.getP()&lt;k2.getP()||(k1.getP()==k2.getP()&amp;&amp;sign(cross(k1,k2))&gt;0);&#125;point proj(point k1,point k2,point q)&#123; // q 到直线 k1,k2 的投影 point k=k2-k1; return k1+k*(dot(q-k1,k)/k.abs2());&#125;point reflect(point k1,point k2,point q)&#123;return proj(k1,k2,q)*2-q;&#125;int clockwise(point k1,point k2,point k3)&#123;// k1 k2 k3 逆时针 1 顺时针 -1 否则 0 return sign(cross(k2-k1,k3-k1));&#125;int checkLL(point k1,point k2,point k3,point k4)&#123;// 求直线 (L) 线段 (S)k1,k2 和 k3,k4 的交点 return cmp(cross(k3-k1,k4-k1),cross(k3-k2,k4-k2))!=0;&#125;point getLL(point k1,point k2,point k3,point k4)&#123; db w1=cross(k1-k3,k4-k3),w2=cross(k4-k3,k2-k3); return (k1*w2+k2*w1)/(w1+w2);&#125;int intersect(db l1,db r1,db l2,db r2)&#123; if (l1&gt;r1) swap(l1,r1); if (l2&gt;r2) swap(l2,r2); return cmp(r1,l2)!=-1&amp;&amp;cmp(r2,l1)!=-1;&#125;int checkSS(point k1,point k2,point k3,point k4)&#123; return intersect(k1.x,k2.x,k3.x,k4.x)&amp;&amp;intersect(k1.y,k2.y,k3.y,k4.y)&amp;&amp; sign(cross(k3-k1,k4-k1))*sign(cross(k3-k2,k4-k2))&lt;=0&amp;&amp; sign(cross(k1-k3,k2-k3))*sign(cross(k1-k4,k2-k4))&lt;=0;&#125;db disSP(point k1,point k2,point q)&#123; point k3=proj(k1,k2,q); if (inmid(k1,k2,k3)) return q.dis(k3); else return min(q.dis(k1),q.dis(k2));&#125;db disSS(point k1,point k2,point k3,point k4)&#123; if (checkSS(k1,k2,k3,k4)) return 0; else return min(min(disSP(k1,k2,k3),disSP(k1,k2,k4)),min(disSP(k3,k4,k1),disSP(k3,k4,k2)));&#125;int onS(point k1,point k2,point q)&#123;return inmid(k1,k2,q)&amp;&amp;sign(cross(k1-q,k2-k1))==0;&#125;struct circle&#123; point o; db r; void scan()&#123;o.scan(); scanf(\"%lf\",&amp;r);&#125; int inside(point k)&#123;return cmp(r,o.dis(k));&#125;&#125;;struct line&#123; // p[0]-&gt;p[1] point p[2]; line(point k1,point k2)&#123;p[0]=k1; p[1]=k2;&#125; point&amp; operator [] (int k)&#123;return p[k];&#125; int include(point k)&#123;return sign(cross(p[1]-p[0],k-p[0]))&gt;0;&#125; point dir()&#123;return p[1]-p[0];&#125; line push()&#123; // 向外 ( 左手边 ) 平移 eps const db eps = 1e-6; point delta=(p[1]-p[0]).turn90().unit()*eps; return &#123;p[0]-delta,p[1]-delta&#125;; &#125;&#125;;point getLL(line k1,line k2)&#123;return getLL(k1[0],k1[1],k2[0],k2[1]);&#125;int parallel(line k1,line k2)&#123;return sign(cross(k1.dir(),k2.dir()))==0;&#125;int sameDir(line k1,line k2)&#123;return parallel(k1,k2)&amp;&amp;sign(dot(k1.dir(),k2.dir()))==1;&#125;int operator &lt; (line k1,line k2)&#123; if (sameDir(k1,k2)) return k2.include(k1[0]); return compareangle(k1.dir(),k2.dir());&#125;int checkpos(line k1,line k2,line k3)&#123;return k3.include(getLL(k1,k2));&#125;vector&lt;line&gt; getHL(vector&lt;line&gt; &amp;L)&#123; // 求半平面交 , 半平面是逆时针方向 , 输出按照逆时针 sort(L.begin(),L.end()); deque&lt;line&gt; q; for (int i=0;i&lt;(int)L.size();i++)&#123; if (i&amp;&amp;sameDir(L[i],L[i-1])) continue; while (q.size()&gt;1&amp;&amp;!checkpos(q[q.size()-2],q[q.size()-1],L[i])) q.pop_back(); while (q.size()&gt;1&amp;&amp;!checkpos(q[1],q[0],L[i])) q.pop_front(); q.push_back(L[i]); &#125; while (q.size()&gt;2&amp;&amp;!checkpos(q[q.size()-2],q[q.size()-1],q[0])) q.pop_back(); while (q.size()&gt;2&amp;&amp;!checkpos(q[1],q[0],q[q.size()-1])) q.pop_front(); vector&lt;line&gt;ans; for (int i=0;i&lt;q.size();i++) ans.push_back(q[i]); return ans;&#125;db closepoint(vector&lt;point&gt;&amp;A,int l,int r)&#123; // 最近点对 , 先要按照 x 坐标排序 if (r-l&lt;=5)&#123; db ans=1e20; for (int i=l;i&lt;=r;i++) for (int j=i+1;j&lt;=r;j++) ans=min(ans,A[i].dis(A[j])); return ans; &#125; int mid=l+r&gt;&gt;1; db ans=min(closepoint(A,l,mid),closepoint(A,mid+1,r)); vector&lt;point&gt;B; for (int i=l;i&lt;=r;i++) if (abs(A[i].x-A[mid].x)&lt;=ans) B.push_back(A[i]); sort(B.begin(),B.end(),[](point k1,point k2)&#123;return k1.y&lt;k2.y;&#125;); for (int i=0;i&lt;B.size();i++) for (int j=i+1;j&lt;B.size()&amp;&amp;B[j].y-B[i].y&lt;ans;j++) ans=min(ans,B[i].dis(B[j])); return ans;&#125;int checkposCC(circle k1,circle k2)&#123;// 返回两个圆的公切线数量 if (cmp(k1.r,k2.r)==-1) swap(k1,k2); db dis=k1.o.dis(k2.o); int w1=cmp(dis,k1.r+k2.r),w2=cmp(dis,k1.r-k2.r); if (w1&gt;0) return 4; else if (w1==0) return 3; else if (w2&gt;0) return 2; else if (w2==0) return 1; else return 0;&#125;vector&lt;point&gt; getCL(circle k1,point k2,point k3)&#123; // 沿着 k2-&gt;k3 方向给出 , 相切给出两个 point k=proj(k2,k3,k1.o); db d=k1.r*k1.r-(k-k1.o).abs2(); if (sign(d)==-1) return &#123;&#125;; point del=(k3-k2).unit()*sqrt(max((db)0.0,d)); return &#123;k-del,k+del&#125;;&#125;vector&lt;point&gt; getCC(circle k1,circle k2)&#123;// 沿圆 k1 逆时针给出 , 相切给出两个 int pd=checkposCC(k1,k2); if (pd==0||pd==4) return &#123;&#125;; db a=(k2.o-k1.o).abs2(),cosA=(k1.r*k1.r+a-k2.r*k2.r)/(2*k1.r*sqrt(max(a,(db)0.0))); db b=k1.r*cosA,c=sqrt(max((db)0.0,k1.r*k1.r-b*b)); point k=(k2.o-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c; return &#123;m-del,m+del&#125;;&#125; vector&lt;point&gt; TangentCP(circle k1,point k2)&#123;// 沿圆 k1 逆时针给出 db a=(k2-k1.o).abs(),b=k1.r*k1.r/a,c=sqrt(max((db)0.0,k1.r*k1.r-b*b)); point k=(k2-k1.o).unit(),m=k1.o+k*b,del=k.turn90()*c; return &#123;m-del,m+del&#125;;&#125; vector&lt;line&gt; TangentoutCC(circle k1,circle k2)&#123; int pd=checkposCC(k1,k2); if (pd==0) return &#123;&#125;; if (pd==1)&#123;point k=getCC(k1,k2)[0]; return &#123;(line)&#123;k,k&#125;&#125;;&#125; if (cmp(k1.r,k2.r)==0)&#123; point del=(k2.o-k1.o).unit().turn90().getdel(); return &#123;(line)&#123;k1.o-del*k1.r,k2.o-del*k2.r&#125;,(line)&#123;k1.o+del*k1.r,k2.o+del*k2.r&#125;&#125;; &#125; else &#123; point p=(k2.o*k1.r-k1.o*k2.r)/(k1.r-k2.r); vector&lt;point&gt;A=TangentCP(k1,p),B=TangentCP(k2,p); vector&lt;line&gt;ans; for (int i=0;i&lt;A.size();i++) ans.push_back((line)&#123;A[i],B[i]&#125;); return ans; &#125;&#125;vector&lt;line&gt; TangentinCC(circle k1,circle k2)&#123; int pd=checkposCC(k1,k2); if (pd&lt;=2) return &#123;&#125;; if (pd==3)&#123;point k=getCC(k1,k2)[0]; return &#123;(line)&#123;k,k&#125;&#125;;&#125; point p=(k2.o*k1.r+k1.o*k2.r)/(k1.r+k2.r); vector&lt;point&gt;A=TangentCP(k1,p),B=TangentCP(k2,p); vector&lt;line&gt;ans; for (int i=0;i&lt;A.size();i++) ans.push_back((line)&#123;A[i],B[i]&#125;); return ans;&#125;vector&lt;line&gt; TangentCC(circle k1,circle k2)&#123; int flag=0; if (k1.r&lt;k2.r) swap(k1,k2),flag=1; vector&lt;line&gt;A=TangentoutCC(k1,k2),B=TangentinCC(k1,k2); for (line k:B) A.push_back(k); if (flag) for (line &amp;k:A) swap(k[0],k[1]); return A;&#125;db getarea(circle k1,point k2,point k3)&#123; // 圆 k1 与三角形 k2 k3 k1.o 的有向面积交 point k=k1.o; k1.o=k1.o-k; k2=k2-k; k3=k3-k; int pd1=k1.inside(k2),pd2=k1.inside(k3); vector&lt;point&gt;A=getCL(k1,k2,k3); if (pd1&gt;=0)&#123; if (pd2&gt;=0) return cross(k2,k3)/2; return k1.r*k1.r*rad(A[1],k3)/2+cross(k2,A[1])/2; &#125; else if (pd2&gt;=0)&#123; return k1.r*k1.r*rad(k2,A[0])/2+cross(A[0],k3)/2; &#125;else &#123; int pd=cmp(k1.r,disSP(k2,k3,k1.o)); if (pd&lt;=0) return k1.r*k1.r*rad(k2,k3)/2; return cross(A[0],A[1])/2+k1.r*k1.r*(rad(k2,A[0])+rad(A[1],k3))/2; &#125;&#125;circle getcircle(point k1,point k2,point k3)&#123; db a1=k2.x-k1.x,b1=k2.y-k1.y,c1=(a1*a1+b1*b1)/2; db a2=k3.x-k1.x,b2=k3.y-k1.y,c2=(a2*a2+b2*b2)/2; db d=a1*b2-a2*b1; point o=(point)&#123;k1.x+(c1*b2-c2*b1)/d,k1.y+(a1*c2-a2*c1)/d&#125;; return (circle)&#123;o,k1.dis(o)&#125;;&#125;circle getScircle(vector&lt;point&gt; A)&#123; random_shuffle(A.begin(),A.end()); circle ans=(circle)&#123;A[0],0&#125;; for (int i=1;i&lt;A.size();i++) if (ans.inside(A[i])==-1)&#123; ans=(circle)&#123;A[i],0&#125;; for (int j=0;j&lt;i;j++) if (ans.inside(A[j])==-1)&#123; ans.o=(A[i]+A[j])/2; ans.r=ans.o.dis(A[i]); for (int k=0;k&lt;j;k++) if (ans.inside(A[k])==-1) ans=getcircle(A[i],A[j],A[k]); &#125; &#125; return ans;&#125;db area(vector&lt;point&gt; A)&#123; // 多边形用 vector&lt;point&gt; 表示 , 逆时针 db ans=0; for (int i=0;i&lt;A.size();i++) ans+=cross(A[i],A[(i+1)%A.size()]); return ans/2;&#125;int checkconvex(vector&lt;point&gt;A)&#123; int n=A.size(); A.push_back(A[0]); A.push_back(A[1]); for (int i=0;i&lt;n;i++) if (sign(cross(A[i+1]-A[i],A[i+2]-A[i]))==-1) return 0; return 1;&#125;int contain(vector&lt;point&gt;A,point q)&#123; // 2 内部 1 边界 0 外部 int pd=0; A.push_back(A[0]); for (int i=1;i&lt;A.size();i++)&#123; point u=A[i-1],v=A[i]; if (onS(u,v,q)) return 1; if (cmp(u.y,v.y)&gt;0) swap(u,v); if (cmp(u.y,q.y)&gt;=0||cmp(v.y,q.y)&lt;0) continue; if (sign(cross(u-v,q-v))&lt;0) pd^=1; &#125; return pd&lt;&lt;1;&#125;vector&lt;point&gt; ConvexHull(vector&lt;point&gt;A,int flag=1)&#123; // flag=0 不严格 flag=1 严格 int n=A.size(); vector&lt;point&gt;ans(n*2); sort(A.begin(),A.end()); int now=-1; for (int i=0;i&lt;A.size();i++)&#123; while (now&gt;0&amp;&amp;sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))&lt;flag) now--; ans[++now]=A[i]; &#125; int pre=now; for (int i=n-2;i&gt;=0;i--)&#123; while (now&gt;pre&amp;&amp;sign(cross(ans[now]-ans[now-1],A[i]-ans[now-1]))&lt;flag) now--; ans[++now]=A[i]; &#125; ans.resize(now); return ans;&#125;db convexDiameter(vector&lt;point&gt;A)&#123; int now=0,n=A.size(); db ans=0; for (int i=0;i&lt;A.size();i++)&#123; now=max(now,i); while (1)&#123; db k1=A[i].dis(A[now%n]),k2=A[i].dis(A[(now+1)%n]); ans=max(ans,max(k1,k2)); if (k2&gt;k1) now++; else break; &#125; &#125; return ans;&#125;vector&lt;point&gt; convexcut(vector&lt;point&gt;A,point k1,point k2)&#123; // 保留 k1,k2,p 逆时针的所有点 int n=A.size(); A.push_back(A[0]); vector&lt;point&gt;ans; for (int i=0;i&lt;n;i++)&#123; int w1=clockwise(k1,k2,A[i]),w2=clockwise(k1,k2,A[i+1]); if (w1&gt;=0) ans.push_back(A[i]); if (w1*w2&lt;0) ans.push_back(getLL(k1,k2,A[i],A[i+1])); &#125; return ans;&#125;int checkPoS(vector&lt;point&gt;A,point k1,point k2)&#123; // 多边形 A 和直线 ( 线段 )k1-&gt;k2 严格相交 , 注释部分为线段 struct ins&#123; point m,u,v; int operator &lt; (const ins&amp; k) const &#123;return m&lt;k.m;&#125; &#125;; vector&lt;ins&gt;B; //if (contain(A,k1)==2||contain(A,k2)==2) return 1; vector&lt;point&gt;poly=A; A.push_back(A[0]); for (int i=1;i&lt;A.size();i++) if (checkLL(A[i-1],A[i],k1,k2))&#123; point m=getLL(A[i-1],A[i],k1,k2); if (inmid(A[i-1],A[i],m)/*&amp;&amp;inmid(k1,k2,m)*/) B.push_back((ins)&#123;m,A[i-1],A[i]&#125;); &#125; if (B.size()==0) return 0; sort(B.begin(),B.end()); int now=1; while (now&lt;B.size()&amp;&amp;B[now].m==B[0].m) now++; if (now==B.size()) return 0; int flag=contain(poly,(B[0].m+B[now].m)/2); if (flag==2) return 1; point d=B[now].m-B[0].m; for (int i=now;i&lt;B.size();i++)&#123; if (!(B[i].m==B[i-1].m)&amp;&amp;flag==2) return 1; int tag=sign(cross(B[i].v-B[i].u,B[i].m+d-B[i].u)); if (B[i].m==B[i].u||B[i].m==B[i].v) flag+=tag; else flag+=tag*2; &#125; //return 0; return flag==2;&#125;int checkinp(point r,point l,point m)&#123; if (compareangle(l,r))&#123;return compareangle(l,m)&amp;&amp;compareangle(m,r);&#125; return compareangle(l,m)||compareangle(m,r);&#125;int checkPosFast(vector&lt;point&gt;A,point k1,point k2)&#123; // 快速检查线段是否和多边形严格相交 if (contain(A,k1)==2||contain(A,k2)==2) return 1; if (k1==k2) return 0; A.push_back(A[0]); A.push_back(A[1]); for (int i=1;i+1&lt;A.size();i++) if (checkLL(A[i-1],A[i],k1,k2))&#123; point now=getLL(A[i-1],A[i],k1,k2); if (inmid(A[i-1],A[i],now)==0||inmid(k1,k2,now)==0) continue; if (now==A[i])&#123; if (A[i]==k2) continue; point pre=A[i-1],ne=A[i+1]; if (checkinp(pre-now,ne-now,k2-now)) return 1; &#125; else if (now==k1)&#123; if (k1==A[i-1]||k1==A[i]) continue; if (checkinp(A[i-1]-k1,A[i]-k1,k2-k1)) return 1; &#125; else if (now==k2||now==A[i-1]) continue; else return 1; &#125; return 0;&#125;// 拆分凸包成上下凸壳 凸包尽量都随机旋转一个角度来避免出现相同横坐标 // 尽量特判只有一个点的情况 凸包逆时针void getUDP(vector&lt;point&gt;A,vector&lt;point&gt;&amp;U,vector&lt;point&gt;&amp;D)&#123; db l=1e100,r=-1e100; for (int i=0;i&lt;A.size();i++) l=min(l,A[i].x),r=max(r,A[i].x); int wherel,wherer; for (int i=0;i&lt;A.size();i++) if (cmp(A[i].x,l)==0) wherel=i; for (int i=A.size();i;i--) if (cmp(A[i-1].x,r)==0) wherer=i-1; U.clear(); D.clear(); int now=wherel; while (1)&#123;D.push_back(A[now]); if (now==wherer) break; now++; if (now&gt;=A.size()) now=0;&#125; now=wherel; while (1)&#123;U.push_back(A[now]); if (now==wherer) break; now--; if (now&lt;0) now=A.size()-1;&#125;&#125;// 需要保证凸包点数大于等于 3,2 内部 ,1 边界 ,0 外部int containCoP(const vector&lt;point&gt;&amp;U,const vector&lt;point&gt;&amp;D,point k)&#123; db lx=U[0].x,rx=U[U.size()-1].x; if (k==U[0]||k==U[U.size()-1]) return 1; if (cmp(k.x,lx)==-1||cmp(k.x,rx)==1) return 0; int where1=lower_bound(U.begin(),U.end(),(point)&#123;k.x,-1e100&#125;)-U.begin(); int where2=lower_bound(D.begin(),D.end(),(point)&#123;k.x,-1e100&#125;)-D.begin(); int w1=clockwise(U[where1-1],U[where1],k),w2=clockwise(D[where2-1],D[where2],k); if (w1==1||w2==-1) return 0; else if (w1==0||w2==0) return 1; return 2;&#125;// d 是方向 , 输出上方切点和下方切点pair&lt;point,point&gt; getTangentCow(const vector&lt;point&gt; &amp;U,const vector&lt;point&gt; &amp;D,point d)&#123; if (sign(d.x)&lt;0||(sign(d.x)==0&amp;&amp;sign(d.y)&lt;0)) d=d*(-1); point whereU,whereD; if (sign(d.x)==0) return mp(U[0],U[U.size()-1]); int l=0,r=U.size()-1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (sign(cross(U[mid+1]-U[mid],d))&lt;=0) l=mid+1,ans=mid+1; else r=mid;&#125; whereU=U[ans]; l=0,r=D.size()-1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (sign(cross(D[mid+1]-D[mid],d))&gt;=0) l=mid+1,ans=mid+1; else r=mid;&#125; whereD=D[ans]; return mp(whereU,whereD);&#125;// 先检查 contain, 逆时针给出pair&lt;point,point&gt; getTangentCoP(const vector&lt;point&gt;&amp;U,const vector&lt;point&gt;&amp;D,point k)&#123; db lx=U[0].x,rx=U[U.size()-1].x; if (k.x&lt;lx)&#123; int l=0,r=U.size()-1,ans=U.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;&#125; point w1=U[ans]; l=0,r=D.size()-1,ans=D.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;&#125; point w2=D[ans]; return mp(w1,w2); &#125; else if (k.x&gt;rx)&#123; int l=1,r=U.size(),ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid-1])==-1) r=mid; else ans=mid,l=mid+1;&#125; point w1=U[ans]; l=1,r=D.size(),ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid-1])==1) r=mid; else ans=mid,l=mid+1;&#125; point w2=D[ans]; return mp(w2,w1); &#125; else &#123; int where1=lower_bound(U.begin(),U.end(),(point)&#123;k.x,-1e100&#125;)-U.begin(); int where2=lower_bound(D.begin(),D.end(),(point)&#123;k.x,-1e100&#125;)-D.begin(); if ((k.x==lx&amp;&amp;k.y&gt;U[0].y)||(where1&amp;&amp;clockwise(U[where1-1],U[where1],k)==1))&#123; int l=1,r=where1+1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid-1])==1) ans=mid,l=mid+1; else r=mid;&#125; point w1=U[ans]; l=where1,r=U.size()-1,ans=U.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,U[mid],U[mid+1])==1) l=mid+1; else ans=mid,r=mid;&#125; point w2=U[ans]; return mp(w2,w1); &#125; else &#123; int l=1,r=where2+1,ans=0; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid-1])==-1) ans=mid,l=mid+1; else r=mid;&#125; point w1=D[ans]; l=where2,r=D.size()-1,ans=D.size()-1; while (l&lt;r)&#123;int mid=l+r&gt;&gt;1; if (clockwise(k,D[mid],D[mid+1])==-1) l=mid+1; else ans=mid,r=mid;&#125; point w2=D[ans]; return mp(w1,w2); &#125; &#125;&#125;struct P3&#123; db x,y,z; P3 operator + (P3 k1)&#123;return (P3)&#123;x+k1.x,y+k1.y,z+k1.z&#125;;&#125; P3 operator - (P3 k1)&#123;return (P3)&#123;x-k1.x,y-k1.y,z-k1.z&#125;;&#125; P3 operator * (db k1)&#123;return (P3)&#123;x*k1,y*k1,z*k1&#125;;&#125; P3 operator / (db k1)&#123;return (P3)&#123;x/k1,y/k1,z/k1&#125;;&#125; db abs2()&#123;return x*x+y*y+z*z;&#125; db abs()&#123;return sqrt(x*x+y*y+z*z);&#125; P3 unit()&#123;return (*this)/abs();&#125; int operator &lt; (const P3 k1) const&#123; if (cmp(x,k1.x)!=0) return x&lt;k1.x; if (cmp(y,k1.y)!=0) return y&lt;k1.y; return cmp(z,k1.z)==-1; &#125; int operator == (const P3 k1)&#123; return cmp(x,k1.x)==0&amp;&amp;cmp(y,k1.y)==0&amp;&amp;cmp(z,k1.z)==0; &#125; void scan()&#123; double k1,k2,k3; scanf(\"%lf%lf%lf\",&amp;k1,&amp;k2,&amp;k3); x=k1; y=k2; z=k3; &#125;&#125;;P3 cross(P3 k1,P3 k2)&#123;return (P3)&#123;k1.y*k2.z-k1.z*k2.y,k1.z*k2.x-k1.x*k2.z,k1.x*k2.y-k1.y*k2.x&#125;;&#125;db dot(P3 k1,P3 k2)&#123;return k1.x*k2.x+k1.y*k2.y+k1.z*k2.z;&#125;//p=(3,4,5),l=(13,19,21),theta=85 ans=(2.83,4.62,1.77)P3 turn3D(db k1,P3 l,P3 p)&#123; l=l.unit(); P3 ans; db c=cos(k1),s=sin(k1); ans.x=p.x*(l.x*l.x*(1-c)+c)+p.y*(l.x*l.y*(1-c)-l.z*s)+p.z*(l.x*l.z*(1-c)+l.y*s); ans.y=p.x*(l.x*l.y*(1-c)+l.z*s)+p.y*(l.y*l.y*(1-c)+c)+p.z*(l.y*l.z*(1-c)-l.x*s); ans.z=p.x*(l.x*l.z*(1-c)-l.y*s)+p.y*(l.y*l.z*(1-c)+l.x*s)+p.z*(l.x*l.x*(1-c)+c); return ans;&#125;typedef vector&lt;P3&gt; VP;typedef vector&lt;VP&gt; VVP;db Acos(db x)&#123;return acos(max(-(db)1,min(x,(db)1)));&#125;// 球面距离 , 圆心原点 , 半径 1db Odist(P3 a,P3 b)&#123;db r=Acos(dot(a,b)); return r;&#125;db r; P3 rnd;vector&lt;db&gt; solve(db a,db b,db c)&#123; db r=sqrt(a*a+b*b),th=atan2(b,a); if (cmp(c,-r)==-1) return &#123;0&#125;; else if (cmp(r,c)&lt;=0) return &#123;1&#125;; else &#123; db tr=pi-Acos(c/r); return &#123;th+pi-tr,th+pi+tr&#125;; &#125;&#125;vector&lt;db&gt; jiao(P3 a,P3 b)&#123; // dot(rd+x*cos(t)+y*sin(t),b) &gt;= cos(r) if (cmp(Odist(a,b),2*r)&gt;0) return &#123;0&#125;; P3 rd=a*cos(r),z=a.unit(),y=cross(z,rnd).unit(),x=cross(y,z).unit(); vector&lt;db&gt; ret = solve(-(dot(x,b)*sin(r)),-(dot(y,b)*sin(r)),-(cos(r)-dot(rd,b))); return ret;&#125;db norm(db x,db l=0,db r=2*pi)&#123; // change x into [l,r) while (cmp(x,l)==-1) x+=(r-l); while (cmp(x,r)&gt;=0) x-=(r-l); return x;&#125;db disLP(P3 k1,P3 k2,P3 q)&#123; return (cross(k2-k1,q-k1)).abs()/(k2-k1).abs();&#125;db disLL(P3 k1,P3 k2,P3 k3,P3 k4)&#123; P3 dir=cross(k2-k1,k4-k3); if (sign(dir.abs())==0) return disLP(k1,k2,k3); return fabs(dot(dir.unit(),k1-k2));&#125;VP getFL(P3 p,P3 dir,P3 k1,P3 k2)&#123; db a=dot(k2-p,dir),b=dot(k1-p,dir),d=a-b; if (sign(fabs(d))==0) return &#123;&#125;; return &#123;(k1*a-k2*b)/d&#125;;&#125;VP getFF(P3 p1,P3 dir1,P3 p2,P3 dir2)&#123;// 返回一条线 P3 e=cross(dir1,dir2),v=cross(dir1,e); db d=dot(dir2,v); if (sign(abs(d))==0) return &#123;&#125;; P3 q=p1+v*dot(dir2,p2-p1)/d; return &#123;q,q+e&#125;;&#125;// 3D Covex Hull Templatedb getV(P3 k1,P3 k2,P3 k3,P3 k4)&#123; // get the Volume return dot(cross(k2-k1,k3-k1),k4-k1);&#125;db rand_db()&#123;return 1.0*rand()/RAND_MAX;&#125;VP convexHull2D(VP A,P3 dir)&#123; P3 x=&#123;(db)rand(),(db)rand(),(db)rand()&#125;; x=x.unit(); x=cross(x,dir).unit(); P3 y=cross(x,dir).unit(); P3 vec=dir.unit()*dot(A[0],dir); vector&lt;point&gt;B; for (int i=0;i&lt;A.size();i++) B.push_back((point)&#123;dot(A[i],x),dot(A[i],y)&#125;); B=ConvexHull(B); A.clear(); for (int i=0;i&lt;B.size();i++) A.push_back(x*B[i].x+y*B[i].y+vec); return A;&#125;namespace CH3&#123; VVP ret; set&lt;pair&lt;int,int&gt; &gt;e; int n; VP p,q; void wrap(int a,int b)&#123; if (e.find(&#123;a,b&#125;)==e.end())&#123; int c=-1; for (int i=0;i&lt;n;i++) if (i!=a&amp;&amp;i!=b)&#123; if (c==-1||sign(getV(q[c],q[a],q[b],q[i]))&gt;0) c=i; &#125; if (c!=-1)&#123; ret.push_back(&#123;p[a],p[b],p[c]&#125;); e.insert(&#123;a,b&#125;); e.insert(&#123;b,c&#125;); e.insert(&#123;c,a&#125;); wrap(c,b); wrap(a,c); &#125; &#125; &#125; VVP ConvexHull3D(VP _p)&#123; p=q=_p; n=p.size(); ret.clear(); e.clear(); for (auto &amp;i:q) i=i+(P3)&#123;rand_db()*1e-4,rand_db()*1e-4,rand_db()*1e-4&#125;; for (int i=1;i&lt;n;i++) if (q[i].x&lt;q[0].x) swap(p[0],p[i]),swap(q[0],q[i]); for (int i=2;i&lt;n;i++) if ((q[i].x-q[0].x)*(q[1].y-q[0].y)&gt;(q[i].y-q[0].y)*(q[1].x-q[0].x)) swap(q[1],q[i]),swap(p[1],p[i]); wrap(0,1); return ret; &#125;&#125;VVP reduceCH(VVP A)&#123; VVP ret; map&lt;P3,VP&gt; M; for (VP nowF:A)&#123; P3 dir=cross(nowF[1]-nowF[0],nowF[2]-nowF[0]).unit(); for (P3 k1:nowF) M[dir].pb(k1); &#125; for (pair&lt;P3,VP&gt; nowF:M) ret.pb(convexHull2D(nowF.se,nowF.fi)); return ret;&#125;// 把一个面变成 ( 点 , 法向量 ) 的形式pair&lt;P3,P3&gt; getF(VP F)&#123; return mp(F[0],cross(F[1]-F[0],F[2]-F[0]).unit());&#125;// 3D Cut 保留 dot(dir,x-p)&gt;=0 的部分VVP ConvexCut3D(VVP A,P3 p,P3 dir)&#123; VVP ret; VP sec; for (VP nowF: A)&#123; int n=nowF.size(); VP ans; int dif=0; for (int i=0;i&lt;n;i++)&#123; int d1=sign(dot(dir,nowF[i]-p)); int d2=sign(dot(dir,nowF[(i+1)%n]-p)); if (d1&gt;=0) ans.pb(nowF[i]); if (d1*d2&lt;0)&#123; P3 q=getFL(p,dir,nowF[i],nowF[(i+1)%n])[0]; ans.push_back(q); sec.push_back(q); &#125; if (d1==0) sec.push_back(nowF[i]); else dif=1; dif|=(sign(dot(dir,cross(nowF[(i+1)%n]-nowF[i],nowF[(i+1)%n]-nowF[i])))==-1); &#125; if (ans.size()&gt;0&amp;&amp;dif) ret.push_back(ans); &#125; if (sec.size()&gt;0) ret.push_back(convexHull2D(sec,dir)); return ret;&#125;db vol(VVP A)&#123; if (A.size()==0) return 0; P3 p=A[0][0]; db ans=0; for (VP nowF:A) for (int i=2;i&lt;nowF.size();i++) ans+=abs(getV(p,nowF[0],nowF[i-1],nowF[i])); return ans/6;&#125;VVP init(db INF) &#123; VVP pss(6,VP(4)); pss[0][0] = pss[1][0] = pss[2][0] = &#123;-INF, -INF, -INF&#125;; pss[0][3] = pss[1][1] = pss[5][2] = &#123;-INF, -INF, INF&#125;; pss[0][1] = pss[2][3] = pss[4][2] = &#123;-INF, INF, -INF&#125;; pss[0][2] = pss[5][3] = pss[4][1] = &#123;-INF, INF, INF&#125;; pss[1][3] = pss[2][1] = pss[3][2] = &#123;INF, -INF, -INF&#125;; pss[1][2] = pss[5][1] = pss[3][3] = &#123;INF, -INF, INF&#125;; pss[2][2] = pss[4][3] = pss[3][1] = &#123;INF, INF, -INF&#125;; pss[5][0] = pss[4][0] = pss[3][0] = &#123;INF, INF, INF&#125;; return pss;&#125;","categories":[],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://aoudad.cn/tags/计算几何/"}]},{"title":"线段树模板","slug":"线段树模板","date":"2018-12-28T13:13:24.000Z","updated":"2019-02-11T14:19:26.772Z","comments":true,"path":"2018/12/28/线段树模板/","link":"","permalink":"http://aoudad.cn/2018/12/28/线段树模板/","excerpt":"","text":"题意描述线段树还不是很熟练，拿个Amori的线段树板子 InputOutputSample InputSample Output题意：思路：代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081ll ans[maxn*4];int a[maxn];ll tag[maxn*4];ll sum(ll a,ll b)&#123; return a+b;&#125;void build(int o,int l,int r)&#123; if(l==r) &#123; ans[o]=a[l]; return; &#125; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; build(lson,l,m); build(rson,m+1,r); ans[o]=sum(ans[lson], ans[rson]);&#125;void update(int o,int l,int r,int ql,int qr,int k)//区间修改:将[l,r]区间每个数都加上k&#123; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; if(ql&lt;=l&amp;&amp;qr&gt;=r) &#123; ans[o]+=k*(r-l+1) tag[o]+=k; return; &#125; if(tag[o]) &#123; tag[lson]+=tag[o]; tag[rson]+=tag[o]; ans[lson]+=tag[o]*(m-l+1) ans[rson]+=tag[o]*(r-m); tag[o]=0; &#125; if(qr&lt;=m) update(lson,l,m,ql,qr,k); else if(ql&gt;m) update(rson,m+1,r,ql,qr,k); else &#123; update(lson,l,m,ql,qr,k); update(rson,m+1,r,ql,qr,k); &#125; ans[o]=ans[lson]+ans[rson];&#125;void update_p(int o,int l,int r,int x,int y)//单点修改:将a[x]加上y&#123; if(L==R) &#123; ans[o]+=y return; &#125; int m=(l+r)/2,lson=o&lt;&lt;1,rson=lson|1; if(x&lt;=m)update(lson,l,m,x,y); else update(rson,m+1,r,x,y); ans[o]=ans[lson]+ans[rson];&#125;ll query(int o,int l,int r,int ql,int qr)//区间查询&#123; int lson=o&lt;&lt;1,rson=lson|1; int m=(l+r)&gt;&gt;1; if(ql&lt;=l&amp;&amp;qr&gt;=r) return ans[o]; if(tag[o]) &#123; tag[lson]+=tag[o]; tag[rson]+=tag[o]; ans[lson]+=tag[o]*(m-l+1) ans[rson]+=tag[o]*(r-m); tag[o]=0; &#125; if(qr&lt;=m) return query(lson,l,m,ql,qr); if(ql&gt;m) return query(rson,m+1,r,ql,qr); return query(lson,l,m,ql,qr)+query(rson,m+1,r,ql,qr);&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://aoudad.cn/tags/线段树/"}]},{"title":"Codeforces1091Div2D-The Fair Nut and the Best Path","slug":"Codeforces1091Div2D","date":"2018-12-10T20:11:10.000Z","updated":"2019-02-11T14:17:23.159Z","comments":true,"path":"2018/12/11/Codeforces1091Div2D/","link":"","permalink":"http://aoudad.cn/2018/12/11/Codeforces1091Div2D/","excerpt":"","text":"题意描述outputstandard outputThe Fair Nut is going to travel to the Tree Country, in which there are n cities. Most of the land of this country is covered by forest. Furthermore, the local road system forms a tree (connected graph without cycles). Nut wants to rent a car in the city u and go by a simple path to city v. He hasn’t determined his way, so it’s time to do it. A filling station is located in every city. Because of strange law, Nut can buy only wi liters of gasoline in the i-th city. We can assume, that he has infinite money. Each road has a length, and as soon as Nut drives through this road, the amount of gasoline decreases by length. Of course, Nut can’t choose a path, which consists of roads, where he runs out of gasoline. He can buy gasoline in every visited city, even in the first and the last. A path can consist of only one vertex. He also wants to find the maximum amount of gasoline that he can have at the end of the path. Help him: count it. InputThe first line contains a single integer n (1≤n≤3⋅105) — the number of cities.The second line contains n integers w1,w2,…,wn (0≤wi≤109) — the maximum amounts of liters of gasoline that Nut can buy in cities.Each of the next n−1 lines describes road and contains three integers u, v, c (1≤u,v≤n, 1≤c≤109, u≠v), where u and v — cities that are connected by this road and c — its length.It is guaranteed that graph of road connectivity is a tree. OutputPrint one number — the maximum amount of gasoline that he can have at the end of the path. Sample Input31 3 31 2 21 3 2 56 3 2 5 01 2 102 3 32 4 11 5 1 Sample Output3 7 题意：给一棵n个节点的树， 每个节点上都有一个权值$w_i$，每条边上有一个花费$c_i$，任意选择起点u和终点v(u和v可以是同一个节点)，定义价值$x(u, v)$为从起点u到终点v的路径上所有的节点的权值之和减去所有的边的花费最大，输出这个最大值，其中，到达任任何一个节点的前一瞬间，x不能是负数。输出最大的x。 思路：树上dp。以节点1为起点dfs，$dp[u]=w[u]+max(0, max(dp[v]-c[u, v]))$,其中dp[i]表示，额，好像没有特别明确的含义，大概是表示经过i节点的最大收益吧，显然不一定非要从叶子节点一直push到根节点，也可以中间节点的某两条子树路径是答案，因此需要拿到(dp[v]-c[u, v])中的最大的两个值，这里可以O(n)做，但是由于排序O(nlogn)是没有卡的，所以直接排序也是可以的，但是我在比赛中用了很蠢的O(n^2)，不知道自己是怎么想的，然后愉快的fst了，掉分哭唧唧。然后就xjb更新答案就行了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll mod = 1000000007;const ll maxn = 5e5+7;ll a[maxn];vector&lt;pair&lt;ll, ll&gt; &gt; G[maxn];int vis[maxn];ll ans = -1;ll dfs(int f, int u, ll c)&#123; ll res = a[u]; vector&lt;ll&gt; tmp; for(int i=0;i&lt;G[u].size();++i) &#123; if(G[u][i].first==f)continue; ll t = dfs(u, G[u][i].first, G[u][i].second); res = max(res, t+a[u]); tmp.push_back(t); &#125; sort(tmp.begin(), tmp.end(), greater&lt;ll&gt;()); tmp.push_back(0); tmp.push_back(0); ans = max(a[u]+tmp[0]+tmp[1], ans); ans = max(ans, res); return res-c;&#125;int main()&#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;++i) cin &gt;&gt; a[i]; for(int i=0;i&lt;n-1;++i) &#123; ll u, v, c; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; G[u].push_back(make_pair(v, c)); G[v].push_back(make_pair(u, c)); &#125; dfs(0, 1, 0); cout &lt;&lt; ans &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"树上DP","slug":"树上DP","permalink":"http://aoudad.cn/tags/树上DP/"}]},{"title":"Codeforces1091Div2E-The Fair Nut and Strings","slug":"Codeforces526Div2E","date":"2018-12-10T19:37:32.000Z","updated":"2019-02-11T14:17:08.468Z","comments":true,"path":"2018/12/11/Codeforces526Div2E/","link":"","permalink":"http://aoudad.cn/2018/12/11/Codeforces526Div2E/","excerpt":"","text":"题意描述Recently, the Fair Nut has written k strings of length n, consisting of letters “a” and “b”. He calculated c — the number of strings that are prefixes of at least one of the written strings. Every string was counted only one time. Then, he lost his sheet with strings. He remembers that all written strings were lexicographically not smaller than string s and not bigger than string t. He is interested: what is the maximum value of c that he could get. A string a is lexicographically smaller than a string b if and only if one of the following holds: a is a prefix of b, but a≠b; in the first position where a and b differ, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b.Input The first line contains two integers n and k (1≤n≤5⋅105, 1≤k≤$10^9$).The second line contains a string s (|s|=n) — the string consisting of letters “a” and “b.The third line contains a string t (|t|=n) — the string consisting of letters “a” and “b.It is guaranteed that string s is lexicographically not bigger than t. OutputPrint one number — maximal value of c. Sample Input2 4aabb 3 3ababba 4 5abbbbaaa Sample Output6 8 8 题意：给两个只由字符ab构成的长度为n的字符串s、t，保证s的字典序一定小于t，求字典序小于t且大于s的所有长度为n的字符串中选出k个，使得从中得到的本质不同的前缀的数量最大，输出这个最大值。 思路：比赛的时候想了一下没有k这个限制的做法，然后没有往深的地方想，结束之后发现原来做法是差不太多的。考虑一个完全二叉字典树，其中每个节点最多只有两个儿子，也就是‘a’和’b’，将s和t插进去，显然答案就是从这个字典树中s的叶子结点和t的叶子节点之间选出k个叶子节点，使得这k条路经上的总结点数最大。但是由于我们只需要统计数量，因此不需要真的把这棵树建起来，我们通过观察这颗字典树可以发现，假设s[i-1]和t[i-1]在树上的距离为d（也就是他们之间的同级节点的个数加1），则分类讨论，当s[i]=t[i]时，他们相对于s[i-1]和t[i-1]的方向都相同，因此的距离为2d-1，如果s[i]&gt;t[i]，那么距离为2d,否则距离为2*d-2。口胡式证明正确性：当两个节点之间的距离小于k的时候，显然每条路径都经过是最优的，当两个节点之间的距离大于k的时候，直接加上k就可以了。首先这样的做法肯定是达到了上界，没有其他做法能比这样的策略获得的贡献更大，其次，如果这层节点的上一层节点距离已经可以走k条路经，显然这一层也可以走k条路经，如果上一层的距离小于k，那么这一层的每个节点肯定都是可达的，可行性得证。所以这个做法是没毛病的。实现起来比较简单。 代码：123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123; ll n, k; string s, t; cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s &gt;&gt; t; ll ans = 0, tmp = 1; for(int i=0;i&lt;n;++i) if(tmp&lt;k) &#123; tmp &lt;&lt;= 1; if(s[i]==t[i]) --tmp; else if(s[i]=='b'&amp;&amp;t[i]=='a')tmp-=2; tmp = min(tmp, k); &#125; ans += tmp; cout &lt;&lt;ans &lt;&lt;endl;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://aoudad.cn/tags/贪心/"}]},{"title":"Project Euler","slug":"Project-Euler","date":"2018-11-23T18:20:17.000Z","updated":"2019-02-11T14:19:06.022Z","comments":true,"path":"2018/11/24/Project-Euler/","link":"","permalink":"http://aoudad.cn/2018/11/24/Project-Euler/","excerpt":"","text":"代码：1234567891011121314151617181920212223242526272829// P21#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; set&lt;int&gt; res; for(int i=1;i&lt;=10000;++i) &#123; int tmp = 1; for(int j=2;j*j&lt;=i;++j) &#123; if(i%j==0) tmp += j + i/j; if(j*j==i) tmp -= j; &#125; int t = 1; for(int j=2;j*j&lt;=tmp;++j) &#123; if(tmp%j==0) t += j + tmp/j; if(j*j==tmp) t -= j; &#125; if(t==i&amp;&amp;i!=tmp)res.insert(t), res.insert(i); &#125; int ans = 0; for(auto x:res)ans += x; cout &lt;&lt; ans &lt;&lt; endl;&#125; 123456789101112131415# P22with open(\"in.txt\") as f: s = f.read().split(',') res = 0 cnt = 0 s.sort() for item in s: cnt += 1 tmp = 0 for p in item: if p != '\"': tmp += ( ord(p)-ord('A')+1 ) res += tmp * cnt if item == '\"COLIN\"':print(tmp,cnt,item)print(res) 12345678910111213141516171819202122232425262728293031323334//P23#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint vis[30000];int main()&#123; vector&lt;int&gt; res; for(int i=1;i&lt;=28123;++i) &#123; int tmp = 1; for(int j=2;j*j&lt;=i;++j) &#123; if(i%j==0) tmp += i/j+j; if(j*j==i) tmp -= j; &#125; if(tmp&gt;i) res.push_back(i); &#125; long long ans = 0; for(int i=0;i&lt;res.size();++i) for(int j=i;j&lt;res.size();++j) if(res[i]+res[j]&gt;28123) break; else vis[res[i]+res[j]]++; for(int i=1;i&lt;=28123;++i) if(!vis[i]) ans += i; cout &lt;&lt; ans &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334P24康拓展开裸题#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint vis[30000];static const int FAC[] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; // 阶乘//康托展开逆运算void decantor(int x, int n)&#123; vector&lt;int&gt; v; // 存放当前可选数 vector&lt;int&gt; a; // 所求排列组合 for(int i=0;i&lt;=n;i++) v.push_back(i); for(int i=10;i&gt;=1;i--) &#123; int r = x % FAC[i-1]; int t = x / FAC[i-1]; x = r; sort(v.begin(),v.end());// 从小到大排序 a.push_back(v[t]); // 剩余数里第t+1个数为当前位 v.erase(v.begin()+t); // 移除选做当前位的数 &#125; for(auto x: a) cout &lt;&lt; x &lt;&lt; ' ' ;&#125;int main()&#123; decantor(999999, 10);&#125; 1234567#P25L = []L.append(1)L.append(1)while(L[-1]&lt;pow(10,999)): L.append(L[-1]+L[-2])print(len(L))","categories":[],"tags":[{"name":"Project_Euler","slug":"Project-Euler","permalink":"http://aoudad.cn/tags/Project-Euler/"}]},{"title":"poj1837","slug":"poj1837","date":"2018-11-23T16:24:31.000Z","updated":"2019-02-11T14:18:49.887Z","comments":true,"path":"2018/11/24/poj1837/","link":"","permalink":"http://aoudad.cn/2018/11/24/poj1837/","excerpt":"","text":"题意描述Gigel has a strange “balance” and he wants to poise it. Actually, the device is different from any other ordinary balance.It orders two arms of negligible weight and each arm’s length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 &lt;= G &lt;= 20) knowing that these weights have distinct values in the range 1..25. Gigel may droop any weight of any hook but he is forced to use all the weights.Finally, Gigel managed to balance the device using the experience he gained at the National Olympiad in Informatics. Now he would like to know in how many ways the device can be balanced. Knowing the repartition of the hooks and the set of the weights write a program that calculates the number of possibilities to balance the device.It is guaranteed that will exist at least one solution for each test case at the evaluation. InputThe input has the following structure:• the first line contains the number C (2 &lt;= C &lt;= 20) and the number G (2 &lt;= G &lt;= 20);• the next line contains C integer numbers (these numbers are also distinct and sorted in ascending order) in the range -15..15 representing the repartition of the hooks; each number represents the position relative to the center of the balance on the X axis (when no weights are attached the device is balanced and lined up to the X axis; the absolute value of the distances represents the distance between the hook and the balance center and the sign of the numbers determines the arm of the balance to which the hook is attached: ‘-‘ for the left arm and ‘+’ for the right arm);• on the next line there are G natural, distinct and sorted in ascending order numbers in the range 1..25 representing the weights’ values. OutputThe output contains the number M representing the number of possibilities to poise the balance. Sample Input2 4-2 33 4 5 8 Sample Output2 题意：天平上有n个不同位置的挂钩，有m种不同质量的钩码，求有多少种让天平平衡的方法。钩码需要全部用上。 思路：设$dp[i][j]$表示前i个钩码，使目前天平的力矩为j的方案有多少种，其中j==0时表示天平平衡。则对于当前第i个钩码如果状态j可以由j-w[i]c[k]得到，那么加上它的方案数.即$$dp[i][j]=\\Sigma_{k=0}^ndp[i][j-w[i]p[k]]$$当然此时j作为下标不能是负数，因此往正方向移动（201525=7500位）。注意处理一下$j-w[i]p[k]$超过范围时不考虑。当然也可以换成扫$j-w[i]p[k]$，这样还可以剪枝。 代码：123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define ll long longint dp[2][15002], p[50], w[70];int main()&#123; int n, m, t = 0; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;++i) cin &gt;&gt; p[i]; for(int i=0;i&lt;m;++i) cin &gt;&gt; w[i]; dp[t][7500] = 1; for(int i=0;i&lt;m;++i) &#123; t^=1; memset(dp[t], 0, sizeof dp[t]); for(int j=0;j&lt;=15000;++j) if(dp[1^t][j]) for(int k=0;k&lt;n;++k) dp[t][j+w[i]*p[k]] += dp[t^1][j]; &#125; cout &lt;&lt; dp[t][7500] &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://aoudad.cn/tags/DP/"}]},{"title":"2018青岛区域赛总结","slug":"2018青岛区域赛总结","date":"2018-11-12T14:24:16.000Z","updated":"2018-11-12T14:24:30.886Z","comments":true,"path":"2018/11/12/2018青岛区域赛总结/","link":"","permalink":"http://aoudad.cn/2018/11/12/2018青岛区域赛总结/","excerpt":"","text":"成绩题数：5题罚时：626排名：Rank56奖牌：银牌 比赛过程：热身赛算是第一次参加热身赛【省赛那个也不算吧，当时还一脸懵逼不知道要干嘛刚开始我在搞机器，amori很快看完了所有题目，然后告诉了我做法让我写，然而我不知道是紧张还是什么原因，码的磕磕绊绊的，还直接wa了一发，然后换amori上来写A和B，我看了一下C，感觉是放上来做压力测试的，就不打算交了，打算测其他的东西的时候PC^2挂掉了，于是又等了许久恢复后才继续测其他的，发现了行末空格会返回OFE，评测实在是太慢了，就没测能跑多大的时间复杂度了， 反正也是要莽。 热身赛当晚由于下午的时候我的状态实在是太差，于是当晚拉了几道简单题做，事实证明这是我们当时做的最正确的决定之一了，因为不仅调整了状态，而且还使我(们)更加了解队友的思维习惯和学习经历，而且还刚好做了一道二分最大化最小值的问题。 正式赛当天比赛开始，还是按照原本的开题顺序，amori从头，cmr从D开始，而我先去搞了一下机器和调了下gedit，调好之后看了一眼M，感觉是个签到题，往下一扫，签到成功这是你的签到奖励.jpg，果断直接开始写，交上去1A，然后扫了一眼榜，C和J有人过，然后amori给我讲了J的题意，讨论了一下就开始写了，WA，换amori写，39minA。这时我发现有支中学生队过了G，于是觉得这应该是一个算法题而非思维题，从过的那么快来看amori可能是可做的，于是我就忽悠amori去看G，然后这家伙就看漏题意了。Amori过J之后我和cmr就开始一边讨论C一边写，63min的时候1A。这个时候刷了一下榜，发现冲上了金线【然而并没有什么卵用】，开始了长达一个小时的挂机时间，期间amori和cmr给我讲了BDEFGLK的题意，然而其中有4个题目都是没讲清楚的，L感觉是要推出组合公式，因为看起来就没有啥递推式，然后就自闭了，然后果断把这道题丢给cmr，去仔细的看了一下F题，发现是个构造题，应该是当时最可做的，于是和cmr一边讨论一边写一边调，然后发现是写挫了，换了个写法交上去161min1A，此时大概在银牌头的位置。amori确定了E二分加贪心的做法，避开了爆longlong的坑，但是忘了特判，于是又开始了长达一个小时的xjb搞+莽的自闭时间，所幸250min的时候利用随机数据找到了问题，过了。然后就开始了本次比赛最傻逼的时间。看了看榜，在没有歪榜的情况下，D和L应该是最可做的，但是当时的心态，实在是太跳了，虽然D和L看起来可做但是没有很用心思考。列了列L小数据的答案，决定果断放弃【。然后和cmr一起口头D题，说出了正解，但是很快被我随口说了一个ac自动机给糊弄了，然后还忽悠amori去写了，然后就发现做法不对，浪费了宝贵的半个小时，于是剩下的时间就在吃东西和吹水了。最终是毫无悬念的5题银牌，罚时还算是比较能看的，除了E题，相比我们平时训练来说。 总结首先结论，这次的银牌，关键原因是因为运气好，因为我们队三个人都相信换成大二的其他队伍来QD赛区成绩都应该和我们差不多。其次，这次做得比较好的是，热身赛的时候发现状态不对，当晚便选择做了几道简单题来调整状态。再其次，更加信任队友了，虽然信任了但还是没做出来L，但势必会使得后面的训练更加融洽。再再其次，这次前期没有特别明显的卡题，中期没有死咬着一道题不放。然后，这次暴露出来的比较明显的缺点（主要是指我）是，对于不确定方法对不对的题目，即使是在中后期，我都很难下决心去试试，这个在平时训练的时候已经显示出来了，但是一直没有重视。因为cmr不是代码手，而这种题目一般不经过amori的手，所以我不写的话不行。再然后，还是出现了读错题/读漏题的情况，原本在没有思路的时候我应该把每个题目再好好读一遍的，结果还是没有，这种情况不改的话，随着每个队员能力的提升，对队伍的影响会越来越大。再再然后就是最本质的解题能力太差的问题，包括常规套路和思维题的训练都太少。 未来从下周起直到十二月初的选拔赛结束为止【可能会更久，也可能根据实际情况修改】，我们队都以个人的单挑实力提升为主，在没有其他变数的情况下，每周只会有一场左右的队伍训练。1，在训练时应同时注意常规算法套路和思维题【抖机灵题】的训练。2，注意涉及的广度，尽量做到每个知识点即使没法很快做出来，在和队友讨论或者经提醒之后能知道怎么做，至少在比赛中能和队友讨论相关做法。3，注意深度，对于自己擅长的领域，要做到不依赖任何人和搜索引擎的情况下能独立解出有一定综合难度的问题。4，对今年的杭电多校牛客多校要注意补题。5，关注codeforces的比赛6，注意代码实现能力的培养@cmr。","categories":[],"tags":[]},{"title":"POJ1840Eqs","slug":"POJ1840Eqs","date":"2018-11-08T16:05:58.000Z","updated":"2019-02-11T14:18:55.704Z","comments":true,"path":"2018/11/09/POJ1840Eqs/","link":"","permalink":"http://aoudad.cn/2018/11/09/POJ1840Eqs/","excerpt":"","text":"题意描述Consider equations having the following form:a1x1 3+ a2x2 3+ a3x3 3+ a4x4 3+ a5x5 3=0The coefficients are given integers from the interval [-50,50].It is consider a solution a system (x1, x2, x3, x4, x5) that verifies the equation, xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}. Determine how many solutions satisfy the given equation. InputThe only line of input contains the 5 coefficients a1, a2, a3, a4, a5, separated by blanks. OutputThe output will contain on the first line the number of the solutions for the given equation. Sample Input37 29 41 43 47 Sample Output654 题意：求满足那个方程的解的个数。 思路：数据范围较小，考虑暴力枚举，对$a_1x_1^3+a_2x_2^3+a_3x_3^3+a_4x_4^3+a_5x_5^3=0$变形得$-(a_1x_1^3+a_2x_2^3)=a_3x_3^3+a_4x_4^3+a_5x_5^3$，枚举左边，存一个hash表，hash[i]表示左边和为i的方案数，再枚举右边即可获取答案。复杂度$O(100^3)$，另外由于可能出现负数，所以要做一下偏移。思路和折半枚举类似，但是那个可以做浮点数的。 代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const int s = 25000000;short res[s+10];int main()&#123; int a[5]; for(int i=0;i&lt;5;++i) cin &gt;&gt; a[i]; for(int i=-50;i&lt;=50;++i) for(int j=-50;j&lt;=50;++j) if(i!=0&amp;&amp;j!=0)&#123; int t = i*i*i*a[0]+j*j*j*a[1];t*=-1; if(t&lt;0) t += s; res[t]++; &#125; long long ans = 0; for(int i=-50;i&lt;=50;++i) for(int j=-50;j&lt;=50;++j) for(int k=-50;k&lt;=50;++k) if(i!=0&amp;&amp;j!=0&amp;&amp;k!=0)&#123; int t = i*i*i*a[2]+j*j*j*a[3]+k*k*k*a[4]; if(t&lt;0) t += s; ans += res[t]; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;","categories":[],"tags":[]},{"title":"BZOJ1002轮状病毒","slug":"BZOJ1002轮状病毒","date":"2018-11-08T15:30:04.000Z","updated":"2019-02-11T14:15:41.836Z","comments":true,"path":"2018/11/08/BZOJ1002轮状病毒/","link":"","permalink":"http://aoudad.cn/2018/11/08/BZOJ1002轮状病毒/","excerpt":"","text":"题意描述轮状病毒有很多变种，所有轮状病毒的变种都是从一个轮状基产生的。一个N轮状基由圆环上N个不同的基原子和圆心处一个核原子构成的，2个原子之间的边表示这2个原子之间的信息通道。N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不同的3轮状病毒。现给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒 Input第一行有1个正整数n Output计算出的不同的n轮状病毒数输出 Sample Input3 Sample Output16 题意：给一个车轮状的无向图，生成树计数。 思路：利用基尔霍夫矩阵树定理，打表获得n为3到9时的答案，扔进BM板子里获得递推式，用java的BigInteger根据递推式写出答案。 代码：12345678910111213141516171819import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;import java.math.BigInteger; public class Main&#123; public static void main(String[] args) &#123; Scanner cin=new Scanner(System.in); int n=cin.nextInt(); BigInteger[] arr = new BigInteger[101]; arr[0] = new BigInteger(\"1\"); arr[1] = new BigInteger(\"1\"); arr[2] = new BigInteger(\"5\"); arr[3] = new BigInteger(\"16\"); for(int i=4;i&lt;=n;++i) arr[i] = arr[i-1].subtract(arr[i-2]).multiply(new BigInteger(\"4\")).add(arr[i-3]); System.out.println(arr[n]); &#125;&#125;","categories":[],"tags":[{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"http://aoudad.cn/tags/矩阵树定理/"}]},{"title":"BZOJ1001狼抓兔子","slug":"BZOJ1001狼抓兔子","date":"2018-11-08T15:18:29.000Z","updated":"2019-02-11T14:15:21.139Z","comments":true,"path":"2018/11/08/BZOJ1001狼抓兔子/","link":"","permalink":"http://aoudad.cn/2018/11/08/BZOJ1001狼抓兔子/","excerpt":"","text":"题意描述现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路 1:(x,y)&lt;==&gt;(x+1,y) 2:(x,y)&lt;==&gt;(x,y+1) 3:(x,y)&lt;==&gt;(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为N,M.表示网格的大小，N,M均小于等于1000.接下来分三部分第一部分共N行，每行M-1个数，表示横向道路的权值.第二部分共N-1行，每行M个数，表示纵向道路的权值.第三部分共N-1行，每行M-1个数，表示斜向道路的权值.输入文件保证不超过10M Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input3 4 5 6 4 4 3 1 7 5 3 5 6 7 8 8 7 6 5 5 5 5 6 6 6 Sample Output14 题意：给一个网格图，求其最小割。 思路：显然就是给一个无向图，求 S(1，1)到T(n，m)的最小割，但是这里套用普通的dinic等最大流算法是会tle/mle/re的，因为n，m都是1e3的。由于给的是一个平面图，将其转化为对偶图，求最短路即可。对偶图可以在这里学习，最大最小定理(平面图最小割 对偶图)。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=0x3f3f3f3f;const int MAXN=2000110;struct qnode&#123; int v; int c; qnode(int _v=0,int _c=0):v(_v),c(_c) &#123;&#125; bool operator &lt;(const qnode &amp;r)const &#123; return c&gt;r.c; &#125;&#125;;struct Edge&#123; int v,cost; Edge(int _v=0,int _cost=0):v(_v),cost(_cost) &#123;&#125;&#125;;vector&lt;Edge&gt;E[MAXN];bool vis[MAXN];int dist[MAXN];void Dijkstra(int n,int start)&#123; memset(vis,false,sizeof(vis)); for(int i=1; i&lt;=n; i++) dist[i]=INF; priority_queue&lt;qnode&gt;que; while(!que.empty()) que.pop(); dist[start]=0; que.push(qnode(start,0)); qnode tmp; while(!que.empty()) &#123; tmp=que.top(); que.pop(); int u=tmp.v; if(vis[u]) continue; vis[u]=true; for(int i=0; i&lt;E[u].size(); i++) &#123; int v=E[tmp.v][i].v; int cost=E[u][i].cost; if(!vis[v]&amp;&amp;dist[v]&gt;dist[u]+cost) &#123; dist[v]=dist[u]+cost; que.push(qnode(v,dist[v])); &#125; &#125; &#125;&#125;void addedge(int u,int v,int w)&#123; E[u].push_back(Edge(v,w)); E[v].push_back(Edge(u,w));&#125;int main()&#123; int n, m, a; scanf(\"%d%d\", &amp;n, &amp;m); if(n==1) &#123; int mi = 1e9; for(int i=0;i&lt;m-1;++i)&#123;scanf(\"%d\", &amp;a);mi = min(mi, a);&#125; cout &lt;&lt; mi &lt;&lt; endl; return 0; &#125; if(m==1) &#123; int mi = 1e9; for(int i=0;i&lt;n-1;++i)&#123;scanf(\"%d\", &amp;a);mi = min(mi, a);&#125; cout &lt;&lt; mi &lt;&lt; endl; return 0; &#125; int S = (n-1)*(m-1)*2+1, T = S+1; for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;m-1; ++j) &#123; scanf(\"%d\", &amp;a); if(i==0) addedge(S, j+1, a); else if(i==n-1) addedge(2*i*(m-1)-m+j+2, T, a); else addedge(2*i*(m-1)+j-m+2,2*i*(m-1)+j+1, a); &#125; for(int i=0; i&lt;n-1; ++i) for(int j=0; j&lt;m; ++j) &#123; scanf(\"%d\", &amp;a); if(j==m-1) addedge(S, 2*i*(m-1)+j, a); else if(j==0)addedge(2*i*(m-1)+m, T, a); else addedge(2*i*(m-1)+j, 2*i*(m-1)+j+m, a); &#125; for(int i=0; i&lt;n-1; ++i) for(int j=0; j&lt;m-1; ++j) &#123; scanf(\"%d\", &amp;a); addedge(2*(m-1)*i+j+1, 2*(m-1)*i+j+m, a); &#125; Dijkstra(T, S); cout &lt;&lt; dist[T] &lt;&lt; endl;&#125;","categories":[],"tags":[{"name":"最小割","slug":"最小割","permalink":"http://aoudad.cn/tags/最小割/"}]},{"title":"zuidadaiquanebihezitu","slug":"zuidadaiquanebihezitu","date":"2018-11-01T15:28:00.000Z","updated":"2019-02-11T14:19:16.857Z","comments":true,"path":"2018/11/01/zuidadaiquanebihezitu/","link":"","permalink":"http://aoudad.cn/2018/11/01/zuidadaiquanebihezitu/","excerpt":"","text":"题意描述先说结论，以后有空再补，最大权闭合子图的权值等于所有正权点之和减去最小割 InputOutputSample InputSample Output题意：思路：代码：1","categories":[],"tags":[]},{"title":"各种板子","slug":"temp","date":"2018-10-14T17:53:21.000Z","updated":"2019-02-11T14:19:11.914Z","comments":true,"path":"2018/10/15/temp/","link":"","permalink":"http://aoudad.cn/2018/10/15/temp/","excerpt":"","text":"BM线性递推式板子先手算/打表找出序列的前几项，然后扔进这两个板子里就可以了，其中杜教的板子可以直接求出第n项的值，而meto的板子则是可以求出递推式，一般8，9项就可以了，需要的项数取决于这个递推式所涉及的项，当然这个序列必须得是线性的 Meto的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-7;const int maxn=1e5;vector&lt;double&gt;ps[maxn+10];int fail[maxn+10];double x[maxn+10],delta[maxn+10];int n,pn;int main()&#123; while(~scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; pn=0; for(int i=1; i&lt;=n; i++) scanf(\"%lf\",x+i); for(int i=1; i&lt;=n; i++) &#123; double dt=-x[i]; for(int j=0; j&lt;ps[pn].size(); j++) dt+=x[i-j-1]*ps[pn][j]; delta[i]=dt; if(fabs(dt)&lt;=eps) continue; fail[pn]=i; if(!pn) &#123; ps[++pn].resize(1); continue; &#125; vector&lt;double&gt; &amp;ls=ps[pn-1]; double k=-dt/delta[fail[pn-1]]; vector&lt;double&gt;cur; cur.resize(i-fail[pn-1]-1); cur.push_back(-k); for(int j=0; j&lt;ls.size(); j++) cur.push_back(ls[j]*k); if(cur.size()&lt;ps[pn].size()) cur.resize(ps[pn].size()); for(int j=0; j&lt;ps[pn].size(); j++) cur[j]+=ps[pn][j]; ps[++pn]=cur; &#125; int len=(int)ps[pn].size(); for(int i=0; i&lt;len; ++i) printf(\"%g%c\",ps[pn][i],\" \\n\"[i==len-1]); &#125; return 0;&#125; 杜教的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b)&#123; ll res=1; a%=mod; assert(b&gt;=0); for(; b; b&gt;&gt;=1) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; &#125; return res;&#125;// headint _,n;namespace linear_seq&#123;const int N=10010;ll res[N],base[N],_c[N],_md[N];vector&lt;int&gt; Md;void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1; i&gt;=k; i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i];&#125;int solve(ll n,VI a,VI b) // a 系数 b 初值 b[n+1]=a[0]*b[n]+...&#123;// printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt; p&gt;=0; p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1; i&gt;=0; i--) res[i+1]=res[i]; res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans;&#125;VI BM(VI s)&#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C;&#125;int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));&#125;&#125;;int main()&#123; ll n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v&#123;1,5,11,36,95,281,781,2245,6336,18061&#125;; printf(\"%d\\n\",linear_seq::gao(v,n-1)); &#125;&#125; 例题：HDU6172，HDU6185 其中6185的打表代码为： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mz[10][15];int x, y, n,cnt;int ok()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) if(mz[i][j]==0) &#123; x=i;y=j; return false; &#125; return 1;&#125;void s()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) printf(\"%d%c\", mz[i][j], \" \\n\"[j==n]);&#125;void dfs(int i, int j)&#123; //s(); if(i&lt;=3&amp;&amp;mz[i+1][j]==0) &#123; mz[i][j]=mz[i+1][j]=1; if(ok()) &#123; mz[i][j]=mz[i+1][j]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i+1][j]=0; &#125; if(j&lt;n&amp;&amp;mz[i][j+1]==0) &#123; mz[i][j]=mz[i][j+1]=1; if(ok()) &#123; mz[i][j]=mz[i][j+1]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i][j+1]=0; &#125;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) &#123; memset(mz, 0, sizeof mz); n = i;cnt=0;dfs(1, 1); cout &lt;&lt; cnt &lt;&lt; ','; &#125;&#125; 快速读入123456789101112131415161718192021222324252627282930313233343536// fast IOnamespace fastIO&#123; #define BUF_SIZE 100000 // fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE, *pend = buf+BUF_SIZE; if(p1==pend)&#123; p1 = buf; pend = buf+fread(buf, 1, BUF_SIZE, stdin);// cout &lt;&lt; 23 &lt;&lt; endl; if(pend==p1)&#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank( char ch ) &#123; return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t'; &#125; inline void read(int &amp;x) &#123; char ch; while(blank(ch=nc())); if(IOerror) return ; for(x=ch-'0';(ch=nc())&gt;='0'&amp;&amp;ch&lt;='9';x=x*10+ch-'0'); &#125; #undef BUF_SIZE&#125;using namespace fastIO; 第K短路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt; using namespace std;#define INF 0xffffff#define MAXN 100010struct node&#123; int to; int val; int next;&#125;;struct node2&#123; int to; int g,f; bool operator&lt;(const node2 &amp;r ) const &#123; if(r.f==f) return r.g&lt;g; return r.f&lt;f; &#125; &#125;;node edge[MAXN],edge2[MAXN];int n,m,s,t,k,cnt,cnt2,ans;int dis[1010],visit[1010],head[1010],head2[1010];void init()&#123; memset(head,-1,sizeof(head)); memset(head2,-1,sizeof(head2)); cnt=cnt2=1;&#125;void addedge(int from,int to,int val)&#123; edge[cnt].to=to; edge[cnt].val=val; edge[cnt].next=head[from]; head[from]=cnt++;&#125;void addedge2(int from,int to,int val)&#123; edge2[cnt2].to=to; edge2[cnt2].val=val; edge2[cnt2].next=head2[from]; head2[from]=cnt2++;&#125;bool spfa(int s,int n,int head[],node edge[],int dist[]) &#123; queue&lt;int&gt;Q1; int inq[1010]; for(int i=0;i&lt;=n;i++) &#123; dis[i]=INF; inq[i]=0; &#125; dis[s]=0; Q1.push(s); inq[s]++; while(!Q1.empty()) &#123; int q=Q1.front(); Q1.pop(); inq[q]--; if(inq[q]&gt;n) return false; int k=head[q]; while(k&gt;=0) &#123; if(dist[edge[k].to]&gt;dist[q]+edge[k].val) &#123; dist[edge[k].to]=edge[k].val+dist[q]; if(!inq[edge[k].to]) &#123; inq[edge[k].to]++; Q1.push(edge[k].to); &#125; &#125; k=edge[k].next; &#125; &#125; return true; &#125;int A_star(int s,int t,int n,int k,int head[],node edge[],int dist[]) &#123; node2 e,ne; int cnt=0; priority_queue&lt;node2&gt;Q; if(s==t) k++; if(dis[s]==INF) return -1; e.to=s; e.g=0; e.f=e.g+dis[e.to]; Q.push(e); while(!Q.empty()) &#123; e=Q.top(); Q.pop(); if(e.to==t)//找到一条最短路径 &#123; cnt++; &#125; if(cnt==k)//找到k短路 &#123; return e.g; &#125; for(int i=head[e.to]; i!=-1; i=edge[i].next) &#123; ne.to=edge[i].to; ne.g=e.g+edge[i].val; ne.f=ne.g+dis[ne.to]; Q.push(ne); &#125; &#125; return -1; &#125; int main()&#123; while(~scanf(\"%d%d\",&amp;n,&amp;m)) &#123; init(); for(int i=1;i&lt;=m;i++) &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); addedge(a,b,c); addedge2(b,a,c); &#125; scanf(\"%d%d%d\",&amp;s,&amp;t,&amp;k); spfa(t,n,head2,edge2,dis); ans=A_star(s,t,n,k,head,edge,dis); printf(\"%d\\n\",ans); &#125; return 0;&#125; 阶乘逆元线性预处理1234fac[0]=fac[1]=1;for(int i=2;i&lt;=MAXN;i++) fac[i]=fac[i-1]*i%mod;inv[MAXN]=quipow(fac[MAXN],mod-2);for(int i=MAXN-1;i&gt;=0;i--)inv[i]=inv[i+1]*(i+1)%mod; 线性求所有数的逆元12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int A[100001];int p;int main()&#123; cin&gt;&gt;p; A[1]=1; for(int i=2;i&lt;=10;i++) &#123; A[i]=(p-(p/i))*A[p%i]%p; printf(\"%d %d %d\\n\",i,A[i],(i*A[i])%p); &#125;&#125; SG函数模板123456789101112131415161718192021//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[N];//可以取走的石子个数int sg[N];//0~n的SG函数值int Hash[N]; void getSG(int n)&#123; memset(sg,0,sizeof(sg)); for(int i = 1; i &lt;= n; i++)&#123; memset(Hash,0,sizeof(Hash)); for(int j = 1; f[j] &lt;= i; j++) Hash[sg[i-f[j]]] = 1; for(int j = 0; j &lt;= n; j++)&#123; //求mes&#123;&#125;中未出现的最小的非负整数 if(Hash[j] == 0)&#123; sg[i] = j; break; &#125; &#125; &#125;&#125; 数位dp基本模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef long long ll;int a[20];ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零&#123; //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 &#123; if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ &#125; //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans;&#125;ll solve(ll x)&#123; int pos=0; while(x)//把数位都分解出来 &#123; a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; &#125; return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true); //刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛&#125;int main()&#123; ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri)) &#123; //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(\"%lld\\n\",solve(ri)-solve(le-1)); &#125;&#125; n queen11, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624, 4968057848, 39029188884, 314666222712, 2691008701644, 24233937684440, 227514171973736, 2207893435808352, 22317699616364044, 234907967154122528 最大最小表示模板12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+5;char s[maxn&lt;&lt;1];inline int max(int a,int b)&#123;return a&gt;b?a:b;&#125;inline int min(int a,int b)&#123;return a&lt;b?a:b;&#125;int MINR(char s[],int l)&#123; //s是原串（未加倍过），l是原串长 for(int i=0;i&lt;l;++i)s[l+i]=s[i]; //将s串加倍 s[2*l]=0; int i=0,j=1; //利用i，j指针移动 while(i&lt;l&amp;&amp;j&lt;l)&#123; int k=0; while(s[i+k]==s[j+k]&amp;&amp;k&lt;l)++k; //不断比较直到比较完长度为l的串或两个子串不相等 if(k==l)return min(i,j); //若比较出长度为l则直接返回靠前的那个串的开始位置 if(s[i+k]&gt;s[j+k])i=max(i+k+1,j+1); //i串比j串大，那么i到i+k中的串都比j串大，i可以直接移动到i+k+1位置，而起始位置比j小的肯定都在j移动过程中比较过，所以i可以直接移动到j+1位置，因此取这两值的最大值 else j=max(j+k+1,i+1); //同上 &#125; return min(i,j); //返回位置靠前的下标&#125;int MAXR(char s[],int l)&#123; for(int i=0;i&lt;l;++i)s[l+i]=s[i]; s[2*l]=0; int i=0,j=1; while(i&lt;l&amp;&amp;j&lt;l)&#123; int k=0; while(s[i+k]==s[j+k]&amp;&amp;k&lt;l)++k; if(k==l)return min(i,j); if(s[i+k]&lt;s[j+k])i=max(i+k+1,j+1); else j=max(j+k+1,i+1); &#125; return min(i,j);&#125; 长整型乘法取模123456LL mul(LL a, LL b, LL c)&#123; const double eps = 1e-8; a %= c, b %= c; LL ans = a * b - (LL)((long double)a*b/c+eps)*c; return ans &lt; 0 ? ans+c : ans;&#125; 快速统计1-n范围内的素数个数12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define chkbit(ar, i) (((ar[(i) &gt;&gt; 6]) &amp; (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define setbit(ar, i) (((ar[(i) &gt;&gt; 6]) |= (1 &lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))#define isprime(x) (( (x) &amp;&amp; ((x)&amp;1) &amp;&amp; (!chkbit(ar, (x)))) || ((x) == 2))namespace pcf&#123; long long dp[MAXN][MAXM]; unsigned int ar[(MAX &gt;&gt; 6) + 5] = &#123;0&#125;; int len = 0, primes[MAXP], counter[MAX]; void Sieve()&#123; setbit(ar, 0), setbit(ar, 1); for (int i = 3; (i * i) &lt; MAX; i++, i++)&#123; if (!chkbit(ar, i))&#123; int k = i &lt;&lt; 1; for (int j = (i * i); j &lt; MAX; j += k) setbit(ar, j); &#125; &#125; for (int i = 1; i &lt; MAX; i++)&#123; counter[i] = counter[i - 1]; if (isprime(i)) primes[len++] = i, counter[i]++; &#125; &#125; void init()&#123; Sieve(); for (int n = 0; n &lt; MAXN; n++)&#123; for (int m = 0; m &lt; MAXM; m++)&#123; if (!n) dp[n][m] = m; else dp[n][m] = dp[n - 1][m] - dp[n - 1][m / primes[n - 1]]; &#125; &#125; &#125; long long phi(long long m, int n)&#123; if (n == 0) return m; if (primes[n - 1] &gt;= m) return 1; if (m &lt; MAXM &amp;&amp; n &lt; MAXN) return dp[n][m]; return phi(m, n - 1) - phi(m / primes[n - 1], n - 1); &#125; long long Lehmer(long long m)&#123; if (m &lt; MAX) return counter[m]; long long w, res = 0; int i, a, s, c, x, y; s = sqrt(0.9 + m), y = c = cbrt(0.9 + m); a = counter[y], res = phi(m, a) + a - 1; for (i = a; primes[i] &lt;= s; i++) res = res - Lehmer(m / primes[i]) + Lehmer(primes[i]) - 1; return res; &#125;&#125; Lucas 定理用于计算二项式系数C(n, m)被质数 p 除的所得的余数123456789101112LL Cm(LL n,LL m,LL p)&#123; LL a=1,b=1; if(m&gt;n)return 0; while(m)&#123; a=(a*n--)%p; b=(b*m--)%p; &#125; return a*inv(b,p)%p;&#125;LL Lucas(LL n,LL m,LL p)&#123; return m?Cm(n%p,m%p,p)*Lucas(n/p,m/p,p)%p:1;&#125; simpson积分12345678910111213141516double simpson(double L,double R,int n)&#123; const double h=(R-L)/n; double ans=f(L)+f(R); for(int i=1;i&lt;n;i+=2)ans+=4*f(L+i*h); for(int i=2;i&lt;n;i+=2)ans+=2*f(L+i*h); return ans*h/3;&#125;double asr(double L,double R,double eps,double A)&#123; double mid=L+(R-L)/2; double Ls=simpson(L,mid,2),Rs=simpson(mid,R,2); if(fabs(Ls+Rs-A)&lt;=15*eps)return Ls+Rs+(Ls+Rs-A)/15.0; return asr(L,mid,eps/2,Ls)+asr(mid,R,eps/2,Rs);&#125;double asr(double L,double R,double eps)&#123; return asr(L,R,eps,simpson(L,R,2));&#125; 对于指定日期，计算星期几。1234567int whatday(int y,int m,int d)&#123; if(m&lt;3)m+=12,y--; if(y&lt;1752||y==1752&amp;&amp;m&lt;9||y==1752&amp;&amp;m==9&amp;&amp;d&lt;3) return (d+2*m+3*(m+1)/5+y+y/4+5)%7; else return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;&#125;","categories":[],"tags":[]},{"title":"BM线性递推式板子","slug":"BM线性递推式板子","date":"2018-10-14T17:53:21.000Z","updated":"2019-02-11T14:14:56.936Z","comments":true,"path":"2018/10/15/BM线性递推式板子/","link":"","permalink":"http://aoudad.cn/2018/10/15/BM线性递推式板子/","excerpt":"","text":"描述先手算/打表找出序列的前几项，然后扔进这两个板子里就可以了，其中杜教的板子可以直接求出第n项的值，而meto的板子则是可以求出递推式，一般8，9项就可以了，需要的项数取决于这个递推式所涉及的项，当然这个序列必须得是线性的 Meto的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;const double eps=1e-7;const int maxn=1e5;vector&lt;double&gt;ps[maxn+10];int fail[maxn+10];double x[maxn+10],delta[maxn+10];int n,pn;int main()&#123; while(~scanf(\"%d\",&amp;n)&amp;&amp;n) &#123; pn=0; for(int i=1; i&lt;=n; i++) scanf(\"%lf\",x+i); for(int i=1; i&lt;=n; i++) &#123; double dt=-x[i]; for(int j=0; j&lt;ps[pn].size(); j++) dt+=x[i-j-1]*ps[pn][j]; delta[i]=dt; if(fabs(dt)&lt;=eps) continue; fail[pn]=i; if(!pn) &#123; ps[++pn].resize(1); continue; &#125; vector&lt;double&gt; &amp;ls=ps[pn-1]; double k=-dt/delta[fail[pn-1]]; vector&lt;double&gt;cur; cur.resize(i-fail[pn-1]-1); cur.push_back(-k); for(int j=0; j&lt;ls.size(); j++) cur.push_back(ls[j]*k); if(cur.size()&lt;ps[pn].size()) cur.resize(ps[pn].size()); for(int j=0; j&lt;ps[pn].size(); j++) cur[j]+=ps[pn][j]; ps[++pn]=cur; &#125; int len=(int)ps[pn].size(); for(int i=0; i&lt;len; ++i) printf(\"%g%c\",ps[pn][i],\" \\n\"[i==len-1]); &#125; return 0;&#125; 杜教的板子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b)&#123; ll res=1; a%=mod; assert(b&gt;=0); for(; b; b&gt;&gt;=1) &#123; if(b&amp;1) res=res*a%mod; a=a*a%mod; &#125; return res;&#125;// headint _,n;namespace linear_seq&#123;const int N=10010;ll res[N],base[N],_c[N],_md[N];vector&lt;int&gt; Md;void mul(ll *a,ll *b,int k)&#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1; i&gt;=k; i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i];&#125;int solve(ll n,VI a,VI b) // a 系数 b 初值 b[n+1]=a[0]*b[n]+...&#123;// printf(\"%d\\n\",SZ(b)); ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i]; _md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt; p&gt;=0; p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1; i&gt;=0; i--) res[i+1]=res[i]; res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans;&#125;VI BM(VI s)&#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C;&#125;int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));&#125;&#125;;int main()&#123; ll n; while (cin &gt;&gt; n) &#123; vector&lt;int&gt;v&#123;1,5,11,36,95,281,781,2245,6336,18061&#125;; printf(\"%d\\n\",linear_seq::gao(v,n-1)); &#125;&#125; 例题：HDU6172，HDU6185 其中6185的打表代码为： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mz[10][15];int x, y, n,cnt;int ok()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) if(mz[i][j]==0) &#123; x=i;y=j; return false; &#125; return 1;&#125;void s()&#123; for(int i=1;i&lt;=4;++i) for(int j=1;j&lt;=n;++j) printf(\"%d%c\", mz[i][j], \" \\n\"[j==n]);&#125;void dfs(int i, int j)&#123; //s(); if(i&lt;=3&amp;&amp;mz[i+1][j]==0) &#123; mz[i][j]=mz[i+1][j]=1; if(ok()) &#123; mz[i][j]=mz[i+1][j]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i+1][j]=0; &#125; if(j&lt;n&amp;&amp;mz[i][j+1]==0) &#123; mz[i][j]=mz[i][j+1]=1; if(ok()) &#123; mz[i][j]=mz[i][j+1]=0; ++cnt; return ; &#125; dfs(x, y); mz[i][j]=mz[i][j+1]=0; &#125;&#125;int main()&#123; for(int i=1;i&lt;=10;++i) &#123; memset(mz, 0, sizeof mz); n = i;cnt=0;dfs(1, 1); cout &lt;&lt; cnt &lt;&lt; ','; &#125;&#125;","categories":[],"tags":[{"name":"BM","slug":"BM","permalink":"http://aoudad.cn/tags/BM/"}]},{"title":"poj2109","slug":"poj2109","date":"2018-10-07T14:53:56.000Z","updated":"2019-02-11T14:19:01.008Z","comments":true,"path":"2018/10/07/poj2109/","link":"","permalink":"http://aoudad.cn/2018/10/07/poj2109/","excerpt":"","text":"题意描述Current work in cryptography involves (among other things) large prime numbers and computing powers of numbers among these primes. Work in this area has resulted in the practical use of results from number theory and other branches of mathematics once considered to be only of theoretical interest.This problem involves the efficient computation of integer roots of numbers.Given an integer n&gt;=1 and an integer p&gt;= 1 you have to write a program that determines the n th positive root of p. In this problem, given such integers n and p, p will always be of the form k to the n th. power, for an integer k (this integer is what your program must find). InputThe input consists of a sequence of integer pairs n and p with each integer on a line by itself. For all such pairs 1&lt;=n&lt;= 200, 1&lt;=p&lt;10^101 and there exists an integer k, $1\\le k\\le10^9$ such that k^n = p. OutputFor each integer pair n and p the value k should be printed, i.e., the number k such that $k^n=p$. Sample Input2 163 277 4357186184021382204544 Sample Output431234 题意：给定两个正整数n和p，求一个整数k使得$k^n=p$，保证这样的整数k一定存在 思路：原本想着二分加高精度或者直接用JAVA二分的，搜了一下直接用double和pow就可以了，因为在这道题中，整数k一定存在且$1\\le k\\le10^9$，因此k的有效位数最大为9，double的精度够用，直接pow没毛病。 代码：1234567891011#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; double n, m; while(cin &gt;&gt; n &gt;&gt; m) cout &lt;&lt; (int)(pow(m, 1.0/n)+0.3) &lt;&lt; '\\n';&#125;","categories":[],"tags":[]},{"title":"20180927Training","slug":"20180927Training","date":"2018-09-28T08:36:41.000Z","updated":"2019-02-11T14:14:30.867Z","comments":true,"path":"2018/09/28/20180927Training/","link":"","permalink":"http://aoudad.cn/2018/09/28/20180927Training/","excerpt":"","text":"训练结果训练赛题目： Gym 101572过题数： 3题 ( B, I, J )终榜rank： 97/298 过程：13:45分左右Amori才过来，所以从这时候开始做题，J签到题，B题给Amori解释题意之后，他给了个暴力的做法，然后我上去写写了很久写挂了，换他上去写，同时他把D题题意告诉了我，还提到了可能是道图论题，然而我并没有往那边想2333。然后他码了一会儿就AC了，我没啥想法就码了个D的假做法交上去，果不其然WA10，然后我把G题题意描述了一下，Amori给出了很多方案，比如用set维护等，但是因为没有一个具体的方案所以我都给拒绝了2333，然后我开了I题，发现这题可做，建个有向图然后找最小环即可，然后我就因为字符串读入写挂，建图写自闭了。之后换Amori上去写写写就过了【1.25e8都能过也太cf了】，然后看了一眼E死活看不懂题意就放弃了。 总结：这场主要还是一些很常见的套路，然后大概比较注重思维，理论上能做的题目还是挺多的，但是还是做的不好，大概是周四下午的状态一直都很不好吧，然后我应该调整一下自己的性格，队伍自己不了解/没听懂的东西不应该直接cha掉，也要注重队友的想法，然后青岛赛还有一个月就要开始了，这场有可能是数据结构和数学数论题专场，所以接下来训练会集中在这几个领域吧，然后现在的题目越来越注重思维了，所以原本打算放弃的cf也得拾起来，现在争取每两天刷完一场div2，每三天刷完一场div1吧。 题目（按过题顺序）： Problem J: Judging Moose 题意：签到题 思路：签到题 代码：12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int l, r; cin &gt;&gt; l &gt;&gt; r; if(l==0&amp;&amp;r==0) puts(\"Not a moose\"); else if(l==r) printf(\"Even %d\\n\", l+r); else printf(\"Odd %d\\n\", max(l, r) * 2);&#125; Problem B: Best Relay Team 题意：给两个长度为n的序列（$4\\le n \\le 500$）{$a_1, a_2, \\dots,\\a_n$}与{$b_1, b_2, \\dots,\\b_n$},其中$2\\le a_i, b_i\\le 20$，找出四个不同的下标$i_1, i_2, i_3,i_4$使得$a_{i1}+b_{i2}+b_{i3}+b_{i4}$最小 思路：直接枚举a较小或b较小的那几个就可以了【然而我蜜汁写挂了】 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;struct sol&#123; int id; double val; string name;&#125;;bool cmp(sol a,sol b)&#123; return a.val&lt;b.val;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; sol a[505],b[505]; for(int i=1;i&lt;=n;i++) &#123; a[i].id=b[i].id=i; cin&gt;&gt;a[i].name; b[i].name=a[i].name; cin&gt;&gt;a[i].val; cin&gt;&gt;b[i].val; &#125; sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); map&lt;int,int&gt;mpa; map&lt;int,int&gt;mpb; for(int i=1;i&lt;=n;i++) &#123; mpa[a[i].id]=i; mpb[b[i].id]=i; &#125; double ans=1e9; vector&lt;int&gt;res; for(int i=1;i&lt;=n;i++) &#123; double sum=0; vector&lt;int&gt;v; sum+=a[i].val; v.push_back(a[i].id); while(1) &#123; int cnt=0; for(int j=1;j&lt;=n;j++) &#123; if(b[j].id!=a[i].id) &#123; sum+=b[j].val; cnt++; v.push_back(b[j].id); &#125; if(cnt==3) break; &#125; if(cnt==3) break; &#125; if(ans&gt;sum) &#123; ans=sum; res=v; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;a[mpa[res[0]]].name&lt;&lt;endl; for(int i=1;i&lt;4;i++) cout&lt;&lt;b[mpb[res[i]]].name&lt;&lt;endl; &#125;&#125; Problem I: Import Spaghetti 题意：给一个有向图，求最小环 思路：根据题意建一个有向图，然后跑floyd求最小环，然后对最小环bfs求出路径【然后我建图写自闭了】 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e2+5;int G[maxn][maxn];const int INF = 1e7;int n;vector&lt;int&gt;g[maxn];map&lt;int,string&gt; mp2;void floyd()&#123; int i,j,k; for(k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(G[i][j]&gt;G[i][k]+G[k][j]) G[i][j]=G[i][k]+G[k][j];&#125;int mark;int fa[maxn];void dfs(int cur)&#123; if(cur==mark) &#123; cout&lt;&lt;mp2[cur]&lt;&lt;\" \"; return; &#125; dfs(fa[cur]); cout&lt;&lt;mp2[cur]&lt;&lt;\" \";&#125;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=n;++j) G[i][j]=INF; string s; map&lt;string, int&gt; mp; mp2.clear(); for(int i=0;i&lt;n;++i) &#123; cin &gt;&gt; s; mp[s] = i; mp2[i]=s; &#125; int k ; for(int i=0;i&lt;n;++i) &#123; cin &gt;&gt; s &gt;&gt; k; getchar(); for(int p=0;p&lt;k;++p)&#123; getline(cin, s); int l = s.length(); string tmp=\"\"; for(int j=7;j&lt;l;++j) &#123; if(s[j]==' ') continue; if(s[j]==',') &#123; G[i][mp[tmp]] = 1; g[i].push_back(mp[tmp]); tmp = \"\"; &#125; else tmp = tmp + s[j]; &#125; G[i][mp[tmp]] = 1; g[i].push_back(mp[tmp]); &#125; &#125; floyd(); int ans=INF; mark=-1; for(int i=0;i&lt;n;i++) &#123; if(G[i][i]&lt;ans) &#123; ans=G[i][i]; mark=i; &#125; &#125; if(ans==INF) &#123; puts(\"SHIP IT\"); return 0; &#125; queue&lt;int&gt;q; q.push(mark); memset(fa,-1,sizeof fa); while(!q.empty()) &#123; int cur=q.front(); q.pop(); if(cur==mark&amp;&amp;fa[cur]!=-1) break; for(int i=0;i&lt;g[cur].size();i++) &#123; int p=g[cur][i]; if(fa[p]==-1) &#123; fa[p]=cur; q.push(p); &#125; &#125; &#125; dfs(fa[mark]);&#125; Problem G: Galactic Collegiate Programming Contest 题意：有n支队伍，m个事件，每个事件包括p和t，表示p队在时间t做出了一道题，相同题数下时间t总和小的排名靠前，相同的并列，求每一个事件之后1队的排名。 思路：【比赛中觉得是平衡树的裸题，但是太菜了不会，还cha掉了amori一些有可能做出来的思路2333】其实可以直接用multiset维护当前排名在1队之前的队伍数量，每个事件如果是1队，则直接修改1队的信息就可以，否则如果在这之前队伍p排名在1之前，则先拿出来修改，如果在p之后，则直接修改，之后都扔进multiset里，从最后开始如果比1队排名靠后就删掉。最后multiset的大小再加一就是1队的rank，需要注意的是multiset的删除要用**.erase(迭代器)**，不然会把所有的值都删掉的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+7;struct Node&#123; int p, t; bool operator&lt;(const Node&amp; a)const &#123; if(p!=a.p) return p &gt; a.p; return t &lt; a.t; &#125;&#125; ans[maxn];int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; multiset&lt;Node&gt; res; for(int i=0; i&lt;m; ++i) &#123; int p, t; cin &gt;&gt; p &gt;&gt; t; if(p==1) &#123; ans[1].p ++; ans[1].t += t; &#125; else &#123; if(ans[p]&lt;ans[1]) res.erase(res.find(ans[p])); ans[p].p ++; ans[p].t += t; res.insert(ans[p]); &#125; while(!res.empty()&amp;&amp; !( *--res.end()&lt;ans[1] ) ) res.erase(--res.end()); cout &lt;&lt;res.size() + 1 &lt;&lt; endl; &#125;&#125; Problem D: Distinctive Character 题意：给n个k长度的01串，定义两个01串之间的距离为两个串位与位之间字符相同的个数，求出使到这n个串的最大距离最小的01串 思路：比赛场上想到了可能和最短路有关，但是没有深入去思考。可以定义$f(S)$表示01串S到给定串的最大距离，则有$f(a_i)$=k，由他们改变其中其中一个位的得到的串的f函数值应该是k（该串已经在$a_i$中）或者k-1，用队列维护一下。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int f[1&lt;&lt;21], vis[1&lt;&lt;21];int main()&#123; int n, k;queue&lt;int&gt; q; cin &gt;&gt; n &gt;&gt; k; for(int i=0;i&lt;n;++i) &#123; string s;int tmp=0; cin &gt;&gt; s; for(int j=0;j&lt;k;++j) tmp = (tmp&lt;&lt;1)+s[j]-'0'; f[tmp] = k; vis[tmp] = 1; q.push(tmp); &#125; int x, y; while(!q.empty()) &#123; x = q.front();q.pop(); for(int j=0;j&lt;k;++j) &#123; y = x^(1&lt;&lt;j); if(!vis[y]) &#123; vis[y]=1; f[y] = f[x]-1; q.push(y); &#125; &#125; &#125; for(int i=k-1;i&gt;=0;--i) cout &lt;&lt; ((x&gt;&gt;i)&amp;1);// cout &lt;&lt; endl;&#125;","categories":[],"tags":[]},{"title":"2018ACM-ICPC青岛赛区网络赛A","slug":"2018ACM-ICPC青岛赛区网络赛A","date":"2018-09-19T16:48:43.000Z","updated":"2019-02-11T14:14:08.522Z","comments":true,"path":"2018/09/20/2018ACM-ICPC青岛赛区网络赛A/","link":"","permalink":"http://aoudad.cn/2018/09/20/2018ACM-ICPC青岛赛区网络赛A/","excerpt":"","text":"题意描述DreamGrid is playing the music game Live Love. He has just finished a song consisting of $n$ notes and got a result sequence $A_1,A_2,\\dots,A_n$ ( $A_i \\in$ {PERFECT, NON-PERFECT}). The score of the song is equal to the $\\textit{max-combo}$ of the result sequence, which is defined as the maximum number of continuous PERFECTs in the sequence. Formally speaking, $\\text{max-combo}(A) = \\max\\{ k | k$ is an integer and there exists an integer $i$ ($1 \\le i \\le n-k+1$) such that $A_i = A_{i+1} = A_{i+2} = \\dots = A_{i+k-1} = PERFECT\\}$. For completeness, we define max($\\emptyset$) = 0. As DreamGrid is forgetful, he forgets the result sequence immediately after finishing the song. All he knows is the sequence length $n$ and the total number of PERFECTs in the sequence, indicated by $m$. Any possible score $s$ he may get must satisfy that there exists a sequence $A’$ of length $n$ containing exactly $m$ PERFECTs and $(n-m)$ NON-PERFECTs and \\text{max-combo}(A’) = s. Now he needs your help to find the maximum and minimum $s$ among all possible scores. InputThere are multiple test cases. The first line of the input contains an integer $T$($1 \\le T \\le 100$), indicating the number of test cases. For each test case: The only line contains two integers $n$ and $m$ ($1 \\le n \\le 10^3$, $0\\le m \\le 10^3$, $m\\le n$), indicating the sequence length and the number of PERFECTs DreamGrid gets. OutputFor each test case output one line containing two integers $s_{max}$ and $s_{min}$ , indicating the maximum and minimum possible score. Sample Input55 4100 50252 523 010 10 Sample Output4 250 152 10 010 10 题意：给一个含有m个1的01序列，求该序列连续的1的最大长度的最大值和最小值 思路：m即为最大值，0尽量均分1时得到最小值，除一下上取整即可，0特殊处理一下 代码：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std; int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; LL n, m; cin &gt;&gt; n &gt;&gt; m; if (m == 0) cout &lt;&lt; \"0 0\" &lt;&lt; endl; else cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (m - 1) / (n - m + 1) +1 &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"2018ACM-ICPC青岛赛区网络赛","slug":"2018ACM-ICPC青岛赛区网络赛","permalink":"http://aoudad.cn/tags/2018ACM-ICPC青岛赛区网络赛/"}]},{"title":"2018ACM-ICPC青岛赛区网络赛K","slug":"2018ACM-ICPC青岛赛区网络赛K","date":"2018-09-19T09:34:03.000Z","updated":"2019-02-11T14:14:21.650Z","comments":true,"path":"2018/09/19/2018ACM-ICPC青岛赛区网络赛K/","link":"","permalink":"http://aoudad.cn/2018/09/19/2018ACM-ICPC青岛赛区网络赛K/","excerpt":"","text":"题目描述：BaoBao has a sequence $a_1,a_2,\\dots,a_n$. He would like to find a subset $S$ of $\\{1, 2, \\dots, n\\}$ such that $\\forall i, j \\in S$, $a_i \\oplus a_j &lt; \\min(a_i,a_j)$ and $|S|$ is maximum, where means bitwise exclusive or. InputThere are multiple test cases. The first line of input contains an integer $T$ , indicating the number of test cases. For each test case:The first line contains an integer $n$ ($1\\le n \\le 10^5$), indicating the length of the sequence.The second line contains n integers: $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$), indicating the sequence.It is guaranteed that the sum of $n$ in all cases does not exceed $10^5$. OutputFor each test case, output an integer denoting the maximum size of $S$ . 题意给n个数，从中选出最大的子集合，使得该集合中的数两两之间的异或值小于他们各自本身，输出最大的子集合大小。 思路：当两个数的最大二进制位不同时，两者的异或值肯定大于两者中的较小值，故按照二进制位最高位的位置来分组，输出最大那一组的大小即可。 代码：1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 32;int ans[maxn];int main()&#123; int T; cin &gt;&gt; T; while(T--) &#123; int n, x; scanf(\"%d\", &amp;n); memset(ans, 0, sizeof(ans)); while(n--) &#123; scanf(\"%d\", &amp;x); int t = 0; while(x) &#123; x&gt;&gt;=1; ++t; &#125; ++ans[t]; &#125; printf(\"%d\\n\", *max_element(ans, ans+maxn)); &#125;&#125;","categories":[],"tags":[{"name":"2018ACM-ICPC青岛赛区网络赛","slug":"2018ACM-ICPC青岛赛区网络赛","permalink":"http://aoudad.cn/tags/2018ACM-ICPC青岛赛区网络赛/"}]}]}